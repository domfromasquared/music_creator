<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>RetroLoop Studio — Drum Sequencer + Piano Roll</title>
  <style>
    :root{
      --bg:#0f1115;
      --ink:#e9eef5;
      --muted:#97a3b6;

      --btn:#22283a;
      --btn2:#2a3150;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --groupA:#121a28;
      --groupB:#211a2f;
      --inactiveOverlay: rgba(0,0,0,0.38);
      --playheadOutline: rgba(255,255,255,0.30);
      --beatDivider: rgba(255,255,255,0.18);
      --dragOutline: rgba(255,255,255,0.45);
      --dragFill: rgba(255,255,255,0.10);

      --kick: rgba(255,139,90,0.95);
      --snare: rgba(88,166,255,0.92);
      --clap: rgba(255,255,255,0.88);

      --shaker: rgba(186, 140, 255, 0.90);
      --ch: rgba(124,255,178,0.92);     /* closed hat */
      --oh: rgba(255, 210, 120, 0.92);  /* open hat */

      --rollBg: rgba(0,0,0,.18);
      --rollStrip: rgba(0,0,0,.32);
      --gridLine: rgba(255,255,255,.06);
      --gridBeat: rgba(255,255,255,.14);

      --whiteKeyA: rgba(255,255,255,0.92);
      --whiteKeyB: rgba(255,255,255,0.82);
      --blackKeyA: rgba(12,14,20,0.98);
      --blackKeyB: rgba(22,24,32,0.98);
      --keyBorder: rgba(0,0,0,0.35);

      --rowWhiteA: rgba(255,255,255,.03);
      --rowWhiteB: rgba(255,255,255,.015);
      --rowBlack: rgba(0,0,0,.22);

      --pianoNote: rgba(124,255,178,.85);
      --bassNote: rgba(88,166,255,.80);
      --synthNote: rgba(255,139,90,.78);

      --knobFill: rgba(0,140,255,.95);
      --knobBg: rgba(0,0,0,.30);
      --knobGlow: rgba(0,140,255,.28);

      --knobFillPiano: rgba(124,255,178,.95);
      --knobGlowPiano: rgba(124,255,178,.28);

      --knobFillSynth: rgba(255,139,90,.95);
      --knobGlowSynth: rgba(255,139,90,.28);

      --knobFillBass: rgba(88,166,255,.95);
      --knobGlowBass: rgba(88,166,255,.28);

      --knobFillDrum: rgba(255,255,255,.92);
      --knobGlowDrum: rgba(255,255,255,.18);

      --knobFillFx: rgba(186,140,255,.92);
      --knobGlowFx: rgba(186,140,255,.22);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 20% -10%, #1b2040 0%, transparent 60%),
                  radial-gradient(900px 500px at 90% 0%, #223022 0%, transparent 55%),
                  var(--bg);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 18px;
    }
    h1{margin:0 0 6px 0; font-size:18px; letter-spacing:.2px}
    .sub{color:var(--muted); margin:0 0 16px 0; font-size:13px}

    .wrap{
      display:grid;
      grid-template-columns: 440px 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.07);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .title{
      font-size:13px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.12em
    }
    .bd{padding: 12px}

    button{
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ink);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 700;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:disabled{opacity:.5; cursor:not-allowed}

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    input[type="range"]{width: 150px}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:8px;
      background: rgba(0,0,0,.25);
      color: var(--ink);
    }
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}

    /* --- Mute/Solo buttons --- */
    .msBtns{display:flex; gap:6px; align-items:center}
    .msBtn{
      padding: 6px 9px;
      border-radius: 10px;
      font-size: 12px;
      line-height: 1;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      user-select:none;
    }
    .msBtn.active{
      color: var(--ink);
      border-color: rgba(255,255,255,.28);
      background: rgba(255,255,255,.10);
    }
    .msBtn.mute.active{
      background: rgba(255,80,80,.18);
      border-color: rgba(255,80,80,.35);
    }
    .msBtn.solo.active{
      background: rgba(124,255,178,.14);
      border-color: rgba(124,255,178,.30);
    }

    /* --- Compact Mixer --- */
    .mixer{
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
    }
    .mixerTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .mixerTitle{
      font-size:12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .12em;
    }
    .mixerGrid{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
    }
    @media (max-width: 980px){
      .mixerGrid{grid-template-columns: repeat(2, minmax(0, 1fr));}
    }
    .strip{
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.16);
      padding: 10px;
      min-width: 0;
    }
    .stripHd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom: 8px;
    }
    .stripName{
      font-weight: 800;
      font-size: 12px;
      letter-spacing: .06em;
      color: var(--ink);
      white-space:nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .stripRow{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
    }
    .stripKnobs{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .kCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      width: 54px;
    }
    .kLbl{
      font-size: 10px;
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase;
      user-select:none;
    }
    .kMiniVal{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      width: 48px;
      text-align:center;
      user-select:none;
    }

    /* Knob */
    .knobWrap{display:flex; align-items:center; justify-content:flex-end; gap:8px; flex: 0 0 auto;}
    .knob{
      width:34px;
      height:34px;
      border-radius:999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.10), rgba(0,0,0,.24)), var(--knobBg);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25), 0 0 0 2px rgba(0,0,0,.12);
      position:relative;
      touch-action:none;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .knob::before{
      content:"";
      position:absolute;
      inset:4px;
      border-radius:999px;
      background:
        conic-gradient(from 225deg,
          var(--knobFill) 0deg,
          var(--knobFill) var(--knobDeg),
          rgba(255,255,255,.10) var(--knobDeg),
          rgba(255,255,255,.10) 270deg
        );
      filter: drop-shadow(0 0 10px var(--knobGlow));
      mask: radial-gradient(circle, transparent 55%, #000 56%);
      -webkit-mask: radial-gradient(circle, transparent 55%, #000 56%);
    }
    .knobDot{
      position:absolute;
      left:50%;
      top:50%;
      width:4px;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.85);
      transform-origin: 50% calc(100% + 4px);
      transform: translate(-50%,-90%) rotate(var(--knobRot));
      opacity:.9;
    }
    .knobVal{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      width: 44px;
      text-align:center;
    }

    /* Drum */
    .drumGrid{
      display:grid;
      grid-template-columns: 160px minmax(0, 1fr);
      gap:10px;
      align-items:start;
      touch-action: none;
    }
    .trackNames{display:grid; gap:8px;}
    .trackName{
      height:40px;
      border-radius: 12px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.08);
      padding: 6px 8px;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .trackLabel{
      font-size:12px;
      color: var(--muted);
      text-transform:uppercase;
      letter-spacing:.08em;
      line-height:1;
      flex: 1 1 auto;
      min-width: 0;
    }

    .steps{
      display:grid;
      gap:8px;
      overflow:hidden;
      border-radius: 12px;
      min-width: 0;
    }
    .rowSteps{
      display:grid;
      gap:6px;
      height:40px;
      align-items:stretch;
      touch-action: none;
      width: 100%;
      min-width: 0;
    }
    .cell{
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      position:relative;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      min-width: 0;
    }
    .cell.groupA{ background: var(--groupA); }
    .cell.groupB{ background: var(--groupB); }
    .cell::after{
      content:"";
      position:absolute;
      inset:0;
      background: var(--inactiveOverlay);
      opacity:.55;
      pointer-events:none;
    }
    .cell.on::after{opacity:.07}

    .cell.on.kick{  background: linear-gradient(180deg, var(--kick), rgba(255,139,90,0.45)); border-color: rgba(255,139,90,0.75); }
    .cell.on.snare{ background: linear-gradient(180deg, var(--snare),rgba(88,166,255,0.30)); border-color: rgba(88,166,255,0.65); }
    .cell.on.clap{  background: linear-gradient(180deg, var(--clap), rgba(255,255,255,0.18)); border-color: rgba(255,255,255,0.45); }
    .cell.on.shaker{ background: linear-gradient(180deg, var(--shaker), rgba(186,140,255,0.28)); border-color: rgba(186,140,255,0.60); }
    .cell.on.ch{     background: linear-gradient(180deg, var(--ch), rgba(124,255,178,0.30)); border-color: rgba(124,255,178,0.65); }
    .cell.on.oh{     background: linear-gradient(180deg, var(--oh), rgba(255,210,120,0.24)); border-color: rgba(255,210,120,0.60); }

    .cell.beatDivider{ box-shadow: inset -2px 0 0 var(--beatDivider); }
    .cell.playhead{ outline: 2px solid var(--playheadOutline); outline-offset: 1px; }
    .cell.drag-hover{
      outline: 2px solid var(--dragOutline);
      outline-offset: -2px;
      box-shadow: inset 0 0 0 999px var(--dragFill);
    }

    /* Piano roll */
    .rollHeaderRight{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tab{
      padding: 7px 14px;
      border-radius: 999px;
      font-size:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: background .15s ease, border-color .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .tab.active{ color: var(--ink); }
    .tab.active[data-roll="piano"]{
      background: rgba(124,255,178,.16);
      border-color: rgba(124,255,178,.45);
      box-shadow: 0 0 0 2px rgba(124,255,178,.12) inset;
    }
    .tab.active[data-roll="synth"]{
      background: rgba(255,139,90,.16);
      border-color: rgba(255,139,90,.45);
      box-shadow: 0 0 0 2px rgba(255,139,90,.12) inset;
    }
    .tab.active[data-roll="bass"]{
      background: rgba(88,166,255,.16);
      border-color: rgba(88,166,255,.45);
      box-shadow: 0 0 0 2px rgba(88,166,255,.12) inset;
    }

    .trKnobs{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .trGroup{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.20);
    }
    .trLabel{
      font-size:12px;
      color: var(--muted);
      letter-spacing:.04em;
      user-select:none;
      white-space:nowrap;
    }
    .trKnob{ width:30px; height:30px; }
    .trVal{ width: 42px; }

    .rollWrap{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      overflow:hidden;
      touch-action: none;
    }
    canvas{display:block; width:100%; height:auto; touch-action:none}

    #midiFile{display:none}
    #projectFile{display:none}
  </style>
</head>

<body>
  <h1>RetroLoop Studio</h1>
  <p class="sub">
    4/4 • Drum sequencer + piano roll • Loop size:
    <span class="kbd" id="resText">1/64</span> • Keys: C3 → C5
  </p>

  <div class="wrap">
    <div class="card">
      <div class="hd">
        <div class="title">Transport</div>
        <div class="btnRow">
          <button id="playBtn">Play</button>
          <button id="pauseBtn" disabled>Pause</button>
          <button id="stopBtn" disabled>Stop</button>
        </div>
      </div>

      <div class="bd">
        <div class="btnRow" style="margin-bottom:10px;">
          <div class="pill">
            <span style="min-width:38px;">BPM</span>
            <input id="bpm" type="range" min="70" max="180" value="115"/>
            <span id="bpmLabel" class="kbd">115</span>
          </div>

          <div class="pill">
            <span>Loop</span>
            <input id="resolution" type="range" min="0" max="2" step="1" value="2"/>
            <span id="resolutionLabel" class="kbd">1/64</span>
          </div>
        </div>

        <!-- Volume + Mute/Solo -->
        <div class="btnRow" style="margin-bottom:10px;">
          <div class="pill" data-bus="piano">
            <span>Piano</span>
            <input id="pianoVol" type="range" min="0" max="1" step="0.01" value="0.35"/>
            <div class="msBtns">
              <button class="msBtn mute" id="pianoMute" type="button">M</button>
              <button class="msBtn solo" id="pianoSolo" type="button">S</button>
            </div>
          </div>

          <div class="pill" data-bus="synth">
            <span>Synth</span>
            <input id="synthVol" type="range" min="0" max="1" step="0.01" value="0.32"/>
            <div class="msBtns">
              <button class="msBtn mute" id="synthMute" type="button">M</button>
              <button class="msBtn solo" id="synthSolo" type="button">S</button>
            </div>
          </div>

          <div class="pill" data-bus="bass">
            <span>Bass</span>
            <input id="bassVol" type="range" min="0" max="1" step="0.01" value="0.40"/>
            <div class="msBtns">
              <button class="msBtn mute" id="bassMute" type="button">M</button>
              <button class="msBtn solo" id="bassSolo" type="button">S</button>
            </div>
          </div>

          <div class="pill" data-bus="drum">
            <span>Drum Bus</span>
            <input id="drumVol" type="range" min="0" max="1" step="0.01" value="0.85"/>
            <div class="msBtns">
              <button class="msBtn mute" id="drumMute" type="button">M</button>
              <button class="msBtn solo" id="drumSolo" type="button">S</button>
            </div>
          </div>
        </div>

        <!-- ✅ Compact Mixer Strip -->
        <div class="mixer">
          <div class="mixerTop">
            <div class="mixerTitle">Mixer</div>
            <div class="btnRow" style="gap:8px;">
              <div class="pill" style="padding:6px 10px;">
                <span>Reverb</span>
                <span class="kbd" id="rvLabel">Return</span>
              </div>
            </div>
          </div>

          <div class="mixerGrid">
            <!-- Piano Strip -->
            <div class="strip">
              <div class="stripHd">
                <div class="stripName">Piano</div>
              </div>
              <div class="stripRow">
                <div class="stripKnobs">
                  <div class="kCol">
                    <div class="knob" id="pianoPanKnob" style="--knobFill:var(--knobFillPiano);--knobGlow:var(--knobGlowPiano);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Pan</div>
                    <div class="kMiniVal" id="pianoPanVal">0</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="pianoLpfKnob" style="--knobFill:var(--knobFillPiano);--knobGlow:var(--knobGlowPiano);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">LPF</div>
                    <div class="kMiniVal" id="pianoLpfVal">100</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="pianoSendKnob" style="--knobFill:var(--knobFillPiano);--knobGlow:var(--knobGlowPiano);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Verb</div>
                    <div class="kMiniVal" id="pianoSendVal">10</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Synth Strip -->
            <div class="strip">
              <div class="stripHd">
                <div class="stripName">Synth</div>
              </div>
              <div class="stripRow">
                <div class="stripKnobs">
                  <div class="kCol">
                    <div class="knob" id="synthPanKnob" style="--knobFill:var(--knobFillSynth);--knobGlow:var(--knobGlowSynth);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Pan</div>
                    <div class="kMiniVal" id="synthPanVal">0</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="synthLpfKnob" style="--knobFill:var(--knobFillSynth);--knobGlow:var(--knobGlowSynth);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">LPF</div>
                    <div class="kMiniVal" id="synthLpfVal">100</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="synthSendKnob" style="--knobFill:var(--knobFillSynth);--knobGlow:var(--knobGlowSynth);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Verb</div>
                    <div class="kMiniVal" id="synthSendVal">14</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Bass Strip -->
            <div class="strip">
              <div class="stripHd">
                <div class="stripName">Bass</div>
              </div>
              <div class="stripRow">
                <div class="stripKnobs">
                  <div class="kCol">
                    <div class="knob" id="bassPanKnob" style="--knobFill:var(--knobFillBass);--knobGlow:var(--knobGlowBass);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Pan</div>
                    <div class="kMiniVal" id="bassPanVal">0</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="bassLpfKnob" style="--knobFill:var(--knobFillBass);--knobGlow:var(--knobGlowBass);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">LPF</div>
                    <div class="kMiniVal" id="bassLpfVal">100</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="bassSendKnob" style="--knobFill:var(--knobFillBass);--knobGlow:var(--knobGlowBass);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Verb</div>
                    <div class="kMiniVal" id="bassSendVal">6</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Drums Strip -->
            <div class="strip">
              <div class="stripHd">
                <div class="stripName">Drums</div>
              </div>
              <div class="stripRow">
                <div class="stripKnobs">
                  <div class="kCol">
                    <div class="knob" id="drumPanKnob" style="--knobFill:var(--knobFillDrum);--knobGlow:var(--knobGlowDrum);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Pan</div>
                    <div class="kMiniVal" id="drumPanVal">0</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="drumLpfKnob" style="--knobFill:var(--knobFillDrum);--knobGlow:var(--knobGlowDrum);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">LPF</div>
                    <div class="kMiniVal" id="drumLpfVal">100</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="drumSendKnob" style="--knobFill:var(--knobFillDrum);--knobGlow:var(--knobGlowDrum);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Verb</div>
                    <div class="kMiniVal" id="drumSendVal">18</div>
                  </div>
                </div>
              </div>
            </div>

            <!-- FX Return Strip (global) -->
            <div class="strip" style="grid-column: 1 / -1;">
              <div class="stripHd">
                <div class="stripName">FX Return</div>
              </div>
              <div class="stripRow" style="justify-content:flex-start;">
                <div class="stripKnobs">
                  <div class="kCol">
                    <div class="knob" id="rvReturnKnob" style="--knobFill:var(--knobFillFx);--knobGlow:var(--knobGlowFx);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Return</div>
                    <div class="kMiniVal" id="rvReturnVal">22</div>
                  </div>
                  <div class="kCol">
                    <div class="knob" id="rvSizeKnob" style="--knobFill:var(--knobFillFx);--knobGlow:var(--knobGlowFx);">
                      <div class="knobDot"></div>
                    </div>
                    <div class="kLbl">Size</div>
                    <div class="kMiniVal" id="rvSizeVal">45</div>
                  </div>
                </div>
                <div class="hint" style="margin:0 0 0 10px; max-width:520px;">
                  Pan = -100..100 • LPF = brightness • Verb = send level • Size regenerates reverb IR (no assets).
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Actions -->
        <div class="btnRow" style="margin-top:10px;">
          <button id="loadDemo">Reload Demo</button>
          <button id="clearProject">Clear Project</button>

          <button id="saveProjectBtn">Save Project</button>
          <button id="loadProjectBtn">Load Project</button>
          <input id="projectFile" type="file" accept=".json,application/json"/>

          <button id="importMidiBtn">Import MIDI</button>
          <input id="midiFile" type="file" accept=".mid,.midi" />
        </div>

        <p class="hint">
          <span class="kbd">Space</span> toggles Play/Pause (desktop).<br/>
          Auto demo loads from <span class="kbd">MIDI/</span> on GitHub Pages (relative paths).<br/>
          Mapping: <span class="kbd">pluck → Bass</span>, <span class="kbd">chords → Piano</span>, <span class="kbd">arp → Synth</span>.
        </p>
      </div>
    </div>

    <div class="card">
      <div class="hd">
        <div class="title">Drum Sequencer</div>
        <div class="pill">
          <span>Loop</span>
          <span class="kbd" id="groupText">1/64</span>
        </div>
      </div>
      <div class="bd">
        <div class="drumGrid" id="drumGrid"></div>
      </div>
    </div>

    <div class="card" style="grid-column: 1 / -1;">
      <div class="hd">
        <div class="title">Piano Roll</div>
        <div class="rollHeaderRight">
          <div class="tabs">
            <div class="tab active" data-roll="piano">Piano</div>
            <div class="tab" data-roll="synth">Synth</div>
            <div class="tab" data-roll="bass">Bass</div>
          </div>

          <div class="trKnobs" aria-label="Transpose knobs">
            <div class="trGroup" data-inst="piano">
              <div class="trLabel">P Tr</div>
              <div class="knob trKnob" id="pianoTrKnob" style="--knobFill:var(--knobFillPiano);--knobGlow:var(--knobGlowPiano);">
                <div class="knobDot"></div>
              </div>
              <div class="knobVal trVal" id="pianoTrVal">0</div>
            </div>

            <div class="trGroup" data-inst="synth">
              <div class="trLabel">S Tr</div>
              <div class="knob trKnob" id="synthTrKnob" style="--knobFill:var(--knobFillSynth);--knobGlow:var(--knobGlowSynth);">
                <div class="knobDot"></div>
              </div>
              <div class="knobVal trVal" id="synthTrVal">0</div>
            </div>

            <div class="trGroup" data-inst="bass">
              <div class="trLabel">B Tr</div>
              <div class="knob trKnob" id="bassTrKnob" style="--knobFill:var(--knobFillBass);--knobGlow:var(--knobGlowBass);">
                <div class="knobDot"></div>
              </div>
              <div class="knobVal trVal" id="bassTrVal">0</div>
            </div>
          </div>
        </div>
      </div>

      <div class="bd">
        <div class="rollWrap">
          <canvas id="roll" width="1280" height="560"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>

<script>
(() => {
  const RES_OPTIONS = [
    { label: "1/16", steps: 16 },
    { label: "1/32", steps: 32 },
    { label: "1/64", steps: 64 },
  ];
  const MASTER_STEPS = 64;

  const ROLL_BASE_MIDI = 48; // C3
  const ROLL_TOP_MIDI  = 72; // C5
  const ROLL_PITCHES   = (ROLL_TOP_MIDI - ROLL_BASE_MIDI) + 1;

  const drumNames = ["Kick", "Clap", "Shaker", "Snare", "CH", "OH"];
  const drumKeys  = ["kick", "clap", "shaker", "snare", "ch", "oh"];

  const MIDI_PATHS = {
    bass:  "MIDI/NW_EID_115_synth_pluck_nightlife_Abmaj.mid",
    piano: "MIDI/NW_EID_115_synth_chords_nightlife_Abmaj.mid",
    synth: "MIDI/NW_EID_115_synth_arp_nightlife_Abmaj.mid",
  };

  const transpose = { piano: 0, synth: 0, bass: 0 };

  function makeEmptyProject(){
    return {
      drums: {
        kick:   new Array(MASTER_STEPS).fill(false),
        clap:   new Array(MASTER_STEPS).fill(false),
        shaker: new Array(MASTER_STEPS).fill(false),
        snare:  new Array(MASTER_STEPS).fill(false),
        ch:     new Array(MASTER_STEPS).fill(false),
        oh:     new Array(MASTER_STEPS).fill(false),
      },
      piano: Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0)),
      synth: Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0)),
      bass:  Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0)),
      drumVols: { kick:100, clap:85, shaker:65, snare:92, ch:62, oh:70 },
    };
  }

  const project = makeEmptyProject();

  let LOOP_STEPS = 64;

  // playback
  let ctx = null;
  let master = null;

  // Bus gain nodes (these are what mute/solo controls)
  let pianoBus = null, synthBus = null, bassBus = null, drumBus = null;

  // Mixer inserts
  const mix = {
    piano: { lpf:null, pan:null, send:null, panVal:0, lpfVal:100, sendVal:10 },
    synth: { lpf:null, pan:null, send:null, panVal:0, lpfVal:100, sendVal:14 },
    bass:  { lpf:null, pan:null, send:null, panVal:0, lpfVal:100, sendVal:6 },
    drum:  { lpf:null, pan:null, send:null, panVal:0, lpfVal:100, sendVal:18 },
  };

  // Reverb (global send/return)
  let rvConvolver = null;
  let rvReturnGain = null;
  let rvInput = null;   // sum of sends
  let rvSize = 45;      // 0..100
  let rvReturn = 22;    // 0..100

  // Per-drum row gains
  const drumGains = { kick:null, clap:null, shaker:null, snare:null, ch:null, oh:null };

  let isPlaying = false;
  let isPaused = false;
  let currentStep = 0;
  let nextNoteTime = 0;
  let timerId = null;

  let bpm = 115;
  const lookAhead = 0.025;
  const scheduleAhead = 0.12;

  // UI refs
  const playBtn = document.getElementById("playBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const stopBtn = document.getElementById("stopBtn");

  const bpmEl = document.getElementById("bpm");
  const bpmLabel = document.getElementById("bpmLabel");

  const resEl = document.getElementById("resolution");
  const resLabel = document.getElementById("resolutionLabel");
  const resText = document.getElementById("resText");
  const groupText = document.getElementById("groupText");

  const pianoVol = document.getElementById("pianoVol");
  const synthVol = document.getElementById("synthVol");
  const bassVol  = document.getElementById("bassVol");
  const drumVol  = document.getElementById("drumVol");

  const busBtns = {
    piano: { mute: document.getElementById("pianoMute"), solo: document.getElementById("pianoSolo") },
    synth: { mute: document.getElementById("synthMute"), solo: document.getElementById("synthSolo") },
    bass:  { mute: document.getElementById("bassMute"),  solo: document.getElementById("bassSolo") },
    drum:  { mute: document.getElementById("drumMute"),  solo: document.getElementById("drumSolo") },
  };

  // Mixer knob refs
  const knobEls = {
    piano: {
      panK: document.getElementById("pianoPanKnob"), panV: document.getElementById("pianoPanVal"),
      lpfK: document.getElementById("pianoLpfKnob"), lpfV: document.getElementById("pianoLpfVal"),
      sndK: document.getElementById("pianoSendKnob"), sndV: document.getElementById("pianoSendVal"),
    },
    synth: {
      panK: document.getElementById("synthPanKnob"), panV: document.getElementById("synthPanVal"),
      lpfK: document.getElementById("synthLpfKnob"), lpfV: document.getElementById("synthLpfVal"),
      sndK: document.getElementById("synthSendKnob"), sndV: document.getElementById("synthSendVal"),
    },
    bass: {
      panK: document.getElementById("bassPanKnob"), panV: document.getElementById("bassPanVal"),
      lpfK: document.getElementById("bassLpfKnob"), lpfV: document.getElementById("bassLpfVal"),
      sndK: document.getElementById("bassSendKnob"), sndV: document.getElementById("bassSendVal"),
    },
    drum: {
      panK: document.getElementById("drumPanKnob"), panV: document.getElementById("drumPanVal"),
      lpfK: document.getElementById("drumLpfKnob"), lpfV: document.getElementById("drumLpfVal"),
      sndK: document.getElementById("drumSendKnob"), sndV: document.getElementById("drumSendVal"),
    },
    rv: {
      retK: document.getElementById("rvReturnKnob"), retV: document.getElementById("rvReturnVal"),
      sizK: document.getElementById("rvSizeKnob"),   sizV: document.getElementById("rvSizeVal"),
    }
  };

  const pianoTrKnob = document.getElementById("pianoTrKnob");
  const synthTrKnob = document.getElementById("synthTrKnob");
  const bassTrKnob  = document.getElementById("bassTrKnob");
  const pianoTrVal = document.getElementById("pianoTrVal");
  const synthTrVal = document.getElementById("synthTrVal");
  const bassTrVal  = document.getElementById("bassTrVal");

  const loadDemoBtn = document.getElementById("loadDemo");
  const clearProjectBtn = document.getElementById("clearProject");
  const importMidiBtn = document.getElementById("importMidiBtn");
  const midiFileInput = document.getElementById("midiFile");

  // ✅ Save / Load Project
  const saveProjectBtn = document.getElementById("saveProjectBtn");
  const loadProjectBtn = document.getElementById("loadProjectBtn");
  const projectFileInput = document.getElementById("projectFile");

  const drumGridEl = document.getElementById("drumGrid");
  const rollCanvas = document.getElementById("roll");
  const g = rollCanvas.getContext("2d");

  const AudioContext = window.AudioContext || window.webkitAudioContext;

  // Tabs
  let activeRoll = "piano";
  document.querySelectorAll(".tab").forEach(t => {
    t.addEventListener("click", () => {
      document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
      t.classList.add("active");
      activeRoll = t.dataset.roll;
      drawRoll(isPlaying ? currentStep : -1);
    });
  });

  bpmEl.addEventListener("input", () => {
    bpm = Number(bpmEl.value);
    bpmLabel.textContent = String(bpm);
  });

  // Spacebar
  function isTypingTarget(el){
    if (!el) return false;
    const tag = (el.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || el.isContentEditable;
  }
  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space") return;
    if (isTypingTarget(document.activeElement)) return;
    e.preventDefault();
    togglePlayPause();
  }, {passive:false});

  // Mute/Solo states
  const busState = {
    piano: { mute:false, solo:false },
    synth: { mute:false, solo:false },
    bass:  { mute:false, solo:false },
    drum:  { mute:false, solo:false },
  };

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function cssVar(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  // Knob visuals
  function knobStyleForPercent(pct){
    const deg = pct * 270;
    const rot = (-135 + pct * 270);
    return { fillDeg: `${deg}deg`, rotDeg: `${rot}deg` };
  }
  function setKnobVisual(knobEl, pct){
    pct = clamp(pct, 0, 1);
    const st = knobStyleForPercent(pct);
    knobEl.style.setProperty("--knobDeg", st.fillDeg);
    knobEl.style.setProperty("--knobRot", st.rotDeg);
  }

  // Generic knob binder for numeric values
  function bindKnob({knobEl, valEl, min, max, step, initial, onChange, format, dblClickReset}){
    let value = initial;
    const valueToPct = (v) => (v - min) / (max - min);

    function setValue(v){
      v = clamp(v, min, max);
      if (step) v = Math.round(v / step) * step;
      value = v;
      setKnobVisual(knobEl, valueToPct(value));
      if (valEl) valEl.textContent = format ? format(value) : String(value);
      onChange && onChange(value);
    }

    setValue(value);

    let active=false, pid=null, startY=0, startVal=0;
    const onDown = async (e) => {
      e.preventDefault();
      await ensureRunning();
      active=true; pid=e.pointerId; startY=e.clientY; startVal=value;
      knobEl.setPointerCapture(pid);
    };
    const onMove = (e) => {
      if (!active || e.pointerId !== pid) return;
      e.preventDefault();
      const dy = startY - e.clientY;          // up increases
      const delta = (dy / 120) * (max - min); // 120px = full range
      setValue(startVal + delta);
    };
    const onUp = (e) => {
      if (!active || e.pointerId !== pid) return;
      active=false; pid=null;
    };

    knobEl.addEventListener("pointerdown", onDown, {passive:false});
    knobEl.addEventListener("pointermove", onMove, {passive:false});
    knobEl.addEventListener("pointerup", onUp);
    knobEl.addEventListener("pointercancel", onUp);
    knobEl.addEventListener("lostpointercapture", () => { active=false; pid=null; });

    if (dblClickReset !== undefined){
      knobEl.addEventListener("dblclick", (e) => { e.preventDefault(); setValue(dblClickReset); });
    }

    return { get:()=>value, set:setValue, toPct:valueToPct };
  }

  // Transpose knobs
  function semitoneToPct(v){ return (clamp(v, -24, 24) + 24) / 48; }
  function setTranspose(inst, val){
    const v = clamp(Math.round(Number(val)), -24, 24);
    transpose[inst] = v;
    if (inst === "piano"){
      pianoTrVal.textContent = String(v);
      setKnobVisual(pianoTrKnob, semitoneToPct(v));
    } else if (inst === "synth"){
      synthTrVal.textContent = String(v);
      setKnobVisual(synthTrKnob, semitoneToPct(v));
    } else {
      bassTrVal.textContent = String(v);
      setKnobVisual(bassTrKnob, semitoneToPct(v));
    }
  }
  function attachTransposeKnob(knobEl, inst){
    let active=false, pid=null, startY=0, startVal=0;
    const onDown = async (e) => {
      e.preventDefault();
      await ensureRunning();
      active=true; pid=e.pointerId; startY=e.clientY; startVal=transpose[inst]||0;
      knobEl.setPointerCapture(pid);
    };
    const onMove = (e) => {
      if (!active || e.pointerId !== pid) return;
      e.preventDefault();
      const dy = startY - e.clientY;
      setTranspose(inst, startVal + dy/12);
    };
    const onUp = (e) => {
      if (!active || e.pointerId !== pid) return;
      active=false; pid=null;
    };
    knobEl.addEventListener("pointerdown", onDown, {passive:false});
    knobEl.addEventListener("pointermove", onMove, {passive:false});
    knobEl.addEventListener("pointerup", onUp);
    knobEl.addEventListener("pointercancel", onUp);
    knobEl.addEventListener("lostpointercapture", ()=>{active=false;pid=null;});
    knobEl.addEventListener("dblclick", (e)=>{e.preventDefault(); setTranspose(inst,0);});
  }

  // Routing + mute/solo
  function applyBusRouting(){
    if (!pianoBus) return;
    const anySolo = Object.values(busState).some(b => b.solo);

    function effGain(busName, sliderValue){
      const base = Number(sliderValue);
      const s = busState[busName];
      if (anySolo) return (s.solo ? (s.mute ? 0 : base) : 0);
      return (s.mute ? 0 : base);
    }
    pianoBus.gain.value = effGain("piano", pianoVol.value);
    synthBus.gain.value = effGain("synth", synthVol.value);
    bassBus.gain.value  = effGain("bass",  bassVol.value);
    drumBus.gain.value  = effGain("drum",  drumVol.value);
  }

  function bindMuteSolo(busName){
    const { mute, solo } = busBtns[busName];
    mute.addEventListener("click", async (e) => {
      e.preventDefault();
      await ensureRunning();
      busState[busName].mute = !busState[busName].mute;
      mute.classList.toggle("active", busState[busName].mute);
      applyBusRouting();
    });
    solo.addEventListener("click", async (e) => {
      e.preventDefault();
      await ensureRunning();
      busState[busName].solo = !busState[busName].solo;
      solo.classList.toggle("active", busState[busName].solo);
      applyBusRouting();
    });
  }

  // LPF mapping: 0..100 => 200..18000
  function lpfCutoffFromPct(pct01){
    const min = 200;
    const max = 18000;
    const ratio = max / min;
    return min * Math.pow(ratio, pct01);
  }

  function makeImpulseResponse(decaySeconds){
    const sr = ctx.sampleRate;
    const len = Math.max(1, Math.floor(sr * decaySeconds));
    const buffer = ctx.createBuffer(2, len, sr);

    for (let ch=0; ch<2; ch++){
      const data = buffer.getChannelData(ch);
      for (let i=0; i<len; i++){
        const t = i / len;
        const env = Math.pow(1 - t, 2.8);
        data[i] = (Math.random()*2 - 1) * env;
      }
    }
    return buffer;
  }

  function setReverbSize(size0to100){
    rvSize = clamp(Math.round(size0to100), 0, 100);
    if (!ctx || !rvConvolver) return;
    const decay = 0.6 + (rvSize/100) * 5.4;
    rvConvolver.buffer = makeImpulseResponse(decay);
  }

  function setReverbReturn(v0to100){
    rvReturn = clamp(Math.round(v0to100), 0, 100);
    if (!rvReturnGain) return;
    rvReturnGain.gain.value = (rvReturn/100) * 0.55;
  }

  function applyMixerNodes(inst){
    if (!ctx) return;
    const m = mix[inst];
    if (!m || !m.pan || !m.lpf || !m.send) return;

    m.pan.pan.value = clamp(m.panVal/100, -1, 1);

    const pct = clamp(m.lpfVal/100, 0, 1);
    m.lpf.frequency.setValueAtTime(lpfCutoffFromPct(pct), ctx.currentTime);
    m.lpf.Q.value = 0.7;

    const s = clamp(m.sendVal/100, 0, 1);
    m.send.gain.value = s*s;
  }

  function ensureAudio(){
    if (ctx) return;

    ctx = new AudioContext();

    master = ctx.createGain();
    master.gain.value = 0.9;
    master.connect(ctx.destination);

    pianoBus = ctx.createGain();
    synthBus = ctx.createGain();
    bassBus  = ctx.createGain();
    drumBus  = ctx.createGain();

    rvInput = ctx.createGain();
    rvConvolver = ctx.createConvolver();
    rvReturnGain = ctx.createGain();

    rvInput.connect(rvConvolver);
    rvConvolver.connect(rvReturnGain);
    rvReturnGain.connect(master);

    rvConvolver.buffer = makeImpulseResponse(0.6 + (rvSize/100)*5.4);
    setReverbReturn(rvReturn);

    function wireBus(inst, busGain){
      const lpf = ctx.createBiquadFilter();
      lpf.type = "lowpass";

      const pan = ctx.createStereoPanner();
      const send = ctx.createGain();

      busGain.connect(lpf);
      lpf.connect(pan);
      pan.connect(master);

      busGain.connect(send);
      send.connect(rvInput);

      mix[inst].lpf = lpf;
      mix[inst].pan = pan;
      mix[inst].send = send;

      applyMixerNodes(inst);
    }

    wireBus("piano", pianoBus);
    wireBus("synth", synthBus);
    wireBus("bass",  bassBus);
    wireBus("drum",  drumBus);

    for (const k of drumKeys){
      drumGains[k] = ctx.createGain();
      drumGains[k].gain.value = 1;
      drumGains[k].connect(drumBus);
    }

    pianoVol.addEventListener("input", applyBusRouting);
    synthVol.addEventListener("input", applyBusRouting);
    bassVol.addEventListener("input", applyBusRouting);
    drumVol.addEventListener("input", applyBusRouting);

    bindMuteSolo("piano");
    bindMuteSolo("synth");
    bindMuteSolo("bass");
    bindMuteSolo("drum");

    applyBusRouting();
  }

  async function ensureRunning(){
    ensureAudio();
    if (ctx.state !== "running") await ctx.resume();
  }

  // --- Mixer knobs ---
  function bindTrackMixer(inst){
    const els = knobEls[inst];
    const m = mix[inst];

    bindKnob({
      knobEl: els.panK,
      valEl: els.panV,
      min: -100, max: 100, step: 1,
      initial: m.panVal,
      dblClickReset: 0,
      format: (v)=> String(v),
      onChange: (v)=>{ m.panVal = v; applyMixerNodes(inst); }
    });

    bindKnob({
      knobEl: els.lpfK,
      valEl: els.lpfV,
      min: 0, max: 100, step: 1,
      initial: m.lpfVal,
      dblClickReset: 100,
      format: (v)=> String(v),
      onChange: (v)=>{ m.lpfVal = v; applyMixerNodes(inst); }
    });

    bindKnob({
      knobEl: els.sndK,
      valEl: els.sndV,
      min: 0, max: 100, step: 1,
      initial: m.sendVal,
      dblClickReset: 0,
      format: (v)=> String(v),
      onChange: (v)=>{ m.sendVal = v; applyMixerNodes(inst); }
    });
  }

  function bindReverbKnobs(){
    bindKnob({
      knobEl: knobEls.rv.retK,
      valEl: knobEls.rv.retV,
      min: 0, max: 100, step: 1,
      initial: rvReturn,
      dblClickReset: 20,
      format: (v)=> String(v),
      onChange: (v)=>{ setReverbReturn(v); }
    });

    bindKnob({
      knobEl: knobEls.rv.sizK,
      valEl: knobEls.rv.sizV,
      min: 0, max: 100, step: 1,
      initial: rvSize,
      dblClickReset: 45,
      format: (v)=> String(v),
      onChange: (v)=>{ setReverbSize(v); }
    });
  }

  // --- Instruments ---
  function midiToHz(midi){
    return 440 * Math.pow(2, (midi - 69) / 12);
  }

  function playVoice(freq, time, dur, bus, wave, peak, cutoff){
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();

    osc.type = wave;
    osc.frequency.setValueAtTime(freq, time);

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(peak, time + 0.01);

    const rel = Math.max(0.02, Math.min(0.18, dur * 0.25));
    gain.gain.exponentialRampToValueAtTime(0.0001, time + dur + rel);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(cutoff, time);

    osc.connect(lp).connect(gain).connect(bus);
    osc.start(time);
    osc.stop(time + dur + rel + 0.03);
  }

  async function previewMidi(midi){
    await ensureRunning();
    const now = ctx.currentTime + 0.001;

    if (activeRoll === "bass"){
      const hz = midiToHz(midi + transpose.bass);
      playVoice(hz, now, 0.12, bassBus, "triangle", 0.22, 1500);
      return;
    }
    if (activeRoll === "synth"){
      const hz = midiToHz(midi + transpose.synth);
      playVoice(hz, now, 0.12, synthBus, "sawtooth", 0.18, 5200);
      return;
    }
    const hz = midiToHz(midi + transpose.piano);
    playVoice(hz, now, 0.12, pianoBus, "square", 0.18, 4200);
  }

  // --- Drum synthesis ---
  let noiseBuf = null;
  function getNoiseBuffer(){
    if (noiseBuf) return noiseBuf;
    const len = ctx.sampleRate * 0.5;
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<len;i++) d[i] = Math.random()*2 - 1;
    noiseBuf = b;
    return b;
  }

  function playKick(time){
    const out = drumGains.kick;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(160, time);
    osc.frequency.exponentialRampToValueAtTime(50, time + 0.09);
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(1.0, time + 0.004);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.14);
    osc.connect(gain).connect(out);
    osc.start(time); osc.stop(time + 0.16);
  }

  function playSnare(time){
    const out = drumGains.snare;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1800, time);
    bp.Q.setValueAtTime(0.8, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.9, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.10);
    src.connect(bp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.12);
  }

  function playClap(time){
    const out = drumGains.clap;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(2200, time);
    bp.Q.setValueAtTime(0.7, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.55, time + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.07);
    src.connect(bp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.09);
  }

  function playShaker(time){
    const out = drumGains.shaker;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(6500, time);
    bp.Q.setValueAtTime(1.2, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.22, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.06);
    src.connect(bp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.08);
  }

  function playCH(time){
    const out = drumGains.ch;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(7500, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.33, time + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.04);
    src.connect(hp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.06);
  }

  function playOH(time){
    const out = drumGains.oh;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(6800, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.28, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
    src.connect(hp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.22);
  }

  // --- Sequencer data helpers ---
  function rangesOverlap(aStart, aLen, bStart, bLen){
    const aEnd = aStart + aLen;
    const bEnd = bStart + bLen;
    return aStart < bEnd && bStart < aEnd;
  }
  function clearOverlaps(row, start, len){
    for (let s=0; s<MASTER_STEPS; s++){
      const l = row[s];
      if (l <= 0) continue;
      if (rangesOverlap(s, l, start, len)) row[s] = 0;
    }
  }

  function clearInstrumentGrid(grid){
    for (let p=0; p<ROLL_PITCHES; p++) grid[p].fill(0);
  }
  function getActiveGrid(){
    if (activeRoll === "bass") return project.bass;
    if (activeRoll === "synth") return project.synth;
    return project.piano;
  }
  function noteColor(){
    if (activeRoll === "bass") return cssVar("--bassNote");
    if (activeRoll === "synth") return cssVar("--synthNote");
    return cssVar("--pianoNote");
  }

  // Demo drums
  function setDemoDrumsFromAudioAnalysis(){
    for (const k of drumKeys) project.drums[k].fill(false);

    const KICK   = [11, 30, 32, 43, 56, 62];
    const SNARE  = [ 8, 24, 40, 56];
    const CLAP   = [ 8, 24, 40, 56];
    const SHAKER = [6,7,8,22,24,26,27,28,38,39,40,54,56,58,59,60];
    const CH     = [6,8,22,28,32,38,54,60];
    const OH     = [3,11,17,20,24,26,35,43,52,56,58];

    KICK.forEach(s => project.drums.kick[s] = true);
    SNARE.forEach(s => project.drums.snare[s] = true);
    CLAP.forEach(s => project.drums.clap[s] = true);
    SHAKER.forEach(s => project.drums.shaker[s] = true);
    CH.forEach(s => project.drums.ch[s] = true);
    OH.forEach(s => project.drums.oh[s] = true);

    project.drumVols.kick = 100;
    project.drumVols.snare = 92;
    project.drumVols.clap = 80;
    project.drumVols.shaker = 58;
    project.drumVols.ch = 62;
    project.drumVols.oh = 70;
  }

  async function fetchMidiArrayBuffer(relPath){
    const url = new URL(relPath, window.location.href).toString();
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch MIDI ${url} (${res.status})`);
    return await res.arrayBuffer();
  }

  async function importMidiIntoGrid(arrayBuffer, targetGrid){
    const midi = new Midi(arrayBuffer);

    const quarter = 60 / bpm;
    const toStep = (t) => clamp(Math.round((t / quarter) * 4), 0, MASTER_STEPS-1);
    const toLen  = (d) => clamp(Math.max(1, Math.round((d / quarter) * 4)), 1, MASTER_STEPS);

    clearInstrumentGrid(targetGrid);

    midi.tracks.forEach(tr => {
      if (!tr.notes) return;
      tr.notes.forEach(n => {
        const s = toStep(n.time);
        const len = Math.min(toLen(n.duration), MASTER_STEPS - s);
        const p = n.midi - ROLL_BASE_MIDI;
        if (p < 0 || p >= ROLL_PITCHES) return;

        // clear overlaps + place note
        const row = targetGrid[p];
        for (let i=0; i<MASTER_STEPS; i++){
          const l = row[i];
          if (l <= 0) continue;
          if (rangesOverlap(i, l, s, len)) row[i] = 0;
        }
        row[s] = len;
      });
    });
  }

  async function loadDemoFromMidiFolder(){
    const [pluckBuf, chordsBuf, arpBuf] = await Promise.all([
      fetchMidiArrayBuffer(MIDI_PATHS.bass),
      fetchMidiArrayBuffer(MIDI_PATHS.piano),
      fetchMidiArrayBuffer(MIDI_PATHS.synth),
    ]);

    stopTransportOnly();
    await importMidiIntoGrid(pluckBuf,  project.bass);
    await importMidiIntoGrid(chordsBuf, project.piano);
    await importMidiIntoGrid(arpBuf,    project.synth);

    setDemoDrumsFromAudioAnalysis();
    buildDrumGrid();
    drawRoll(-1);
  }

  function clearProject(){
    stopTransportOnly();
    const fresh = makeEmptyProject();
    for (const k of drumKeys) project.drums[k] = fresh.drums[k].slice();
    for (let p=0; p<ROLL_PITCHES; p++){
      project.piano[p] = fresh.piano[p].slice();
      project.synth[p] = fresh.synth[p].slice();
      project.bass[p]  = fresh.bass[p].slice();
    }
    project.drumVols = { ...fresh.drumVols };
    buildDrumGrid();
    drawRoll(-1);
  }

  // --- Drums UI ---
  function knobStyleForValue(v){
    const pct = clamp(v, 0, 100) / 100;
    return knobStyleForPercent(pct);
  }
  function setRowKnobValue(knobEl, valEl, v, track){
    const vv = clamp(Math.round(v), 0, 100);
    valEl.textContent = String(vv);
    const st = knobStyleForValue(vv);
    knobEl.style.setProperty("--knobDeg", st.fillDeg);
    knobEl.style.setProperty("--knobRot", st.rotDeg);
    project.drumVols[track] = vv;

    if (track && drumGains[track]){
      const x = vv / 100;
      drumGains[track].gain.value = x * x;
    }
  }
  function attachRowKnob(knobEl, valEl, track){
    let active = false, pid = null, startVal = 100, startY = 0;

    const onDown = async (e) => {
      e.preventDefault();
      await ensureRunning();
      active = true;
      pid = e.pointerId;
      startY = e.clientY;
      startVal = Number(valEl.textContent) || 100;
      knobEl.setPointerCapture(pid);
    };
    const onMove = (e) => {
      if (!active || e.pointerId !== pid) return;
      e.preventDefault();
      const dy = startY - e.clientY;
      setRowKnobValue(knobEl, valEl, startVal + dy * 0.35, track);
    };
    const onUp = (e) => {
      if (!active || e.pointerId !== pid) return;
      active = false; pid = null;
    };

    knobEl.addEventListener("pointerdown", onDown, {passive:false});
    knobEl.addEventListener("pointermove", onMove, {passive:false});
    knobEl.addEventListener("pointerup", onUp);
    knobEl.addEventListener("pointercancel", onUp);
    knobEl.addEventListener("lostpointercapture", () => { active=false; pid=null; });
  }

  function buildDrumGrid(){
    drumGridEl.innerHTML = "";

    const namesCol = document.createElement("div");
    namesCol.className = "trackNames";

    const stepsCol = document.createElement("div");
    stepsCol.className = "steps";

    drumKeys.forEach((key, idx) => {
      const nameRow = document.createElement("div");
      nameRow.className = "trackName";

      const label = document.createElement("div");
      label.className = "trackLabel";
      label.textContent = drumNames[idx];

      const knobWrap = document.createElement("div");
      knobWrap.className = "knobWrap";

      const knob = document.createElement("div");
      knob.className = "knob";
      const dot = document.createElement("div");
      dot.className = "knobDot";
      knob.appendChild(dot);

      const val = document.createElement("div");
      val.className = "knobVal";
      val.textContent = String(project.drumVols[key] ?? 100);

      const init = knobStyleForValue(Number(val.textContent));
      knob.style.setProperty("--knobDeg", init.fillDeg);
      knob.style.setProperty("--knobRot", init.rotDeg);

      knobWrap.appendChild(knob);
      knobWrap.appendChild(val);

      nameRow.appendChild(label);
      nameRow.appendChild(knobWrap);
      namesCol.appendChild(nameRow);

      attachRowKnob(knob, val, key);

      const row = document.createElement("div");
      row.className = "rowSteps";
      row.style.gridTemplateColumns = `repeat(${LOOP_STEPS}, minmax(0, 1fr))`;

      for (let s=0; s<LOOP_STEPS; s++){
        const cell = document.createElement("div");
        cell.className = "cell";
        const group = Math.floor(s / 4) % 2;
        cell.classList.add(group === 0 ? "groupA" : "groupB");
        cell.classList.add(key);
        if ((s+1) % 4 === 0 && s !== LOOP_STEPS-1) cell.classList.add("beatDivider");
        cell.dataset.track = key;
        cell.dataset.step = String(s);
        cell.ondragstart = () => false;
        row.appendChild(cell);
      }
      stepsCol.appendChild(row);
    });

    drumGridEl.appendChild(namesCol);
    drumGridEl.appendChild(stepsCol);

    enableDrumPainting(stepsCol);
    refreshDrumUI();
  }

  function refreshDrumUI(){
    const rows = drumGridEl.querySelectorAll(".rowSteps");
    drumKeys.forEach((k, r) => {
      const row = rows[r];
      if (!row) return;
      for (let s=0; s<LOOP_STEPS; s++){
        row.children[s].classList.toggle("on", project.drums[k][s]);
      }
    });
  }

  function updatePlayheadUI(step){
    drumGridEl.querySelectorAll(".cell").forEach(c => c.classList.remove("playhead"));
    if (step < 0) return;
    const rows = drumGridEl.querySelectorAll(".rowSteps");
    drumKeys.forEach((_, rIdx) => {
      const row = rows[rIdx];
      const cell = row && row.children[step];
      if (cell) cell.classList.add("playhead");
    });
  }

  // row-locked drag paint
  let drumPaint = { active:false, pointerId:null, value:true, visited:new Set(), track:null };

  function cellFromPoint(clientX, clientY){
    const el = document.elementFromPoint(clientX, clientY);
    if (!el) return null;
    return el.classList && el.classList.contains("cell") ? el : null;
  }
  function clearDragHover(){
    drumGridEl.querySelectorAll(".cell.drag-hover").forEach(c => c.classList.remove("drag-hover"));
  }
  function applyDrumCell(cell, value){
    const key = cell.dataset.track;
    if (drumPaint.track && key !== drumPaint.track) return;

    const step = Number(cell.dataset.step);
    const id = `${key}:${step}`;
    if (drumPaint.visited.has(id)) return;
    drumPaint.visited.add(id);

    project.drums[key][step] = value;
    cell.classList.toggle("on", value);
    cell.classList.add("drag-hover");
  }

  function enableDrumPainting(container){
    container.addEventListener("pointerdown", (e) => {
      const cell = e.target.closest(".cell");
      if (!cell) return;
      e.preventDefault();

      drumPaint.active = true;
      drumPaint.pointerId = e.pointerId;
      drumPaint.visited.clear();
      clearDragHover();

      const key = cell.dataset.track;
      const step = Number(cell.dataset.step);

      drumPaint.track = key;
      drumPaint.value = !project.drums[key][step];

      container.setPointerCapture(e.pointerId);
      applyDrumCell(cell, drumPaint.value);
    }, {passive:false});

    container.addEventListener("pointermove", (e) => {
      if (!drumPaint.active) return;
      if (drumPaint.pointerId !== e.pointerId) return;
      e.preventDefault();
      const cell = cellFromPoint(e.clientX, e.clientY);
      if (!cell) return;
      applyDrumCell(cell, drumPaint.value);
    }, {passive:false});

    const end = (e) => {
      if (!drumPaint.active) return;
      if (drumPaint.pointerId !== e.pointerId) return;
      drumPaint.active = false;
      drumPaint.pointerId = null;
      drumPaint.track = null;
      drumPaint.visited.clear();
      setTimeout(clearDragHover, 40);
    };

    container.addEventListener("pointerup", end);
    container.addEventListener("pointercancel", end);
    container.addEventListener("lostpointercapture", () => {
      drumPaint.active = false;
      drumPaint.pointerId = null;
      drumPaint.track = null;
      drumPaint.visited.clear();
      setTimeout(clearDragHover, 40);
    });
  }

  // --- Piano roll drawing/editing ---
  const KEY_PAD = 128;
  function isBlackKey(midi){
    const pc = midi % 12;
    return pc === 1 || pc === 3 || pc === 6 || pc === 8 || pc === 10;
  }
  function midiNameFlat(m){
    const pc = m % 12;
    const oct = Math.floor(m/12) - 1;
    const names = { 0:"C", 1:"Db", 2:"D", 3:"Eb", 4:"E", 5:"F", 6:"Gb", 7:"G", 8:"Ab", 9:"A", 10:"Bb", 11:"B" };
    return `${names[pc]}${oct}`;
  }

  function drawRoll(playheadStep = -1){
    const W = rollCanvas.width;
    const H = rollCanvas.height;

    const grid = getActiveGrid();

    const leftPad = KEY_PAD;
    const cellW = (W - leftPad) / LOOP_STEPS;
    const cellH = H / ROLL_PITCHES;

    g.clearRect(0,0,W,H);
    g.fillStyle = cssVar("--rollBg");
    g.fillRect(0,0,W,H);

    for (let p=0; p<ROLL_PITCHES; p++){
      const midi = ROLL_BASE_MIDI + p;
      const y = H - (p+1)*cellH;
      g.fillStyle = isBlackKey(midi) ? cssVar("--rowBlack") : ((p % 2 === 0) ? cssVar("--rowWhiteA") : cssVar("--rowWhiteB"));
      g.fillRect(leftPad, y, W-leftPad, cellH);
    }

    for (let s=0; s<=LOOP_STEPS; s++){
      const x = leftPad + s*cellW;
      g.strokeStyle = (s % 4 === 0) ? cssVar("--gridBeat") : cssVar("--gridLine");
      g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke();
    }
    for (let p=0; p<=ROLL_PITCHES; p++){
      const y = p*cellH;
      g.strokeStyle = cssVar("--gridLine");
      g.beginPath(); g.moveTo(leftPad,y); g.lineTo(W,y); g.stroke();
    }

    g.fillStyle = cssVar("--rollStrip");
    g.fillRect(0,0,leftPad,H);

    for (let p=0; p<ROLL_PITCHES; p++){
      const midi = ROLL_BASE_MIDI + p;
      const y = H - (p+1)*cellH;
      const black = isBlackKey(midi);

      if (!black){
        const grad = g.createLinearGradient(0,y,0,y+cellH);
        grad.addColorStop(0, cssVar("--whiteKeyA"));
        grad.addColorStop(1, cssVar("--whiteKeyB"));
        g.fillStyle = grad;
        g.fillRect(6, y+1, leftPad-12, cellH-2);
        g.strokeStyle = cssVar("--keyBorder");
        g.strokeRect(6.5, y+1.5, leftPad-13, cellH-3);

        g.fillStyle = "rgba(0,0,0,0.80)";
        g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
        g.fillText(midiNameFlat(midi), 12, y + cellH*0.68);
      } else {
        const grad = g.createLinearGradient(0,y,0,y+cellH);
        grad.addColorStop(0, cssVar("--blackKeyB"));
        grad.addColorStop(1, cssVar("--blackKeyA"));

        const insetLeft = 22;
        const insetRight = 20;
        g.fillStyle = grad;
        g.fillRect(insetLeft, y+2, leftPad - insetLeft - insetRight, cellH-4);
        g.strokeStyle = "rgba(255,255,255,.10)";
        g.strokeRect(insetLeft+0.5, y+2.5, leftPad - insetLeft - insetRight - 1, cellH-5);

        g.fillStyle = "rgba(255,255,255,0.80)";
        g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
        g.fillText(midiNameFlat(midi), insetLeft+6, y + cellH*0.68);
      }
    }

    for (let p=0; p<ROLL_PITCHES; p++){
      for (let s=0; s<LOOP_STEPS; s++){
        const len = grid[p][s];
        if (len <= 0) continue;

        const x = leftPad + s*cellW + 1;
        const y = H - (p+1)*cellH + 1;
        const clampedLen = Math.min(len, LOOP_STEPS - s);
        const w = (cellW * clampedLen) - 2;
        const h = cellH - 2;

        g.fillStyle = noteColor();
        g.fillRect(x,y,w,h);

        g.strokeStyle = "rgba(255,255,255,.18)";
        g.strokeRect(x+0.5,y+0.5,w-1,h-1);
      }
    }

    if (playheadStep >= 0){
      const x = leftPad + playheadStep*cellW;
      g.fillStyle = "rgba(255,255,255,.12)";
      g.fillRect(x,0,cellW,H);
    }
  }

  function rollHitTest(clientX, clientY){
    const rect = rollCanvas.getBoundingClientRect();
    const px = (clientX - rect.left) * (rollCanvas.width / rect.width);
    const py = (clientY - rect.top)  * (rollCanvas.height / rect.height);

    const W = rollCanvas.width;
    const H = rollCanvas.height;

    const leftPad = KEY_PAD;
    const cellW = (W - leftPad) / LOOP_STEPS;
    const cellH = H / ROLL_PITCHES;

    const pitch = Math.floor((H - py) / cellH);
    if (pitch < 0 || pitch >= ROLL_PITCHES) return null;

    if (px < leftPad) return { area:"keys", pitch };

    const step = Math.floor((px - leftPad) / cellW);
    if (step < 0 || step >= LOOP_STEPS) return null;

    return { area:"grid", pitch, step };
  }

  function findCoveringNote(row, step){
    for (let s=0; s<MASTER_STEPS; s++){
      const len = row[s];
      if (len <= 0) continue;
      if (step >= s && step < s + len) return {start:s, len};
    }
    return null;
  }

  function setNoteLenOnGrid(grid, pitch, start, len){
    const row = grid[pitch];
    len = Math.max(1, Math.min(len, MASTER_STEPS - start));
    // clear overlaps
    for (let i=0; i<MASTER_STEPS; i++){
      const l = row[i];
      if (l <= 0) continue;
      if (rangesOverlap(i, l, start, len)) row[i] = 0;
    }
    row[start] = len;
  }

  let noteDrag = {active:false, pointerId:null, grid:null, pitch:0, start:0};

  rollCanvas.addEventListener("pointerdown", async (e) => {
    e.preventDefault();
    const hit = rollHitTest(e.clientX, e.clientY);
    if (!hit) return;

    const midi = ROLL_BASE_MIDI + hit.pitch;
    const grid = getActiveGrid();

    if (hit.area === "keys"){
      await previewMidi(midi);
      return;
    }

    const row = grid[hit.pitch];
    const existing = findCoveringNote(row, hit.step);
    if (existing){
      row[existing.start] = 0;
      drawRoll(isPlaying ? currentStep : -1);
      return;
    }

    await previewMidi(midi);

    setNoteLenOnGrid(grid, hit.pitch, hit.step, 1);
    noteDrag = {active:true, pointerId:e.pointerId, grid, pitch:hit.pitch, start:hit.step};
    rollCanvas.setPointerCapture(e.pointerId);

    drawRoll(isPlaying ? currentStep : -1);
  }, {passive:false});

  rollCanvas.addEventListener("pointermove", (e) => {
    if (!noteDrag.active) return;
    if (noteDrag.pointerId !== e.pointerId) return;
    e.preventDefault();

    const hit = rollHitTest(e.clientX, e.clientY);
    if (!hit || hit.area !== "grid") return;

    const len = Math.max(1, (hit.step - noteDrag.start) + 1);
    setNoteLenOnGrid(noteDrag.grid, noteDrag.pitch, noteDrag.start, len);
    drawRoll(isPlaying ? currentStep : -1);
  }, {passive:false});

  const endNoteDrag = (e) => {
    if (!noteDrag.active) return;
    if (noteDrag.pointerId !== e.pointerId) return;
    noteDrag.active = false;
    noteDrag.pointerId = null;
  };
  rollCanvas.addEventListener("pointerup", endNoteDrag);
  rollCanvas.addEventListener("pointercancel", endNoteDrag);
  rollCanvas.addEventListener("lostpointercapture", () => {
    noteDrag.active = false;
    noteDrag.pointerId = null;
  });

  // ABSOLUTE BPM playback
  function secondsPerStep(){
    const quarter = 60 / bpm;
    return quarter / 4;
  }

  function scheduleStep(step, time){
    if (project.drums.kick[step])   playKick(time);
    if (project.drums.snare[step])  playSnare(time);
    if (project.drums.clap[step])   playClap(time);
    if (project.drums.shaker[step]) playShaker(time);
    if (project.drums.ch[step])     playCH(time);
    if (project.drums.oh[step])     playOH(time);

    for (let p=0; p<ROLL_PITCHES; p++){
      const len = project.piano[p][step];
      if (len > 0){
        const hz = midiToHz((ROLL_BASE_MIDI + p) + transpose.piano);
        playVoice(hz, time, secondsPerStep()*len*0.98, pianoBus, "square", 0.18, 4200);
      }
    }
    for (let p=0; p<ROLL_PITCHES; p++){
      const len = project.synth[p][step];
      if (len > 0){
        const hz = midiToHz((ROLL_BASE_MIDI + p) + transpose.synth);
        playVoice(hz, time, secondsPerStep()*len*0.98, synthBus, "sawtooth", 0.15, 6000);
      }
    }
    for (let p=0; p<ROLL_PITCHES; p++){
      const len = project.bass[p][step];
      if (len > 0){
        const hz = midiToHz((ROLL_BASE_MIDI + p) + transpose.bass);
        playVoice(hz, time, secondsPerStep()*len*0.98, bassBus, "triangle", 0.24, 1500);
      }
    }

    updatePlayheadUI(step);
    drawRoll(step);
  }

  function nextStep(){
    currentStep = (currentStep + 1) % LOOP_STEPS;
    nextNoteTime += secondsPerStep();
  }

  function tick(){
    while (nextNoteTime < ctx.currentTime + scheduleAhead){
      scheduleStep(currentStep, nextNoteTime);
      nextStep();
    }
    timerId = window.setTimeout(tick, lookAhead * 1000);
  }

  async function startFromCurrentStep(){
    await ensureRunning();

    for (const k of drumKeys){
      const vv = project.drumVols[k] ?? 100;
      const x = vv / 100;
      drumGains[k].gain.value = x * x;
    }

    applyMixerNodes("piano");
    applyMixerNodes("synth");
    applyMixerNodes("bass");
    applyMixerNodes("drum");
    setReverbReturn(rvReturn);
    setReverbSize(rvSize);

    isPlaying = true;
    isPaused = false;

    playBtn.disabled = true;
    pauseBtn.disabled = false;
    stopBtn.disabled = false;

    nextNoteTime = ctx.currentTime + 0.06;
    tick();
  }

  function pause(){
    isPaused = true;
    isPlaying = false;

    playBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = false;

    if (timerId) { clearTimeout(timerId); timerId = null; }
  }

  function stopTransportOnly(){
    isPlaying = false;
    isPaused = false;

    if (timerId) { clearTimeout(timerId); timerId = null; }

    currentStep = 0;
    updatePlayheadUI(-1);
    drawRoll(-1);

    playBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
  }

  function togglePlayPause(){
    if (!ctx && !isPlaying && !isPaused){ startFromCurrentStep(); return; }
    if (isPlaying) pause();
    else startFromCurrentStep();
  }

  playBtn.addEventListener("click", () => { currentStep = 0; startFromCurrentStep(); });
  pauseBtn.addEventListener("click", pause);
  stopBtn.addEventListener("click", stopTransportOnly);

  resEl.addEventListener("input", () => {
    const opt = RES_OPTIONS[Number(resEl.value)];
    applyLoopSize(opt.steps, opt.label);
  });

  function applyLoopSize(newLoopSteps, label){
    stopTransportOnly();
    LOOP_STEPS = newLoopSteps;
    resLabel.textContent = label;
    resText.textContent = label;
    groupText.textContent = label;
    buildDrumGrid();
    drawRoll(-1);
  }

  loadDemoBtn.addEventListener("click", async () => {
    try { await loadDemoFromMidiFolder(); }
    catch (e){
      console.warn("Demo MIDI load failed; using drum demo only.", e);
      setDemoDrumsFromAudioAnalysis();
      buildDrumGrid();
      drawRoll(-1);
    }
  });

  clearProjectBtn.addEventListener("click", clearProject);

  importMidiBtn.addEventListener("click", () => midiFileInput.click());
  midiFileInput.addEventListener("change", async () => {
    const file = midiFileInput.files && midiFileInput.files[0];
    if (!file) return;
    const arr = await file.arrayBuffer();
    if (!window.Midi){
      alert("MIDI parser failed to load.");
      return;
    }
    const grid = getActiveGrid();
    await importMidiIntoGrid(arr, grid);
    drawRoll(isPlaying ? currentStep : -1);
    midiFileInput.value = "";
  });

  // ---------------------------
  // ✅ Project Save / Load
  // ---------------------------
  function clampInt(v, min, max){
    v = Number(v);
    if (!Number.isFinite(v)) return min;
    v = Math.round(v);
    return Math.max(min, Math.min(max, v));
  }

  function buildSavePayload(){
    return {
      version: 1,
      savedAt: new Date().toISOString(),
      bpm,
      resolutionLabel: RES_OPTIONS[Number(resEl.value)]?.label ?? "1/64",
      resolutionIndex: Number(resEl.value),
      loopSteps: LOOP_STEPS,

      project: {
        drums: project.drums,
        piano: project.piano,
        synth: project.synth,
        bass:  project.bass,
        drumVols: project.drumVols
      },

      mix: {
        piano: { panVal: mix.piano.panVal, lpfVal: mix.piano.lpfVal, sendVal: mix.piano.sendVal },
        synth: { panVal: mix.synth.panVal, lpfVal: mix.synth.lpfVal, sendVal: mix.synth.sendVal },
        bass:  { panVal: mix.bass.panVal,  lpfVal: mix.bass.lpfVal,  sendVal: mix.bass.sendVal  },
        drum:  { panVal: mix.drum.panVal,  lpfVal: mix.drum.lpfVal,  sendVal: mix.drum.sendVal  },
        reverb: { return: rvReturn, size: rvSize }
      },

      transpose: { ...transpose },
      busState: JSON.parse(JSON.stringify(busState)),
    };
  }

  function downloadJson(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function applyLoadedProject(data){
    stopTransportOnly();

    // BPM
    if (Number.isFinite(Number(data.bpm))){
      bpm = Number(data.bpm);
      bpmEl.value = String(clampInt(bpm, 70, 180));
      bpm = Number(bpmEl.value);
      bpmLabel.textContent = String(bpm);
    }

    // Resolution/loop steps
    let idx = Number.isFinite(Number(data.resolutionIndex))
      ? clampInt(data.resolutionIndex, 0, RES_OPTIONS.length - 1)
      : null;

    if (idx === null && typeof data.resolutionLabel === "string"){
      const found = RES_OPTIONS.findIndex(x => x.label === data.resolutionLabel);
      if (found >= 0) idx = found;
    }
    if (idx === null) idx = 2; // default 1/64

    resEl.value = String(idx);
    const opt = RES_OPTIONS[idx];
    LOOP_STEPS = opt.steps;
    resLabel.textContent = opt.label;
    resText.textContent = opt.label;
    groupText.textContent = opt.label;

    // Drums
    if (data.project?.drums){
      for (const k of drumKeys){
        const src = data.project.drums[k];
        if (Array.isArray(src)){
          for (let i=0; i<MASTER_STEPS; i++){
            project.drums[k][i] = !!src[i];
          }
        }
      }
    }

    // Piano roll grids
    function loadGrid(dst, src){
      if (!Array.isArray(src)) return;
      for (let p=0; p<ROLL_PITCHES; p++){
        const row = src[p];
        if (!Array.isArray(row)) continue;
        for (let s=0; s<MASTER_STEPS; s++){
          const v = row[s];
          dst[p][s] = clampInt(v ?? 0, 0, MASTER_STEPS);
        }
      }
    }
    loadGrid(project.piano, data.project?.piano);
    loadGrid(project.synth, data.project?.synth);
    loadGrid(project.bass,  data.project?.bass);

    // Drum row volumes
    if (data.project?.drumVols){
      for (const k of drumKeys){
        project.drumVols[k] = clampInt(data.project.drumVols[k] ?? project.drumVols[k] ?? 100, 0, 100);
      }
    }

    // Transpose
    if (data.transpose){
      setTranspose("piano", clampInt(data.transpose.piano ?? 0, -24, 24));
      setTranspose("synth", clampInt(data.transpose.synth ?? 0, -24, 24));
      setTranspose("bass",  clampInt(data.transpose.bass  ?? 0, -24, 24));
    }

    // Mixer (pan/lpf/send + reverb)
    function loadMix(inst){
      const m = data.mix?.[inst];
      if (!m) return;
      mix[inst].panVal  = clampInt(m.panVal  ?? mix[inst].panVal,  -100, 100);
      mix[inst].lpfVal  = clampInt(m.lpfVal  ?? mix[inst].lpfVal,     0, 100);
      mix[inst].sendVal = clampInt(m.sendVal ?? mix[inst].sendVal,    0, 100);
    }
    loadMix("piano"); loadMix("synth"); loadMix("bass"); loadMix("drum");

    if (data.mix?.reverb){
      rvReturn = clampInt(data.mix.reverb.return ?? rvReturn, 0, 100);
      rvSize   = clampInt(data.mix.reverb.size   ?? rvSize,   0, 100);
    }

    // Bus state
    if (data.busState){
      for (const name of ["piano","synth","bass","drum"]){
        if (!data.busState[name]) continue;
        busState[name].mute = !!data.busState[name].mute;
        busState[name].solo = !!data.busState[name].solo;
        busBtns[name].mute.classList.toggle("active", busState[name].mute);
        busBtns[name].solo.classList.toggle("active", busState[name].solo);
      }
    }

    // Rebuild UI for LOOP_STEPS
    buildDrumGrid();
    refreshDrumUI();
    drawRoll(-1);

    // Apply audio routing if audio is already created
    if (ctx){
      applyBusRouting();
      applyMixerNodes("piano");
      applyMixerNodes("synth");
      applyMixerNodes("bass");
      applyMixerNodes("drum");
      setReverbReturn(rvReturn);
      setReverbSize(rvSize);
    }

    // Update knob text + visuals (bindings remain active)
    knobEls.piano.panV.textContent = String(mix.piano.panVal); setKnobVisual(knobEls.piano.panK, (mix.piano.panVal + 100)/200);
    knobEls.piano.lpfV.textContent = String(mix.piano.lpfVal); setKnobVisual(knobEls.piano.lpfK, mix.piano.lpfVal/100);
    knobEls.piano.sndV.textContent = String(mix.piano.sendVal); setKnobVisual(knobEls.piano.sndK, mix.piano.sendVal/100);

    knobEls.synth.panV.textContent = String(mix.synth.panVal); setKnobVisual(knobEls.synth.panK, (mix.synth.panVal + 100)/200);
    knobEls.synth.lpfV.textContent = String(mix.synth.lpfVal); setKnobVisual(knobEls.synth.lpfK, mix.synth.lpfVal/100);
    knobEls.synth.sndV.textContent = String(mix.synth.sendVal); setKnobVisual(knobEls.synth.sndK, mix.synth.sendVal/100);

    knobEls.bass.panV.textContent = String(mix.bass.panVal); setKnobVisual(knobEls.bass.panK, (mix.bass.panVal + 100)/200);
    knobEls.bass.lpfV.textContent = String(mix.bass.lpfVal); setKnobVisual(knobEls.bass.lpfK, mix.bass.lpfVal/100);
    knobEls.bass.sndV.textContent = String(mix.bass.sendVal); setKnobVisual(knobEls.bass.sndK, mix.bass.sendVal/100);

    knobEls.drum.panV.textContent = String(mix.drum.panVal); setKnobVisual(knobEls.drum.panK, (mix.drum.panVal + 100)/200);
    knobEls.drum.lpfV.textContent = String(mix.drum.lpfVal); setKnobVisual(knobEls.drum.lpfK, mix.drum.lpfVal/100);
    knobEls.drum.sndV.textContent = String(mix.drum.sendVal); setKnobVisual(knobEls.drum.sndK, mix.drum.sendVal/100);

    knobEls.rv.retV.textContent = String(rvReturn); setKnobVisual(knobEls.rv.retK, rvReturn/100);
    knobEls.rv.sizV.textContent = String(rvSize);   setKnobVisual(knobEls.rv.sizK, rvSize/100);
  }

  function saveProject(){
    const payload = buildSavePayload();
    const name = `RetroLoop_Project_${(new Date()).toISOString().replace(/[:.]/g,"-")}.json`;
    downloadJson(name, payload);
  }

  async function loadProjectFromFile(file){
    const text = await file.text();
    let data;
    try { data = JSON.parse(text); }
    catch {
      alert("That file doesn’t look like valid project JSON.");
      return;
    }
    applyLoadedProject(data);
  }

  saveProjectBtn.addEventListener("click", async () => {
    // optional: resume audio so state is fully live
    await ensureRunning().catch(()=>{});
    saveProject();
  });

  loadProjectBtn.addEventListener("click", () => projectFileInput.click());

  projectFileInput.addEventListener("change", async () => {
    const file = projectFileInput.files && projectFileInput.files[0];
    if (!file) return;
    await loadProjectFromFile(file);
    projectFileInput.value = "";
  });

  // Init values + visuals
  bpm = 115;
  bpmEl.value = "115";
  bpmLabel.textContent = "115";

  resEl.value = "2";
  const initialOpt = RES_OPTIONS[Number(resEl.value)];
  LOOP_STEPS = initialOpt.steps;
  resLabel.textContent = initialOpt.label;
  resText.textContent = initialOpt.label;
  groupText.textContent = initialOpt.label;

  // init transpose knobs
  setTranspose("piano", 0);
  setTranspose("synth", 0);
  setTranspose("bass", 0);
  attachTransposeKnob(pianoTrKnob, "piano");
  attachTransposeKnob(synthTrKnob, "synth");
  attachTransposeKnob(bassTrKnob, "bass");

  // init mixer knobs
  bindTrackMixer("piano");
  bindTrackMixer("synth");
  bindTrackMixer("bass");
  bindTrackMixer("drum");
  bindReverbKnobs();

  buildDrumGrid();
  drawRoll(-1);

  // Auto demo load
  (async () => {
    try{
      await loadDemoFromMidiFolder();
    } catch (e){
      console.warn("Auto demo MIDI load failed; fallback to drum demo only.", e);
      setDemoDrumsFromAudioAnalysis();
      buildDrumGrid();
      drawRoll(-1);
    }
  })();

})();
</script>
</body>
</html>
