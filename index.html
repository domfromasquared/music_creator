<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>RetroLoop Studio — Drum Sequencer + Piano Roll</title>
  <style>
    :root{
      --bg:#0f1115;
      --ink:#e9eef5;
      --muted:#97a3b6;

      --btn:#22283a;
      --btn2:#2a3150;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --groupA:#121a28;
      --groupB:#211a2f;
      --inactiveOverlay: rgba(0,0,0,0.38);
      --playheadOutline: rgba(255,255,255,0.30);
      --beatDivider: rgba(255,255,255,0.18);
      --dragOutline: rgba(255,255,255,0.45);
      --dragFill: rgba(255,255,255,0.10);

      --userBg: #0f1115;

      --kick: #ff8b5a;
      --snare:#58a6ff;
      --clap: #ffffff;

      --shaker:#ba8cff;
      --ch:#7cffb2;
      --oh:#ffd278;

      --tom:#ff78c8;
      --ride:#78d2ff;
      --crash:#ff7878;

      --rollBg: rgba(0,0,0,.18);
      --rollStrip: rgba(0,0,0,.32);
      --gridLine: rgba(255,255,255,.06);
      --gridBeat: rgba(255,255,255,.14);

      --whiteKeyA: rgba(255,255,255,0.92);
      --whiteKeyB: rgba(255,255,255,0.82);
      --blackKeyA: rgba(12,14,20,0.98);
      --blackKeyB: rgba(22,24,32,0.98);
      --keyBorder: rgba(0,0,0,0.35);

      --rowWhiteA: rgba(255,255,255,.03);
      --rowWhiteB: rgba(255,255,255,.015);
      --rowBlack: rgba(0,0,0,.22);

      --pianoNote: rgba(124,255,178,.85);
      --epNote: rgba(255, 215, 120, .82);
      --polyNote: rgba(120, 255, 240, .76);
      --bellNote: rgba(255, 150, 230, .76);
      --synthNote: rgba(255,139,90,.78);
      --bassNote: rgba(88,166,255,.80);
      --padNote: rgba(186,140,255,.72);

      --knobBg: rgba(0,0,0,.30);

      --knobFillPiano: rgba(124,255,178,.95);
      --knobGlowPiano: rgba(124,255,178,.28);

      --knobFillEP: rgba(255, 215, 120, .95);
      --knobGlowEP: rgba(255, 215, 120, .24);

      --knobFillPoly: rgba(120,255,240,.95);
      --knobGlowPoly: rgba(120,255,240,.22);

      --knobFillBell: rgba(255,150,230,.95);
      --knobGlowBell: rgba(255,150,230,.22);

      --knobFillSynth: rgba(255,139,90,.95);
      --knobGlowSynth: rgba(255,139,90,.28);

      --knobFillBass: rgba(88,166,255,.95);
      --knobGlowBass: rgba(88,166,255,.28);

      --knobFillPad: rgba(186,140,255,.95);
      --knobGlowPad: rgba(186,140,255,.26);

      --knobFillDrum: rgba(255,255,255,.92);
      --knobGlowDrum: rgba(255,255,255,.18);

      --knobFillFx: rgba(186,140,255,.92);
      --knobGlowFx: rgba(186,140,255,.22);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 20% -10%, #1b2040 0%, transparent 60%),
        radial-gradient(900px 500px at 90% 0%, #223022 0%, transparent 55%),
        var(--userBg);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 18px;
    }
    h1{margin:0 0 6px 0; font-size:18px; letter-spacing:.2px}
    .sub{color:var(--muted); margin:0 0 16px 0; font-size:13px}

    .wrap{
      display:grid;
      grid-template-columns: 440px 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.07);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .card .hd{
      padding: 12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .hd .left{display:flex; align-items:center; gap:10px;}

    .title{
      font-size:13px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.12em
    }
    .bd{padding: 12px}

    button{
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ink);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 700;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:disabled{opacity:.5; cursor:not-allowed}

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    input[type="range"]{width: 150px}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:8px;
      background: rgba(0,0,0,.25);
      color: var(--ink);
    }
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}

    .msBtn{
      padding: 6px 9px;
      border-radius: 10px;
      font-size: 12px;
      line-height: 1;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      user-select:none;
    }
    .msBtn.active{
      color: var(--ink);
      border-color: rgba(255,255,255,.28);
      background: rgba(255,255,255,.10);
    }
    .msBtn.mute.active{
      background: rgba(255,80,80,.18);
      border-color: rgba(255,80,80,.35);
    }
    .msBtn.solo.active{
      background: rgba(124,255,178,.14);
      border-color: rgba(124,255,178,.30);
    }

    /* --- Compact Mixer --- */
    .mixer{
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      overflow-x: auto;
    }
    .mixerTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .mixerTitle{
      font-size:12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .12em;
    }
    .mixerGrid{
      display:grid;
      grid-template-columns: repeat(8, minmax(230px, 1fr));
      gap: 10px;
      min-width: 1600px;
    }
    @media (max-width: 980px){
      .mixerGrid{
        grid-template-columns: repeat(2, minmax(240px, 1fr));
        min-width: unset;
      }
    }

    .strip{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.16);
      padding: 12px;
      min-width: 0;
      overflow:hidden;
    }
    .stripHd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom: 10px;
    }
    .stripName{
      font-weight: 800;
      font-size: 12px;
      letter-spacing: .06em;
      color: var(--ink);
      white-space:nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }

    .stripBody{
      display:grid;
      grid-template-columns: 56px 1fr;
      gap: 12px;
      align-items: stretch;
      min-width: 0;
    }

    .faderCol{
      width: 56px;
      min-width: 56px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.16);
      padding: 10px 7px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      gap: 8px;
    }
    .faderLbl{
      font-size: 10px;
      color: var(--muted);
      letter-spacing:.10em;
      text-transform: uppercase;
      user-select:none;
    }
    .faderVal{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      width: 44px;
      text-align:center;
      user-select:none;
    }
    .vFaderWrap{
      height: 138px;
      width: 34px;
      display:flex;
      align-items:center;
      justify-content:center;
      touch-action:none;
    }
    .vFader{
      width: 138px;
      height: 32px;
      transform: rotate(-90deg);
      transform-origin: center;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
    }
    .vFader::-webkit-slider-runnable-track{
      height: 10px;
      background: rgba(255,255,255,.12);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .vFader::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      margin-top: -5px;
      background: rgba(0,140,255,.95);
    }
    .vFader::-moz-range-track{
      height: 10px;
      background: rgba(255,255,255,.12);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .vFader::-moz-range-thumb{
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      background: rgba(0,140,255,.95);
    }

    .faderCol[data-inst="piano"] .vFader::-webkit-slider-thumb{ background: var(--knobFillPiano); }
    .faderCol[data-inst="ep"]    .vFader::-webkit-slider-thumb{ background: var(--knobFillEP); }
    .faderCol[data-inst="poly"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillPoly); }
    .faderCol[data-inst="bell"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillBell); }
    .faderCol[data-inst="synth"] .vFader::-webkit-slider-thumb{ background: var(--knobFillSynth); }
    .faderCol[data-inst="bass"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillBass); }
    .faderCol[data-inst="pad"]   .vFader::-webkit-slider-thumb{ background: var(--knobFillPad); }
    .faderCol[data-inst="drum"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillDrum); }

    .faderCol[data-inst="piano"] .vFader::-moz-range-thumb{ background: var(--knobFillPiano); }
    .faderCol[data-inst="ep"]    .vFader::-moz-range-thumb{ background: var(--knobFillEP); }
    .faderCol[data-inst="poly"]  .vFader::-moz-range-thumb{ background: var(--knobFillPoly); }
    .faderCol[data-inst="bell"]  .vFader::-moz-range-thumb{ background: var(--knobFillBell); }
    .faderCol[data-inst="synth"] .vFader::-moz-range-thumb{ background: var(--knobFillSynth); }
    .faderCol[data-inst="bass"]  .vFader::-moz-range-thumb{ background: var(--knobFillBass); }
    .faderCol[data-inst="pad"]   .vFader::-moz-range-thumb{ background: var(--knobFillPad); }
    .faderCol[data-inst="drum"]  .vFader::-moz-range-thumb{ background: var(--knobFillDrum); }

    .faderMS{
      display:flex;
      gap:6px;
      margin-top: 2px;
    }

    .knob{
      width:34px;
      height:34px;
      border-radius:999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.10), rgba(0,0,0,.24)), var(--knobBg);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25), 0 0 0 2px rgba(0,0,0,.12);
      position:relative;
      touch-action:none;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      --knobDeg: 0deg;
      --knobRot: -135deg;
      --knobFill: rgba(0,140,255,.95);
      --knobGlow: rgba(0,140,255,.28);
    }
    .knob::before{
      content:"";
      position:absolute;
      inset:4px;
      border-radius:999px;
      background:
        conic-gradient(from 225deg,
          var(--knobFill) 0deg,
          var(--knobFill) var(--knobDeg),
          rgba(255,255,255,.10) var(--knobDeg),
          rgba(255,255,255,.10) 270deg
        );
      filter: drop-shadow(0 0 10px var(--knobGlow));
      mask: radial-gradient(circle, transparent 55%, #000 56%);
      -webkit-mask: radial-gradient(circle, transparent 55%, #000 56%);
    }
    .knobDot{
      position:absolute;
      left:50%;
      top:50%;
      width:4px;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.85);
      transform-origin: 50% calc(100% + 4px);
      transform: translate(-50%,-90%) rotate(var(--knobRot));
      opacity:.9;
    }
    .kCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      width: 56px;
      min-width: 56px;
    }
    .kLbl{
      font-size: 10px;
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase;
      user-select:none;
    }
    .kMiniVal{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      width: 48px;
      text-align:center;
      user-select:none;
    }
    .stripKnobs{
      /* PAN (top) / LPF (middle) / VERB (bottom) — locked to one vertical column */
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      gap: 10px;
      min-width: 0;
    }
    .stripKnobs .kCol{
      /* Force all three knob modules to share the same width so their centers align perfectly */
      width: 64px;
      align-items:center;
    }

    /* Drum */
    .drumGrid{
      display:grid;
      grid-template-columns: var(--drumControlsW, 320px) minmax(0, 1fr);
      gap:10px;
      align-items:start;
      touch-action: none;
    }
    .stepsWrap{
      overflow-x:auto;
      overflow-y:hidden;
      border-radius: 12px;
      min-width: 0;
      /* Make visible pattern width ~ pattern height (square-ish) */
      width: 100%;
      max-width: 100%;
padding-bottom: 2px;
    }
    .trackNames{display:grid; gap:8px;}
    .trackName{
      height: var(--drumRowH, 44px);
      border-radius: 12px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.08);
      padding: 6px 8px;
      user-select:none;
      display:grid;
      grid-template-columns: 28px 1fr 44px;
      align-items:center;
      gap:10px;
      min-width: 0;
    }
    .trackLabel{
      font-size:12px;
      color: var(--muted);
      text-transform:uppercase;
      letter-spacing:.08em;
      line-height:1;
      flex: 1 1 auto;
      min-width: 0;
      cursor:pointer;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }

    .rowDel{
      width:26px; height:26px;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .rowDel:hover{ background: rgba(0,0,0,.34); border-color: rgba(255,255,255,.18); transform: translateY(-1px); }
    .rowDel:active{ transform: translateY(0); }

    .trackSelect{
      appearance:none;
      -webkit-appearance:none;
      width:100%;
      min-width: 0;
      height: 36px;
      border-radius: 10px;
      padding: 0 28px 0 12px;
      font-weight: 600;
      font-size: 14px;
      min-width: 140px;
      color: #e9eef5;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.14);
      cursor:pointer;
      outline:none;
    }
    .trackSelect:focus{ box-shadow: 0 0 0 2px rgba(88,166,255,.25); border-color: rgba(88,166,255,.35); }
    .trackSelect option{ color:#111; background:#fff; }

    .trackSelectWrap{
      position:relative;
      min-width:0;
    }
    .trackSelectWrap::after{
      content:"";
      position:absolute;
      right:10px;
      top:50%;
      width: 0; height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 6px solid rgba(233,238,245,.70);
      transform: translateY(-30%);
      pointer-events:none;
      opacity:.85;
    }

    .knob{
      position:relative;
    }
    .knobVal{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:10px;
      font-weight:700;
      color: rgba(233,238,245,.82);
      pointer-events:none;
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
    }
}

    .steps{
      display:grid;
      gap:8px;
      border-radius: 12px;
      min-width: 0;
      width: max-content;
    }
    .rowSteps{
      display:grid;
      gap:6px;
      height: var(--drumRowH, 44px);
      align-items:stretch;
      touch-action: none;
      width: 100%;
      min-width: 0;
    }
    .drumGrid .cell{
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      position:relative;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      width: var(--cellW, 35px);
      height: var(--cellH, 44px);
      min-width: 0;
    }
    .cell.groupA{ background: var(--groupA); }
    .cell.groupB{ background: var(--groupB); }
    .cell::after{
      content:"";
      position:absolute;
      inset:0;
      background: var(--inactiveOverlay);
      opacity:.55;
      pointer-events:none;
    }
    .cell.on::after{opacity:.07}

    .cell.on.kick{  background: linear-gradient(180deg, var(--kick), rgba(255,139,90,0.45)); border-color: rgba(255,139,90,0.75); }
    .cell.on.snare{ background: linear-gradient(180deg, var(--snare),rgba(88,166,255,0.30)); border-color: rgba(88,166,255,0.65); }
    .cell.on.clap{  background: linear-gradient(180deg, var(--clap), rgba(255,255,255,0.18)); border-color: rgba(255,255,255,0.45); }
    .cell.on.shaker{ background: linear-gradient(180deg, var(--shaker), rgba(186,140,255,0.28)); border-color: rgba(186,140,255,0.60); }
    .cell.on.ch{     background: linear-gradient(180deg, var(--ch), rgba(124,255,178,0.30)); border-color: rgba(124,255,178,0.65); }
    .cell.on.oh{     background: linear-gradient(180deg, var(--oh), rgba(255,210,120,0.24)); border-color: rgba(255,210,120,0.60); }
    .cell.on.tom{    background: linear-gradient(180deg, var(--tom), rgba(255,120,200,0.22)); border-color: rgba(255,120,200,0.60); }
    .cell.on.ride{   background: linear-gradient(180deg, var(--ride), rgba(120,210,255,0.18)); border-color: rgba(120,210,255,0.55); }
    .cell.on.crash{  background: linear-gradient(180deg, var(--crash), rgba(255,120,120,0.18)); border-color: rgba(255,120,120,0.55); }

    .cell.beatDivider{ box-shadow: inset -2px 0 0 var(--beatDivider); }
    .cell.playhead{ outline: 2px solid var(--playheadOutline); outline-offset: 1px; }
    .cell.drag-hover{
      outline: 2px solid var(--dragOutline);
      outline-offset: -2px;
      box-shadow: inset 0 0 0 999px var(--dragFill);
    }

    /* Piano roll */
    .rollHeaderRight{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tab{
      padding: 7px 14px;
      border-radius: 999px;
      font-size:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: background .15s ease, border-color .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .tab.active{ color: var(--ink); }

    .trKnobs{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .trGroup{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.20);
    }
    .trLabel{
      font-size:12px;
      color: var(--muted);
      letter-spacing:.04em;
      user-select:none;
      white-space:nowrap;
    }
    .trKnob{ width:30px; height:30px; }
    .trVal{ width: 42px; }

    .rollWrap{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      overflow:hidden;
      touch-action: none;
    }
    canvas{display:block; width:100%; height:auto; touch-action:none}

    #midiFile{display:none}
    #projectFile{display:none}
    #colorPicker{display:none}

    /* ---------------- MIDI LIBRARY MODAL ---------------- */
    .modalOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      z-index: 9999;
    }
    .modalOverlay.show{ display:flex; }
    .modal{
      width: min(980px, 100%);
      max-height: min(78vh, 720px);
      overflow:hidden;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(20,22,34,.98), rgba(10,10,15,.98));
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      display:flex;
      flex-direction:column;
    }
    .modalHd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      gap: 10px;
    }
    .modalTitle{
      font-weight: 900;
      letter-spacing: .06em;
      text-transform: uppercase;
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .modalControls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .modalBd{
      display:grid;
      grid-template-columns: 260px 1fr;
      min-height: 360px;
      overflow:hidden;
    }
    @media (max-width: 820px){
      .modalBd{ grid-template-columns: 1fr; }
    }
    .libLeft{
      border-right:1px solid rgba(255,255,255,.08);
      padding: 12px;
      overflow:auto;
      background: rgba(0,0,0,.18);
    }
    .libRight{
      padding: 12px;
      overflow:auto;
    }
    .searchRow{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom: 10px;
      flex-wrap:wrap;
    }
    .input{
      flex: 1 1 220px;
      min-width: 160px;
      padding: 10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      color: var(--ink);
      outline:none;
    }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: var(--muted);
      font-size: 12px;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .pack{
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
      margin-bottom: 10px;
    }
    .pack.active{
      border-color: rgba(124,255,178,.30);
      background: rgba(124,255,178,.08);
    }
    .packName{
      font-weight: 900;
      font-size: 13px;
    }
    .packMeta{
      color: var(--muted);
      font-size: 12px;
      margin-top: 4px;
    }
    .fileRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      margin-bottom: 10px;
    }
    .fileName{
      font-weight: 850;
      font-size: 13px;
      min-width: 0;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .fileBtns{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .miniBtn{
      padding: 7px 10px;
      border-radius: 12px;
      font-size: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.26);
      color: var(--ink);
      cursor:pointer;
    }
    .miniBtn.primary{
      border-color: rgba(124,255,178,.28);
      background: rgba(124,255,178,.12);
    }
    .status{
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.35;
    }
  
    /* --- Modular workspace --- */
    #transportCard{
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      width: calc(100% - 24px);
      z-index: 2147483647;
    }
    .workspace{
      position: relative;
    }
    #transportSpacer{ height: 140px; }

    #transportCard .hd.transportHd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    #transportCard .transportLeft{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 120px;
    }
    #transportCard .transportRight{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    #transportCard .bd.transportBd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    #transportCard .transportHint{
      margin:0;
      max-width: 640px;
    }

    .card.module{
      display:flex;
      flex-direction:column;
      resize: both;
      overflow: hidden;
      min-width: 320px;
      min-height: 220px;
    }
    .card.module .hd{
      cursor: grab;
      touch-action: none;
      user-select:none;
    }
    .card.module.dragging .hd{ cursor: grabbing; }
    .card.module .bd{
      flex: 1 1 auto;
      overflow: auto;
    }


/* ===========================
   Premium UI Facelift (CSS-only)
   Keeps all functionality intact
   =========================== */

:root{
  --userBg: #0b0f17;
  --bg:#0b0f17;
  --ink:#eef3fb;
  --muted:#a9b4c8;

  --btn:#171d2b;
  --btn2:#222b44;

  --shadow: 0 18px 60px rgba(0,0,0,.55);

  --groupA: rgba(18,26,40,0.90);
  --groupB: rgba(28,20,45,0.90);
  --inactiveOverlay: rgba(0,0,0,0.42);
  --playheadOutline: rgba(255,255,255,0.36);
  --beatDivider: rgba(255,255,255,0.16);
  --dragOutline: rgba(255,255,255,0.55);
  --dragFill: rgba(255,255,255,0.10);

  --rollBg: rgba(0,0,0,.20);
  --rollStrip: rgba(0,0,0,.36);
  --gridLine: rgba(255,255,255,.06);
  --gridBeat: rgba(255,255,255,.16);

  --knobBg: rgba(0,0,0,.30);
}

/* subtle premium background */
body{
  background:
    radial-gradient(900px 520px at 15% -10%, rgba(115,140,255,.22) 0%, transparent 60%),
    radial-gradient(880px 520px at 90% 0%, rgba(124,255,178,.16) 0%, transparent 55%),
    radial-gradient(900px 520px at 70% 110%, rgba(186,140,255,.18) 0%, transparent 55%),
    linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0) 40%),
    var(--userBg);
  letter-spacing: .2px;
}

/* global typography polish */
h1{
  font-weight: 900;
  letter-spacing: .5px;
}
.sub{
  color: rgba(233,240,255,.70);
}

/* premium “glass” cards without changing layout */
.card{
  background:
    radial-gradient(1200px 600px at 10% 0%, rgba(255,255,255,.06) 0%, rgba(255,255,255,.02) 55%, rgba(0,0,0,.06) 100%),
    linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.018));
  border:1px solid rgba(255,255,255,.10);
  box-shadow: 0 18px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

/* tighter, more premium header */
.card .hd{
  background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,0));
  border-bottom: 1px solid rgba(255,255,255,.08);
}

/* transport bar: stays “executive” */
#transportCard{
  background:
    radial-gradient(1200px 600px at 0% 0%, rgba(255,255,255,.07) 0%, rgba(255,255,255,.02) 55%, rgba(0,0,0,.10) 100%),
    linear-gradient(180deg, rgba(18,22,34,.88), rgba(10,10,15,.70));
  border: 1px solid rgba(255,255,255,.14);
  box-shadow: 0 22px 90px rgba(0,0,0,.65);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
}

/* module shells: match transport “glass” feel */
.module{
  background:
    radial-gradient(1200px 600px at 10% 0%, rgba(255,255,255,.06) 0%, rgba(255,255,255,.02) 55%, rgba(0,0,0,.10) 100%),
    linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.016));
  border:1px solid rgba(255,255,255,.11);
  box-shadow: 0 18px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}
.module .hd{
  background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,0));
  border-bottom: 1px solid rgba(255,255,255,.08);
}

/* buttons: premium hover/focus; no layout changes */
button{
  border-color: rgba(255,255,255,.14);
  box-shadow: 0 8px 24px rgba(0,0,0,.30);
  transition: transform .12s ease, box-shadow .12s ease, filter .12s ease, background .12s ease, border-color .12s ease;
}
button:hover{
  transform: translateY(-1px);
  filter: brightness(1.06);
  box-shadow: 0 12px 34px rgba(0,0,0,.36);
  border-color: rgba(255,255,255,.22);
}
button:active{
  transform: translateY(0px);
  filter: brightness(0.98);
  box-shadow: 0 8px 22px rgba(0,0,0,.30);
}
button:focus-visible{
  outline: none;
  box-shadow: 0 0 0 3px rgba(124,255,178,.20), 0 12px 34px rgba(0,0,0,.36);
  border-color: rgba(124,255,178,.35);
}

/* pills + kbd feel more “product” */
.pill{
  background: rgba(255,255,255,.07);
  border-color: rgba(255,255,255,.12);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
}
.kbd{
  border-color: rgba(255,255,255,.18);
  background: rgba(0,0,0,.30);
}

/* tabs: more premium selection */
.tab{
  background: rgba(255,255,255,.04);
  border-color: rgba(255,255,255,.12);
}
.tab:hover{
  background: rgba(255,255,255,.06);
  border-color: rgba(255,255,255,.18);
}

/* knobs: more depth */
.knob{
  border-color: rgba(255,255,255,.14);
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.30), 0 10px 28px rgba(0,0,0,.35);
}
.knob::before{
  filter: drop-shadow(0 0 12px var(--knobGlow));
}

/* sliders: nicer track/thumb */
input[type="range"]{
  accent-color: rgba(124,255,178,.92);
}
.vFader::-webkit-slider-runnable-track{
  background: rgba(255,255,255,.14);
  border-color: rgba(255,255,255,.12);
}
.vFader::-webkit-slider-thumb{
  border-color: rgba(255,255,255,.22);
  box-shadow: 0 10px 24px rgba(0,0,0,.40);
}
.vFader::-moz-range-track{
  background: rgba(255,255,255,.14);
  border-color: rgba(255,255,255,.12);
}
.vFader::-moz-range-thumb{
  border-color: rgba(255,255,255,.22);
  box-shadow: 0 10px 24px rgba(0,0,0,.40);
}

/* drum cells: crisp */
.cell{
  border-color: rgba(255,255,255,.12);
}
.cell.playhead{
  outline-color: rgba(255,255,255,.44);
}

/* scrollbars (webkit) */
*::-webkit-scrollbar{ height: 10px; width: 10px; }
*::-webkit-scrollbar-track{ background: rgba(255,255,255,.04); border-radius: 999px; }
*::-webkit-scrollbar-thumb{
  background: rgba(255,255,255,.14);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 999px;
}
*::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.20); }

/* reduce motion support */
@media (prefers-reduced-motion: reduce){
  button{ transition:none !important; }
}


/* ================================
   Drum Sequencer – Sound Dropdown
   ================================ */

/* Closed select */
#drumModule .trackSelect {
  background: #f2f3f5;
  color: #0b0f14;            /* dark text */
  border: 1px solid rgba(0,0,0,.25);
}

/* Opened dropdown options */
#drumModule .trackSelect option {
  background: #f2f3f5;       /* SAME as select */
  color: #0b0f14;            /* force readable text */
}

/* Selected / hovered option (native-safe) */
#drumModule .trackSelect option:checked,
#drumModule .trackSelect option:hover {
  background: #4c9df1;
  color: #ffffff;
}



</style>
</head>

<body>
  <h1>RetroLoop Studio</h1>
  <p class="sub">
    4/4 • Drum sequencer + piano roll • Loop size:
    <span class="kbd" id="resText">1/64</span> • Keys: C3 → C5
  </p>

  <div class="wrap workspace">
    <div class="card" id="transportCard" style="grid-column: 1 / -1;">
      <div class="hd transportHd">
        <div class="transportLeft">
          <div class="title">Transport</div>
        </div>

        <div class="btnRow transportBtns">
          <button id="playBtn">Play</button>
          <button id="pauseBtn" disabled>Pause</button>
          <button id="stopBtn" disabled>Stop</button>
        </div>

        <div class="transportRight">
          <div class="pill">
            <span style="min-width:38px;">BPM</span>
            <input id="bpm" type="range" min="70" max="180" value="115"/>
            <span id="bpmLabel" class="kbd">115</span>
          </div>
        </div>
      </div>

      <div class="bd transportBd">
        <div class="btnRow transportActions">
          <button id="loadDemo">Reload Demo</button>
          <button id="clearProject">Clear Project</button>

          <button id="saveProjectBtn">Save Project</button>
          <button id="loadProjectBtn">Load Project</button>
          <input id="projectFile" type="file" accept=".json,application/json"/>

          <button id="importMidiBtn">Import MIDI</button>
          <input id="midiFile" type="file" accept=".mid,.midi" />

          <button id="midiLibraryBtn">MIDI Library</button>

          <button id="bgBtn">Background</button>
        </div>

        <p class="hint transportHint">
          <span class="kbd">Space</span> toggles Play/Pause (desktop).
          Double-click / double-tap any <span class="kbd">instrument</span> or <span class="kbd">drum label</span> to customize its color.
        </p>
      </div>
    </div>

    <div id="transportSpacer" aria-hidden="true"></div>

    <div class="card module" id="mixerModule" style="grid-column: 1 / -1;">
      <div class="hd">
        <div class="title">Mixer</div>
        <div class="pill" style="padding:6px 10px;">
          <span>Reverb</span><span class="kbd">Return</span>
        </div>
      </div>
      <div class="bd">
        <div class="mixer" style="margin-top:0;">
          <div class="mixerTop" style="display:none;">
            <div class="mixerTitle">Mixer</div>
            <div class="pill" style="padding:6px 10px;">
              <span>Reverb</span><span class="kbd">Return</span>
            </div>
          </div>

          <div class="mixerGrid" id="mixerGrid"></div>
        </div>

      </div>
    </div>

    <div class="card module" id="drumModule">
      <div class="hd">
        <div class="left">
          <button class="miniBtn" id="addDrumRowBtn" title="Add drum row" style="border-radius:999px; padding:6px 12px;">+</button>
          <div class="title">Drum Sequencer</div>
        </div>
        <div class="pill"><span>Loop</span><select class="kbd" id="loopSelectDrum"></select></div>
      </div>
      <div class="bd">
        <div class="drumGrid" id="drumGrid"></div>
      </div>
    </div>

    <div class="card module" id="rollModule" style="grid-column: 1 / -1;">
      <div class="hd">
        <div class="title">Piano Roll</div>
        <div class="rollHeaderRight">
          <div class="tabs" id="tabs"></div>
          <div class="trKnobs" id="trKnobs" aria-label="Transpose knobs"></div>
        <div class="pill" style="padding:6px 10px;"><span>Loop</span><select class="kbd" id="loopSelectRoll"></select></div></div>
      </div>

      <div class="bd">
        <div class="rollWrap">
          <canvas id="roll" width="1280" height="560"></canvas>
        </div>
      </div>
    </div>
  </div>

  <input id="colorPicker" type="color" style="display:none;" />

  <!-- MIDI LIBRARY MODAL -->
  <div class="modalOverlay" id="midiModalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="MIDI Library">
      <div class="modalHd">
        <div class="modalTitle">
          <span>MIDI Library</span>
          <span class="kbd" id="targetLaneBadge">Target: Piano</span>
        </div>
        <div class="modalControls">
          <div class="pill" id="laneSuggestPill" style="display:none; padding:6px 10px;">
            <span>Suggested</span>
            <span class="kbd" id="laneSuggestText">—</span>
            <button class="miniBtn primary" id="applyLaneSuggestion" style="padding:6px 10px; border-radius:999px;">Switch</button>
          </div>
          <button class="miniBtn" id="refreshMidiIndex">Refresh</button>
          <button class="miniBtn" id="closeMidiModal">Close</button>
        </div>
      </div>
      <div class="modalBd">
        <div class="libLeft">
          <div class="searchRow">
            <input class="input" id="midiSearch" placeholder="Search packs / files..." />
            <label class="toggle">
              <input type="checkbox" id="fitToLoop" checked />
              Fit to loop
            </label>
          </div>
          <div id="packList"></div>
          <div class="status" id="midiIndexStatus"></div>
        </div>
        <div class="libRight">
          <div id="fileList"></div>
          <div class="status" id="midiFileStatus"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>

<script>
(() => {
  const RES_OPTIONS = [
    { label: "1/16", steps: 16 },
    { label: "1/32", steps: 32 },
    { label: "1/64", steps: 64 },
  ];
  const MASTER_STEPS = 64;

  const ROLL_BASE_MIDI = 48; // C3
  const ROLL_TOP_MIDI  = 72; // C5
  const ROLL_PITCHES   = (ROLL_TOP_MIDI - ROLL_BASE_MIDI) + 1;

  const KEY_PAD = 64; // piano roll left gutter (key labels)

  const DEMO_JSON_PATH = "demos/demo01.json";
  const MIDI_INDEX_PATH = "midi/index.json";

    // --- Drum sound catalog + default rows (modular drums) ---
  const DRUM_SOUNDS = [
    { key:"kick",      label:"Kick" },
    { key:"kick808",   label:"808 Kick" },
    { key:"clap",      label:"Clap" },
    { key:"snare",     label:"Snare" },
    { key:"ch",        label:"CH" },
    { key:"oh",        label:"OH" },
    { key:"ride",      label:"Ride" },
    { key:"crash",     label:"Crash" },

    // extras (all suggestions)
    { key:"snare808",  label:"808 Snare" },
    { key:"rim",       label:"Rim" },
    { key:"cowbell",   label:"Cowbell" },
    { key:"shaker",    label:"Shaker" },
    { key:"tom",       label:"Tom" },

    { key:"click",     label:"Click" },
    { key:"blip",      label:"Blip" },
    { key:"zap",       label:"Zap" },
    { key:"laser",     label:"Laser" },

    { key:"brushkick", label:"Brush Kick" },
    { key:"brushsn",   label:"Brush Snare" },
    { key:"brushhat",  label:"Brush Hat" },
    { key:"noise",     label:"Noise Burst" },
  ];

  const DEFAULT_DRUM_ROWS = ["kick","kick808","clap","snare","ch","oh","ride","crash"];
  const MAX_DRUM_ROWS = 16;

  const LANES = [
    { key:"piano", label:"Piano",  noteVar:"--pianoNote", knobFill:"--knobFillPiano", knobGlow:"--knobGlowPiano" },
    { key:"ep",    label:"E-Piano",noteVar:"--epNote",    knobFill:"--knobFillEP",    knobGlow:"--knobGlowEP" },
    { key:"poly",  label:"Poly",   noteVar:"--polyNote",  knobFill:"--knobFillPoly",  knobGlow:"--knobGlowPoly" },
    { key:"bell",  label:"Bell",   noteVar:"--bellNote",  knobFill:"--knobFillBell",  knobGlow:"--knobGlowBell" },
    { key:"synth", label:"Synth",  noteVar:"--synthNote", knobFill:"--knobFillSynth", knobGlow:"--knobGlowSynth" },
    { key:"bass",  label:"Bass",   noteVar:"--bassNote",  knobFill:"--knobFillBass",  knobGlow:"--knobGlowBass" },
    { key:"pad",   label:"Pad",    noteVar:"--padNote",   knobFill:"--knobFillPad",   knobGlow:"--knobGlowPad" },
  ];

  function laneLabel(key){
    return (LANES.find(l => l.key === key)?.label) || key;
  }



  const transpose = Object.fromEntries(LANES.map(l => [l.key, 0]));

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function clampInt(v, min, max){
    v = Number(v);
    if (!Number.isFinite(v)) return min;
    v = Math.round(v);
    return Math.max(min, Math.min(max, v));
  }
  function cssVar(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  function normalizeHex(hex){
    if (!hex) return "#000000";
    hex = String(hex).trim();
    if (hex.startsWith("rgb")) return rgbStringToHex(hex);
    if (!hex.startsWith("#")) return "#000000";
    if (hex.length === 4) return "#" + hex[1]+hex[1] + hex[2]+hex[2] + hex[3]+hex[3];
    if (hex.length === 7) return hex;
    return "#000000";
  }
  function rgbStringToHex(str){
    const m = str.match(/rgba?\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)/i);
    if (!m) return "#000000";
    const r = clampInt(m[1],0,255), g = clampInt(m[2],0,255), b = clampInt(m[3],0,255);
    const to2 = (n)=>n.toString(16).padStart(2,"0");
    return `#${to2(r)}${to2(g)}${to2(b)}`;
  }
  function hexToRgb(hex){
    hex = normalizeHex(hex);
    return {
      r: parseInt(hex.slice(1,3),16),
      g: parseInt(hex.slice(3,5),16),
      b: parseInt(hex.slice(5,7),16),
    };
  }
  function hexToRgba(hex, a){
    const {r,g,b} = hexToRgb(hex);
    return `rgba(${r},${g},${b},${a})`;
  }
  function relLuminance(hex){
    const {r,g,b} = hexToRgb(hex);
    const srgb = [r,g,b].map(v => v/255).map(v => v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055,2.4));
    return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
  }
  function contrastText(hex){
    const L = relLuminance(hex);
    return (L > 0.55) ? "rgba(0,0,0,0.85)" : "rgba(255,255,255,0.88)";
  }
  function setCssVar(name, value){ document.documentElement.style.setProperty(name, value); }

  // ---------- THEME (persisted in JSON) ----------
  const theme = {
    bgBase: cssVar("--userBg") || "#0f1115",
        drums: {
      kick: cssVar("--kick") || "#ff8b5a",
      kick808: "#ff6a3d",
      snare: cssVar("--snare") || "#58a6ff",
      snare808: "#3b86ff",
      clap: cssVar("--clap") || "#ffffff",
      ch: cssVar("--ch") || "#7cffb2",
      oh: cssVar("--oh") || "#ffd278",
      ride: cssVar("--ride") || "#78d2ff",
      crash: cssVar("--crash") || "#ff7878",
      shaker: cssVar("--shaker") || "#ba8cff",
      tom: cssVar("--tom") || "#ff78c8",
      rim: "#e6edf3",
      cowbell: "#ffd94a",
      click: "#a6b0c3",
      blip: "#78fff0",
      zap: "#ba8cff",
      laser: "#ff96e6",
      brushkick: "#c7d1e4",
      brushsn: "#b8c6de",
      brushhat: "#d1d9e8",
      noise: "#97a3b6",
    },
    lanes: {
      piano: "#7cffb2",
      ep: "#ffd778",
      poly: "#78fff0",
      bell: "#ff96e6",
      synth: "#ff8b5a",
      bass: "#58a6ff",
      pad: "#ba8cff",
    },
    labelText: { drums:{}, lanes:{} }
  };

    function makeEmptyProject(){
    const emptyGrid = () => Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0));

    const defaultVolBySound = {
      kick:100, kick808:92, clap:85, snare:92, ch:62, oh:70, ride:66, crash:70,
      snare808:88, rim:70, cowbell:72, shaker:65, tom:78,
      click:55, blip:60, zap:65, laser:70, brushkick:80, brushsn:78, brushhat:62, noise:58
    };

    const labelFor = (key) => (DRUM_SOUNDS.find(d => d.key === key)?.label) || key;

    const makeRow = (soundKey) => ({
      id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random())),
      soundKey,
      label: labelFor(soundKey),
      steps: new Array(MASTER_STEPS).fill(false),
      vol: (defaultVolBySound[soundKey] ?? 80)
    });

    const drumRows = DEFAULT_DRUM_ROWS.map(makeRow);

    return {
      drumRows,
      piano: emptyGrid(),
      ep:    emptyGrid(),
      poly:  emptyGrid(),
      bell:  emptyGrid(),
      synth: emptyGrid(),
      bass:  emptyGrid(),
      pad:   emptyGrid(),
    };
  }
  const project = makeEmptyProject();
  let LOOP_STEPS = 64;
  let currentResIndex = 2; // 0=1/16,1=1/32,2=1/64

  let ctx = null;
  let master = null;

  const buses = {};
  const mix = {};
  let rvConvolver = null;
  let rvReturnGain = null;
  let rvInput = null;
  let rvSize = 45;
  let rvReturn = 22;

  let drumRowGains = [];

  function ensureDrumRowGains(rebuild=false){
    if (!ctx || !buses.drum) return;

    if (rebuild){
      try{ drumRowGains.forEach(g => g.disconnect()); }catch(e){}
      drumRowGains = [];
    }

    // Add missing gains
    while (drumRowGains.length < project.drumRows.length){
      const idx = drumRowGains.length;
      const g = ctx.createGain();
      g.gain.value = ((project.drumRows[idx]?.vol) ?? 80) / 100;
      g.connect(buses.drum);
      drumRowGains.push(g);
    }

    // Remove extra gains
    while (drumRowGains.length > project.drumRows.length){
      const g = drumRowGains.pop();
      try{ g.disconnect(); }catch(e){}
    }

    // Sync gains with current volumes
    for (let i=0; i<project.drumRows.length; i++){
      if (drumRowGains[i]) drumRowGains[i].gain.value = ((project.drumRows[i].vol) ?? 80) / 100;
    }
  }

let isPlaying = false;
  let isPaused = false;
  let currentStep = 0;
  let nextNoteTime = 0;
  let timerId = null;

  let bpm = 115;
  const lookAhead = 0.025;
  const scheduleAhead = 0.12;

  const playBtn = document.getElementById("playBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const stopBtn = document.getElementById("stopBtn");

  const bpmEl = document.getElementById("bpm");
  const bpmLabel = document.getElementById("bpmLabel");
  const resText = document.getElementById("resText");
  const loopSelectDrum = document.getElementById("loopSelectDrum");
  const loopSelectRoll = document.getElementById("loopSelectRoll");

  const loadDemoBtn = document.getElementById("loadDemo");
  const clearProjectBtn = document.getElementById("clearProject");

  const importMidiBtn = document.getElementById("importMidiBtn");
  const midiFileInput = document.getElementById("midiFile");

  const saveProjectBtn = document.getElementById("saveProjectBtn");
  const loadProjectBtn = document.getElementById("loadProjectBtn");
  const projectFileInput = document.getElementById("projectFile");

  const bgBtn = document.getElementById("bgBtn");
  const colorPicker = document.getElementById("colorPicker");

  const drumGridEl = document.getElementById("drumGrid");
  const rollCanvas = document.getElementById("roll");
  const g = rollCanvas.getContext("2d");

  const mixerGrid = document.getElementById("mixerGrid");
  const tabsEl = document.getElementById("tabs");
  const trKnobsEl = document.getElementById("trKnobs");

  // MIDI LIBRARY elements
  const midiLibraryBtn = document.getElementById("midiLibraryBtn");
  const midiModalOverlay = document.getElementById("midiModalOverlay");
  const closeMidiModal = document.getElementById("closeMidiModal");
  const refreshMidiIndex = document.getElementById("refreshMidiIndex");
  const midiSearch = document.getElementById("midiSearch");
  const fitToLoop = document.getElementById("fitToLoop");
  const packListEl = document.getElementById("packList");
  const fileListEl = document.getElementById("fileList");
  const midiIndexStatus = document.getElementById("midiIndexStatus");
  const midiFileStatus = document.getElementById("midiFileStatus");
  const targetLaneBadge = document.getElementById("targetLaneBadge");
  const laneSuggestPill = document.getElementById("laneSuggestPill");
  const laneSuggestText = document.getElementById("laneSuggestText");
  const applyLaneSuggestionBtn = document.getElementById("applyLaneSuggestion");


  // active lane
  let activeRoll = "piano";

  // ---------- color customization ----------
  function applyLaneColor(laneKey, hex){
    hex = normalizeHex(hex);
    theme.lanes[laneKey] = hex;
    const lane = LANES.find(l => l.key === laneKey);
    if (!lane) return;
    setCssVar(lane.noteVar, hexToRgba(hex, 0.78));
    setCssVar(lane.knobFill, hexToRgba(hex, 0.95));
    setCssVar(lane.knobGlow, hexToRgba(hex, 0.26));
    theme.labelText.lanes[laneKey] = contrastText(hex);
    updateLaneLabelStyles(laneKey);
    updateActiveTabStyles();
    drawRoll(isPlaying ? currentStep : -1);
  }
  function applyDrumColor(drumKey, hex){
    hex = normalizeHex(hex);
    theme.drums[drumKey] = hex;
    setCssVar(`--${drumKey}`, hex);
    theme.labelText.drums[drumKey] = contrastText(hex);
    updateDrumLabelStyles(drumKey);
    refreshDrumUI();
  }
  function applyBgColor(hex){
    hex = normalizeHex(hex);
    theme.bgBase = hex;
    setCssVar("--userBg", hex);
  }

  let pendingPick = null;
  function openColorPicker(startHex, onPick){
    pendingPick = { onPick };
    colorPicker.value = normalizeHex(startHex);
    colorPicker.click();
  }
  colorPicker.addEventListener("input", () => {
    if (!pendingPick || !pendingPick.onPick) return;
    pendingPick.onPick(colorPicker.value);
  });
  colorPicker.addEventListener("change", () => { pendingPick = null; });

  function attachDoubleTap(el, handler){
    el.addEventListener("dblclick", (e) => { e.preventDefault(); handler(e); });
    let lastTap = 0;
    el.addEventListener("pointerup", (e) => {
      if (e.pointerType !== "touch") return;
      const now = performance.now();
      const dt = now - lastTap;
      lastTap = now;
      if (dt < 300) { e.preventDefault(); handler(e); }
    }, {passive:false});
  }

  // ---------- Tabs ----------
  function updateActiveTabStyles(){
    document.querySelectorAll(".tab").forEach(tab => {
      const key = tab.dataset.roll;
      const hex = theme.lanes[key] || "#888888";
      if (tab.classList.contains("active")){
        tab.style.background = hexToRgba(hex, 0.16);
        tab.style.borderColor = hexToRgba(hex, 0.45);
        tab.style.boxShadow = `0 0 0 2px ${hexToRgba(hex, 0.12)} inset`;
        tab.style.color = "var(--ink)";
      } else {
        tab.style.background = "rgba(0,0,0,.22)";
        tab.style.borderColor = "rgba(255,255,255,.10)";
        tab.style.boxShadow = "none";
        tab.style.color = "var(--muted)";
      }
    });
  }

  const laneStripLabelEls = {};
  function updateLaneLabelStyles(laneKey){
    const hex = theme.lanes[laneKey] || "#999999";
    const txt = theme.labelText.lanes[laneKey] || contrastText(hex);
    const el = laneStripLabelEls[laneKey];
    if (el){
      el.style.background = hexToRgba(hex, 0.16);
      el.style.borderColor = hexToRgba(hex, 0.45);
      el.style.color = txt;
    }
  }
  const drumLabelEls = {};
  function updateDrumLabelStyles(drumKey){
    const hex = theme.drums[drumKey] || "#999999";
    const txt = theme.labelText.drums[drumKey] || contrastText(hex);
    const el = drumLabelEls[drumKey];
    if (!el) return;
    el.style.background = hexToRgba(hex, 0.16);
    el.style.borderColor = hexToRgba(hex, 0.45);
    el.style.color = txt;
  }

  function buildTabs(){
    tabsEl.innerHTML = "";
    LANES.forEach((l, idx) => {
      const t = document.createElement("div");
      t.className = "tab" + (idx===0 ? " active" : "");
      t.textContent = l.label;
      t.dataset.roll = l.key;

      t.addEventListener("click", () => {
        document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
        t.classList.add("active");
        activeRoll = l.key;
        updateActiveTabStyles();
        drawRoll(isPlaying ? currentStep : -1);
      });

      attachDoubleTap(t, () => {
        const start = theme.lanes[l.key] || "#888888";
        openColorPicker(start, (hex) => applyLaneColor(l.key, hex));
      });

      tabsEl.appendChild(t);
    });

    updateActiveTabStyles();
  }

  // ---------- Transpose knobs ----------
  function knobStyleForPercent(pct){
    pct = clamp(pct, 0, 1);
    const deg = pct * 270;
    const rot = (-135 + pct * 270);
    return { fillDeg: `${deg}deg`, rotDeg: `${rot}deg` };
  }
  function setKnobVisual(knobEl, pct){
    const st = knobStyleForPercent(pct);
    knobEl.style.setProperty("--knobDeg", st.fillDeg);
    knobEl.style.setProperty("--knobRot", st.rotDeg);
  }
  function semitoneToPct(v){ return (clamp(v, -24, 24) + 24) / 48; }
  function setTranspose(inst, val){
    const v = clamp(Math.round(Number(val)), -24, 24);
    transpose[inst] = v;
    const grp = trKnobsEl.querySelector(`.trGroup[data-inst="${inst}"]`);
    if (grp){
      grp.querySelector(".trVal").textContent = String(v);
      setKnobVisual(grp.querySelector(".knob"), semitoneToPct(v));
    }
  }
  async function ensureRunning(){
    ensureAudio();
    if (ctx.state !== "running") await ctx.resume();
  }
  function attachTransposeKnob(knobEl, inst){
    let active=false, pid=null, startY=0, startVal=0;
    const onDown = async (e) => {
      e.preventDefault();
      await ensureRunning();
      active=true; pid=e.pointerId; startY=e.clientY; startVal=transpose[inst]||0;
      knobEl.setPointerCapture(pid);
    };
    const onMove = (e) => {
      if (!active || e.pointerId !== pid) return;
      e.preventDefault();
      const dy = startY - e.clientY;
      setTranspose(inst, startVal + dy/12);
    };
    const onUp = (e) => { if (!active || e.pointerId !== pid) return; active=false; pid=null; };
    knobEl.addEventListener("pointerdown", onDown, {passive:false});
    knobEl.addEventListener("pointermove", onMove, {passive:false});
    knobEl.addEventListener("pointerup", onUp);
    knobEl.addEventListener("pointercancel", onUp);
    knobEl.addEventListener("lostpointercapture", ()=>{active=false;pid=null;});
    knobEl.addEventListener("dblclick", (e)=>{e.preventDefault(); setTranspose(inst,0);});
  }
  function buildTransposeKnobs(){
    trKnobsEl.innerHTML = "";
    LANES.forEach(l => {
      const grp = document.createElement("div");
      grp.className = "trGroup";
      grp.dataset.inst = l.key;

      const lab = document.createElement("div");
      lab.className = "trLabel";
      lab.textContent = (l.label.length > 6 ? l.label.slice(0,6) : l.label) + " Tr";

      const knob = document.createElement("div");
      knob.className = "knob trKnob";
      knob.style.setProperty("--knobFill", cssVar(l.knobFill));
      knob.style.setProperty("--knobGlow", cssVar(l.knobGlow));
      knob.appendChild(Object.assign(document.createElement("div"), { className:"knobDot" }));

      const val = document.createElement("div");
      val.className = "kbd trVal";
      val.textContent = "0";

      grp.appendChild(lab);
      grp.appendChild(knob);
      grp.appendChild(val);
      trKnobsEl.appendChild(grp);

      setKnobVisual(knob, semitoneToPct(0));
      attachTransposeKnob(knob, l.key);
    });
  }

  // ---------- Transport ----------
  bpmEl.addEventListener("input", () => {
    bpm = Number(bpmEl.value);
    bpmLabel.textContent = String(bpm);
  });
  function isTypingTarget(el){
    if (!el) return false;
    const tag = (el.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || el.isContentEditable;
  }
  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space") return;
    if (isTypingTarget(document.activeElement)) return;
    e.preventDefault();
    togglePlayPause();
  }, {passive:false});

  attachDoubleTap(bgBtn, () => openColorPicker(theme.bgBase || "#0f1115", (hex) => applyBgColor(hex)));
  bgBtn.addEventListener("click", () => openColorPicker(theme.bgBase || "#0f1115", (hex) => applyBgColor(hex)));

  
  // ---------- Loop dropdowns ----------
  function buildLoopDropdowns(){
    const sels = [loopSelectDrum, loopSelectRoll].filter(Boolean);
    sels.forEach(sel => {
      sel.innerHTML = "";
      RES_OPTIONS.forEach((opt, i) => {
        const o = document.createElement("option");
        o.value = String(i);
        o.textContent = opt.label;
        sel.appendChild(o);
      });
      sel.value = String(currentResIndex);
      sel.addEventListener("change", () => {
        const idx = Number(sel.value);
        const opt = RES_OPTIONS[idx] || RES_OPTIONS[currentResIndex];
        currentResIndex = idx;
        applyLoopSize(opt.steps, opt.label);
      });
    });
  }
// ---------- Mixer (existing) ----------
  const busOrder = [...LANES.map(l => l.key), "drum"];
  const busMeta = {
    piano:{ label:"Piano", fill:"--knobFillPiano", glow:"--knobGlowPiano" },
    ep:{ label:"Electric Piano", fill:"--knobFillEP", glow:"--knobGlowEP" },
    poly:{ label:"Poly Synth", fill:"--knobFillPoly", glow:"--knobGlowPoly" },
    bell:{ label:"Bell", fill:"--knobFillBell", glow:"--knobGlowBell" },
    synth:{ label:"Synth", fill:"--knobFillSynth", glow:"--knobGlowSynth" },
    bass:{ label:"Bass", fill:"--knobFillBass", glow:"--knobGlowBass" },
    pad:{ label:"Pad", fill:"--knobFillPad", glow:"--knobGlowPad" },
    drum:{ label:"Drums", fill:"--knobFillDrum", glow:"--knobGlowDrum" },
  };
  const faderDefaults = { piano:0.35, ep:0.30, poly:0.28, bell:0.24, synth:0.32, bass:0.40, pad:0.26, drum:0.85 };
  const busState = Object.fromEntries(busOrder.map(k => [k, { mute:false, solo:false }]));
  const busUI = {};

  function makeStrip(busKey){
    const meta = busMeta[busKey];

    const strip = document.createElement("div");
    strip.className = "strip";

    const hd = document.createElement("div");
    hd.className = "stripHd";
    const name = document.createElement("div");
    name.className = "stripName";
    name.textContent = meta.label;
    hd.appendChild(name);
    strip.appendChild(hd);

    if (busKey !== "drum"){
      laneStripLabelEls[busKey] = name;
      attachDoubleTap(name, () => {
        const start = theme.lanes[busKey] || "#888888";
        openColorPicker(start, (hex) => applyLaneColor(busKey, hex));
      });
      updateLaneLabelStyles(busKey);
    }

    const body = document.createElement("div");
    body.className = "stripBody";

    const faderCol = document.createElement("div");
    faderCol.className = "faderCol";
    faderCol.dataset.inst = busKey;

    const fLbl = document.createElement("div");
    fLbl.className = "faderLbl";
    fLbl.textContent = "Vol";

    const wrap = document.createElement("div");
    wrap.className = "vFaderWrap";
    const fader = document.createElement("input");
    fader.className = "vFader";
    fader.type = "range";
    fader.min = "0"; fader.max="1"; fader.step="0.01";
    fader.value = String(faderDefaults[busKey] ?? 0.3);
    wrap.appendChild(fader);

    const fVal = document.createElement("div");
    fVal.className = "faderVal";
    fVal.textContent = Number(fader.value).toFixed(2);

    const ms = document.createElement("div");
    ms.className = "faderMS";

    const mute = document.createElement("button");
    mute.className = "msBtn mute";
    mute.type = "button";
    mute.textContent = "M";

    const solo = document.createElement("button");
    solo.className = "msBtn solo";
    solo.type = "button";
    solo.textContent = "S";

    ms.appendChild(mute);
    ms.appendChild(solo);

    faderCol.appendChild(fLbl);
    faderCol.appendChild(wrap);
    faderCol.appendChild(fVal);
    faderCol.appendChild(ms);

    const knobs = document.createElement("div");
    knobs.className = "stripKnobs";

    function mkKnob(labelText){
      const col = document.createElement("div");
      col.className = "kCol";
      const k = document.createElement("div");
      k.className = "knob";
      k.style.setProperty("--knobFill", cssVar(meta.fill));
      k.style.setProperty("--knobGlow", cssVar(meta.glow));
      k.appendChild(Object.assign(document.createElement("div"), { className:"knobDot" }));
      const lbl = document.createElement("div");
      lbl.className = "kLbl";
      lbl.textContent = labelText;
      const v = document.createElement("div");
      v.className = "kMiniVal";
      v.textContent = "0";
      col.appendChild(k); col.appendChild(lbl); col.appendChild(v);
      return { col, knob:k, val:v };
    }

    const pan = mkKnob("Pan");
    const lpf = mkKnob("LPF");
    const snd = mkKnob("Verb");
    knobs.appendChild(pan.col);
    knobs.appendChild(lpf.col);
    knobs.appendChild(snd.col);

    body.appendChild(faderCol);
    body.appendChild(knobs);
    strip.appendChild(body);

    busUI[busKey] = { strip, fader, fVal, mute, solo, pan, lpf, snd, labelEl:name };
    return strip;
  }

  function buildMixer(){
    mixerGrid.innerHTML = "";
    busOrder.forEach(k => mixerGrid.appendChild(makeStrip(k)));

    const fx = document.createElement("div");
    fx.className = "strip";
    fx.style.gridColumn = "1 / -1";

    const hd = document.createElement("div");
    hd.className = "stripHd";
    const name = document.createElement("div");
    name.className = "stripName";
    name.textContent = "FX Return";
    name.style.cursor = "default";
    hd.appendChild(name);
    fx.appendChild(hd);

    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "12px";
    row.style.alignItems = "center";
    row.style.flexWrap = "wrap";

    const knobs = document.createElement("div");
    knobs.className = "stripKnobs";
    knobs.style.flex = "0 0 auto";

    function mkFxKnob(labelText){
      const col = document.createElement("div");
      col.className = "kCol";
      const k = document.createElement("div");
      k.className = "knob";
      k.style.setProperty("--knobFill", cssVar("--knobFillFx"));
      k.style.setProperty("--knobGlow", cssVar("--knobGlowFx"));
      k.appendChild(Object.assign(document.createElement("div"), { className:"knobDot" }));
      const lbl = document.createElement("div");
      lbl.className = "kLbl";
      lbl.textContent = labelText;
      const v = document.createElement("div");
      v.className = "kMiniVal";
      v.textContent = "0";
      col.appendChild(k); col.appendChild(lbl); col.appendChild(v);
      return { col, knob:k, val:v };
    }

    const rvRet = mkFxKnob("Return");
    const rvSiz = mkFxKnob("Size");
    knobs.appendChild(rvRet.col);
    knobs.appendChild(rvSiz.col);

    row.appendChild(knobs);
    fx.appendChild(row);

    mixerGrid.appendChild(fx);
    busUI.__fx = { rvRet, rvSiz };
  }

  // ---------- Audio graph ----------
  function lpfCutoffFromPct(pct01){
    const min = 200;
    const max = 18000;
    const ratio = max / min;
    return min * Math.pow(ratio, pct01);
  }
  function makeImpulseResponse(decaySeconds){
    const sr = ctx.sampleRate;
    const len = Math.max(1, Math.floor(sr * decaySeconds));
    const buffer = ctx.createBuffer(2, len, sr);
    for (let ch=0; ch<2; ch++){
      const data = buffer.getChannelData(ch);
      for (let i=0; i<len; i++){
        const t = i / len;
        const env = Math.pow(1 - t, 2.8);
        data[i] = (Math.random()*2 - 1) * env;
      }
    }
    return buffer;
  }
  function setReverbSize(size0to100){
    rvSize = clamp(Math.round(size0to100), 0, 100);
    if (!ctx || !rvConvolver) return;
    const decay = 0.6 + (rvSize/100) * 5.4;
    rvConvolver.buffer = makeImpulseResponse(decay);
  }
  function setReverbReturn(v0to100){
    rvReturn = clamp(Math.round(v0to100), 0, 100);
    if (!rvReturnGain) return;
    rvReturnGain.gain.value = (rvReturn/100) * 0.55;
  }

  function ensureAudio(){
    if (ctx) return;

    ctx = new (window.AudioContext || window.webkitAudioContext)();

    master = ctx.createGain();
    master.gain.value = 0.9;
    master.connect(ctx.destination);

    rvInput = ctx.createGain();
    rvConvolver = ctx.createConvolver();
    rvReturnGain = ctx.createGain();
    rvInput.connect(rvConvolver);
    rvConvolver.connect(rvReturnGain);
    rvReturnGain.connect(master);
    rvConvolver.buffer = makeImpulseResponse(0.6 + (rvSize/100)*5.4);
    setReverbReturn(rvReturn);

    busOrder.forEach(k => { buses[k] = ctx.createGain(); });

    busOrder.forEach(k => {
      mix[k] = { lpf:null, pan:null, send:null, panVal:0, lpfVal:100, sendVal: (k==="pad"?22 : 12) };
      const lpf = ctx.createBiquadFilter(); lpf.type = "lowpass";
      const pan = ctx.createStereoPanner();
      const send = ctx.createGain();

      buses[k].connect(lpf);
      lpf.connect(pan);
      pan.connect(master);

      buses[k].connect(send);
      send.connect(rvInput);

      mix[k].lpf = lpf;
      mix[k].pan = pan;
      mix[k].send = send;
    });

    ensureDrumRowGains(true);
function applyMixerNodes(busKey){
      const m = mix[busKey];
      if (!m || !m.pan || !m.lpf || !m.send) return;
      m.pan.pan.value = clamp(m.panVal/100, -1, 1);
      m.lpf.frequency.setValueAtTime(lpfCutoffFromPct(clamp(m.lpfVal/100,0,1)), ctx.currentTime);
      m.lpf.Q.value = 0.7;
      const s = clamp(m.sendVal/100, 0, 1);
      m.send.gain.value = s*s;
    }

    function setKnobVisualDeg(knobEl, pct){
      pct = clamp(pct,0,1);
      const deg = pct * 270;
      const rot = (-135 + pct*270);
      knobEl.style.setProperty("--knobDeg", `${deg}deg`);
      knobEl.style.setProperty("--knobRot", `${rot}deg`);
    }

    function bindKnob({knobEl, valEl, min, max, step, initial, onChange, format, dblClickReset}){
      let value = initial;
      const valueToPct = (v) => (v - min) / (max - min);

      function setValue(v){
        v = clamp(v, min, max);
        if (step) v = Math.round(v / step) * step;
        value = v;
        setKnobVisualDeg(knobEl, valueToPct(value));
        if (valEl) valEl.textContent = format ? format(value) : String(value);
        onChange && onChange(value);
      }
      setValue(value);

      let active=false, pid=null, startY=0, startVal=0;
      const onDown = async (e) => {
        e.preventDefault();
        await ensureRunning();
        active=true; pid=e.pointerId; startY=e.clientY; startVal=value;
        knobEl.setPointerCapture(pid);
      };
      const onMove = (e) => {
        if (!active || e.pointerId !== pid) return;
        e.preventDefault();
        const dy = startY - e.clientY;
        const delta = (dy / 120) * (max - min);
        setValue(startVal + delta);
      };
      const onUp = (e) => { if (!active || e.pointerId !== pid) return; active=false; pid=null; };

      knobEl.addEventListener("pointerdown", onDown, {passive:false});
      knobEl.addEventListener("pointermove", onMove, {passive:false});
      knobEl.addEventListener("pointerup", onUp);
      knobEl.addEventListener("pointercancel", onUp);
      knobEl.addEventListener("lostpointercapture", ()=>{active=false;pid=null;});
      if (dblClickReset !== undefined){
        knobEl.addEventListener("dblclick", (e)=>{e.preventDefault(); setValue(dblClickReset);});
      }
      return { get:()=>value, set:setValue };
    }

    function applyBusRouting(){
      const anySolo = Object.values(busState).some(b => b.solo);
      function effGain(busKey){
        const base = Number(busUI[busKey].fader.value);
        const s = busState[busKey];
        if (anySolo) return (s.solo ? (s.mute ? 0 : base) : 0);
        return (s.mute ? 0 : base);
      }
      busOrder.forEach(k => { buses[k].gain.value = effGain(k); });
    }

    function syncVolReadouts(){
      busOrder.forEach(k => { busUI[k].fVal.textContent = Number(busUI[k].fader.value).toFixed(2); });
    }

    busOrder.forEach(k => {
      busUI[k].fader.addEventListener("input", () => {
        syncVolReadouts();
        applyBusRouting();
      });

      busUI[k].mute.addEventListener("click", async (e) => {
        e.preventDefault(); await ensureRunning();
        busState[k].mute = !busState[k].mute;
        busUI[k].mute.classList.toggle("active", busState[k].mute);
        applyBusRouting();
      });
      busUI[k].solo.addEventListener("click", async (e) => {
        e.preventDefault(); await ensureRunning();
        busState[k].solo = !busState[k].solo;
        busUI[k].solo.classList.toggle("active", busState[k].solo);
        applyBusRouting();
      });

      bindKnob({
        knobEl: busUI[k].pan.knob, valEl: busUI[k].pan.val,
        min:-100, max:100, step:1, initial:0, dblClickReset:0,
        format:(v)=>String(v),
        onChange:(v)=>{ mix[k].panVal=v; applyMixerNodes(k); }
      });
      bindKnob({
        knobEl: busUI[k].lpf.knob, valEl: busUI[k].lpf.val,
        min:0, max:100, step:1, initial:100, dblClickReset:100,
        format:(v)=>String(v),
        onChange:(v)=>{ mix[k].lpfVal=v; applyMixerNodes(k); }
      });
      bindKnob({
        knobEl: busUI[k].snd.knob, valEl: busUI[k].snd.val,
        min:0, max:100, step:1, initial: mix[k].sendVal, dblClickReset:0,
        format:(v)=>String(v),
        onChange:(v)=>{ mix[k].sendVal=v; applyMixerNodes(k); }
      });

      applyMixerNodes(k);
    });

    bindKnob({
      knobEl: busUI.__fx.rvRet.knob, valEl: busUI.__fx.rvRet.val,
      min:0, max:100, step:1, initial:rvReturn, dblClickReset:20,
      format:(v)=>String(v),
      onChange:(v)=>setReverbReturn(v)
    });
    bindKnob({
      knobEl: busUI.__fx.rvSiz.knob, valEl: busUI.__fx.rvSiz.val,
      min:0, max:100, step:1, initial:rvSize, dblClickReset:45,
      format:(v)=>String(v),
      onChange:(v)=>setReverbSize(v)
    });

    syncVolReadouts();
    applyBusRouting();
  }

  // ---------- Instruments (preview + scheduling) ----------
  function midiToHz(midi){ return 440 * Math.pow(2, (midi - 69) / 12); }

  function playVoice(freq, time, dur, bus, wave, peak, cutoff, releaseOverride=null){
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();
    osc.type = wave;
    osc.frequency.setValueAtTime(freq, time);

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(peak, time + 0.01);

    const rel = releaseOverride ?? Math.max(0.02, Math.min(0.18, dur * 0.25));
    gain.gain.exponentialRampToValueAtTime(0.0001, time + dur + rel);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(cutoff, time);

    osc.connect(lp).connect(gain).connect(bus);
    osc.start(time);
    osc.stop(time + dur + rel + 0.03);
  }

  function playPad(freq, time, dur, bus, cutoff){
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();

    o1.type = "sawtooth";
    o2.type = "triangle";
    o1.frequency.setValueAtTime(freq, time);
    o2.frequency.setValueAtTime(freq, time);
    o2.detune.setValueAtTime(7, time);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(cutoff, time);
    lp.Q.value = 0.7;

    const attack = 0.06;
    const peak = 0.13;
    const release = Math.max(0.18, Math.min(0.75, dur * 0.35));

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(peak, time + attack);
    gain.gain.setValueAtTime(peak * 0.82, time + attack + 0.08);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + dur + release);

    o1.connect(lp); o2.connect(lp);
    lp.connect(gain).connect(bus);

    o1.start(time); o2.start(time);
    o1.stop(time + dur + release + 0.05);
    o2.stop(time + dur + release + 0.05);
  }

  function playEP(freq, time, dur, bus){
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    const tine = ctx.createOscillator();
    const g1 = ctx.createGain();
    const gT = ctx.createGain();
    const lp = ctx.createBiquadFilter();

    o1.type = "sine"; o2.type = "sine"; tine.type = "triangle";
    o1.frequency.setValueAtTime(freq, time);
    o2.frequency.setValueAtTime(freq * 2, time);
    tine.frequency.setValueAtTime(freq * 4.0, time);

    g1.gain.setValueAtTime(0.0001, time);
    g1.gain.exponentialRampToValueAtTime(0.22, time + 0.008);
    g1.gain.exponentialRampToValueAtTime(0.10, time + 0.09);
    g1.gain.setValueAtTime(0.10, time + Math.max(0.10, dur - 0.10));
    g1.gain.exponentialRampToValueAtTime(0.0001, time + dur + 0.22);

    gT.gain.setValueAtTime(0.0001, time);
    gT.gain.exponentialRampToValueAtTime(0.12, time + 0.004);
    gT.gain.exponentialRampToValueAtTime(0.0001, time + 0.05);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(5200, time);
    lp.Q.value = 0.6;

    o2.detune.setValueAtTime(6, time);
    o1.detune.setValueAtTime(-2, time);
    tine.detune.setValueAtTime(10, time);

    const sum = ctx.createGain();
    o1.connect(g1); o2.connect(g1); tine.connect(gT);
    g1.connect(sum); gT.connect(sum);
    sum.connect(lp).connect(bus);

    o1.start(time); o2.start(time); tine.start(time);
    o1.stop(time + dur + 0.30);
    o2.stop(time + dur + 0.30);
    tine.stop(time + 0.08);
  }

  function playBell(freq, time, dur, bus){
    const car = ctx.createOscillator();
    const mod = ctx.createOscillator();
    const modGain = ctx.createGain();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();

    car.type = "sine"; mod.type = "sine";
    car.frequency.setValueAtTime(freq, time);
    mod.frequency.setValueAtTime(freq * 2.01, time);
    modGain.gain.setValueAtTime(freq * 0.9, time);
    modGain.gain.exponentialRampToValueAtTime(freq * 0.15, time + Math.min(0.20, dur * 0.4));
    mod.connect(modGain);
    modGain.connect(car.frequency);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(9000, time);
    lp.Q.value = 0.4;

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.22, time + 0.006);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + dur + 0.22);

    car.connect(lp).connect(gain).connect(bus);
    mod.start(time); car.start(time);
    mod.stop(time + dur + 0.25); car.stop(time + dur + 0.25);
  }

  function playPoly(freq, time, dur, bus){
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();

    o1.type = "sawtooth";
    o2.type = "sawtooth";
    o1.frequency.setValueAtTime(freq, time);
    o2.frequency.setValueAtTime(freq, time);
    o2.detune.setValueAtTime(9, time);
    o1.detune.setValueAtTime(-7, time);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(5200, time);
    lp.Q.value = 0.7;

    const atk = 0.015;
    const rel = Math.max(0.10, Math.min(0.35, dur * 0.35));
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.16, time + atk);
    gain.gain.setValueAtTime(0.13, time + atk + 0.06);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + dur + rel);

    o1.connect(lp); o2.connect(lp);
    lp.connect(gain).connect(bus);
    o1.start(time); o2.start(time);
    o1.stop(time + dur + rel + 0.03);
    o2.stop(time + dur + rel + 0.03);
  }

  async function previewMidiNote(midi){
    await ensureRunning();
    const now = ctx.currentTime + 0.001;
    const hz = (inst) => midiToHz(midi + (transpose[inst]||0));
    if (activeRoll === "bass"){  playVoice(hz("bass"),  now, 0.14, buses.bass,  "triangle", 0.22, 1500, 0.25); return; }
    if (activeRoll === "synth"){ playVoice(hz("synth"), now, 0.12, buses.synth, "sawtooth", 0.18, 5200, 0.18); return; }
    if (activeRoll === "pad"){   playPad(hz("pad"),     now, 0.22, buses.pad, 5200); return; }
    if (activeRoll === "ep"){    playEP(hz("ep"),       now, 0.18, buses.ep); return; }
    if (activeRoll === "bell"){  playBell(hz("bell"),   now, 0.18, buses.bell); return; }
    if (activeRoll === "poly"){  playPoly(hz("poly"),   now, 0.18, buses.poly); return; }
    playVoice(hz("piano"), now, 0.12, buses.piano, "square", 0.18, 4200, 0.16);
  }

  // ---------- Drums (same as before) ----------
  let noiseBuf = null;
  function getNoiseBuffer(){
    if (noiseBuf) return noiseBuf;
    const len = ctx.sampleRate * 0.5;
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<len;i++) d[i] = Math.random()*2 - 1;
    noiseBuf = b;
    return b;
  }
  function playKick(time, outGain){
    const out = outGain || buses.drum;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(160, time);
    osc.frequency.exponentialRampToValueAtTime(50, time + 0.09);
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(1.0, time + 0.004);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.14);
    osc.connect(gain).connect(out);
    osc.start(time); osc.stop(time + 0.16);
  }
  function playSnare(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1800, time);
    bp.Q.setValueAtTime(0.8, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.9, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.10);
    src.connect(bp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.12);
  }
  function playClap(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(2200, time);
    bp.Q.setValueAtTime(0.7, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.55, time + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.07);
    src.connect(bp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.09);
  }
  function playShaker(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(6500, time);
    bp.Q.setValueAtTime(1.2, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.22, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.06);
    src.connect(bp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.08);
  }
  function playCH(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(7500, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.33, time + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.04);
    src.connect(hp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.06);
  }
  function playOH(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(6800, time);
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.28, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
    src.connect(hp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.22);
  }
  function playTom(time, outGain){
    const out = outGain || buses.drum;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();
    osc.type = "sine";
    osc.frequency.setValueAtTime(210, time);
    osc.frequency.exponentialRampToValueAtTime(110, time + 0.12);
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(1200, time);
    lp.Q.value = 0.7;
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.65, time + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.22);
    osc.connect(lp).connect(gain).connect(out);
    osc.start(time);
    osc.stop(time + 0.25);
  }
  function playRide(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(7000, time);
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(9800, time);
    bp.Q.value = 0.8;
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.22, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.35);
    src.connect(hp).connect(bp).connect(gain).connect(out);
    src.start(time);
    src.stop(time + 0.40);
  }
  function playCrash(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp1 = ctx.createBiquadFilter();
    bp1.type = "bandpass";
    bp1.frequency.setValueAtTime(6200, time);
    bp1.Q.value = 0.8;
    const bp2 = ctx.createBiquadFilter();
    bp2.type = "bandpass";
    bp2.frequency.setValueAtTime(9500, time);
    bp2.Q.value = 0.7;
    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.30, time + 0.004);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.85);
    const sum = ctx.createGain();
    src.connect(bp1).connect(sum);
    src.connect(bp2).connect(sum);
    sum.connect(gain).connect(out);
    src.start(time);
    src.stop(time + 0.90);
  }

  // ---------- Sequencer utilities ----------

  // ---------- Extra Drum Sounds + Dispatcher ----------
  function playDrumSound(key, time, out){
    switch(key){
      case "kick":      return playKick(time, out);
      case "kick808":   return play808Kick(time, out);
      case "snare":     return playSnare(time, out);
      case "snare808":  return play808Snare(time, out);
      case "clap":      return playClap(time, out);
      case "shaker":    return playShaker(time, out);
      case "ch":        return playCH(time, out);
      case "oh":        return playOH(time, out);
      case "tom":       return playTom(time, out);
      case "ride":      return playRide(time, out);
      case "crash":     return playCrash(time, out);

      case "rim":       return playRim(time, out);
      case "cowbell":   return playCowbell(time, out);

      case "click":     return playClick(time, out);
      case "blip":      return playBlip(time, out);
      case "zap":       return playZap(time, out);
      case "laser":     return playLaser(time, out);

      case "brushkick": return playBrushKick(time, out);
      case "brushsn":   return playBrushSnare(time, out);
      case "brushhat":  return playBrushHat(time, out);

      case "noise":     return playNoiseBurst(time, out);
      default:          return playClick(time, out);
    }
  }

  function play808Kick(time, outGain){
    const out = outGain || buses.drum;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "sine";

    // classic 808-ish drop
    osc.frequency.setValueAtTime(120, time);
    osc.frequency.exponentialRampToValueAtTime(42, time + 0.18);

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.9, time + 0.006);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.85);

    // subtle drive via waveshaper
    const shaper = ctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i=0;i<curve.length;i++){
      const x = (i/(curve.length-1))*2 - 1;
      curve[i] = Math.tanh(2.1*x);
    }
    shaper.curve = curve;

    osc.connect(gain);
    gain.connect(shaper);
    shaper.connect(out);

    osc.start(time);
    osc.stop(time + 0.9);
  }

  function play808Snare(time, outGain){
    const out = outGain || buses.drum;

    // noise body
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1800, time);
    bp.Q.value = 0.9;

    const nGain = ctx.createGain();
    nGain.gain.setValueAtTime(0.0001, time);
    nGain.gain.exponentialRampToValueAtTime(0.7, time + 0.004);
    nGain.gain.exponentialRampToValueAtTime(0.0001, time + 0.22);

    // tone
    const osc = ctx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(330, time);
    const tGain = ctx.createGain();
    tGain.gain.setValueAtTime(0.0001, time);
    tGain.gain.exponentialRampToValueAtTime(0.35, time + 0.004);
    tGain.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);

    src.connect(bp);
    bp.connect(nGain);
    nGain.connect(out);

    osc.connect(tGain);
    tGain.connect(out);

    src.start(time);
    src.stop(time + 0.3);
    osc.start(time);
    osc.stop(time + 0.25);
  }

  function playRim(time, outGain){
    const out = outGain || buses.drum;

    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(1800, time);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.55, time + 0.0015);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.06);

    // little click tone
    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.setValueAtTime(950, time);
    const tg = ctx.createGain();
    tg.gain.setValueAtTime(0.0001, time);
    tg.gain.exponentialRampToValueAtTime(0.25, time + 0.001);
    tg.gain.exponentialRampToValueAtTime(0.0001, time + 0.04);

    src.connect(hp); hp.connect(g); g.connect(out);
    osc.connect(tg); tg.connect(out);

    src.start(time); src.stop(time+0.08);
    osc.start(time); osc.stop(time+0.06);
  }

  function playCowbell(time, outGain){
    const out = outGain || buses.drum;

    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    o1.type = "square"; o2.type = "square";
    o1.frequency.setValueAtTime(540, time);
    o2.frequency.setValueAtTime(800, time);

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1200, time);
    bp.Q.value = 0.7;

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.55, time + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);

    o1.connect(bp); o2.connect(bp);
    bp.connect(g); g.connect(out);

    o1.start(time); o2.start(time);
    o1.stop(time+0.2); o2.stop(time+0.2);
  }

  function playClick(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(6000, time);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.35, time + 0.001);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.02);
    src.connect(hp); hp.connect(g); g.connect(out);
    src.start(time); src.stop(time+0.03);
  }

  function playBlip(time, outGain){
    const out = outGain || buses.drum;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = "square";
    osc.frequency.setValueAtTime(920, time);
    osc.frequency.exponentialRampToValueAtTime(520, time + 0.05);
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.35, time + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.08);
    osc.connect(g); g.connect(out);
    osc.start(time); osc.stop(time+0.1);
  }

  function playZap(time, outGain){
    const out = outGain || buses.drum;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(8000, time);
    lp.frequency.exponentialRampToValueAtTime(1200, time + 0.14);

    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(1600, time);
    osc.frequency.exponentialRampToValueAtTime(180, time + 0.14);

    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.55, time + 0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);

    osc.connect(lp); lp.connect(g); g.connect(out);
    osc.start(time); osc.stop(time+0.2);
  }

  function playLaser(time, outGain){
    const out = outGain || buses.drum;
    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(220, time);
    osc.frequency.exponentialRampToValueAtTime(2200, time + 0.12);
    osc.frequency.exponentialRampToValueAtTime(420, time + 0.24);

    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.5, time + 0.004);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.28);

    osc.connect(g); g.connect(out);
    osc.start(time); osc.stop(time+0.3);
  }

  function playBrushKick(time, outGain){
    const out = outGain || buses.drum;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(1200, time);
    osc.type = "sine";
    osc.frequency.setValueAtTime(110, time);
    osc.frequency.exponentialRampToValueAtTime(65, time + 0.16);

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.5, time + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.55);

    osc.connect(lp); lp.connect(gain); gain.connect(out);
    osc.start(time); osc.stop(time+0.6);
  }

  function playBrushSnare(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(3200, time);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.42, time + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.32);
    src.connect(lp); lp.connect(g); g.connect(out);
    src.start(time); src.stop(time+0.4);
  }

  function playBrushHat(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(7000, time);
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.28, time + 0.003);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.12);
    src.connect(hp); hp.connect(g); g.connect(out);
    src.start(time); src.stop(time+0.15);
  }

  function playNoiseBurst(time, outGain){
    const out = outGain || buses.drum;
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(2400, time);
    bp.Q.value = 0.9;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, time);
    g.gain.exponentialRampToValueAtTime(0.35, time + 0.002);
    g.gain.exponentialRampToValueAtTime(0.0001, time + 0.08);
    src.connect(bp); bp.connect(g); g.connect(out);
    src.start(time); src.stop(time+0.1);
  }


  function rangesOverlap(aStart, aLen, bStart, bLen){
    const aEnd = aStart + aLen;
    const bEnd = bStart + bLen;
    return aStart < bEnd && bStart < aEnd;
  }
  function clearInstrumentGrid(grid){
    for (let p=0; p<ROLL_PITCHES; p++) grid[p].fill(0);
  }
  function getGridByLane(laneKey){ return project[laneKey]; }
  function getActiveGrid(){ return getGridByLane(activeRoll); }
  function noteColor(){
    const lane = LANES.find(l => l.key === activeRoll) || LANES[0];
    return cssVar(lane.noteVar);
  }

  // ---------- Drum grid UI (same behavior) ----------
  function knobStyleForValue(v){
    const pct = clamp(v, 0, 100) / 100;
    const deg = pct * 270;
    const rot = (-135 + pct * 270);
    return { fillDeg: `${deg}deg`, rotDeg: `${rot}deg` };
  }
  
  // (legacy) row-knob helpers were previously keyed by drum name.
  // Drums are now dynamic rows with per-row knobs built in buildDrumGrid().
  function setRowKnobValue(){ /* no-op */ }
  function attachRowKnob(){ /* no-op */ }


  function addDrumRow(soundKey){
    if (project.drumRows.length >= MAX_DRUM_ROWS) return;
    const defVolBySound = {
      kick:100, kick808:92, clap:85, snare:92, ch:62, oh:70, ride:66, crash:70,
      snare808:88, rim:70, cowbell:72, shaker:65, tom:78,
      click:55, blip:60, zap:65, laser:70, brushkick:80, brushsn:78, brushhat:62, noise:58
    };
    const labelFor = (key) => (DRUM_SOUNDS.find(d => d.key === key)?.label) || key;

    const row = {
      id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random())),
      soundKey,
      label: labelFor(soundKey),
      steps: new Array(MASTER_STEPS).fill(false),
      vol: (defVolBySound[soundKey] ?? 80)
    };
    project.drumRows.push(row);
    ensureDrumRowGains();
    buildDrumGrid();
    refreshDrumUI();
    saveToLocal();
  }

  function removeDrumRow(index){
    if (project.drumRows.length <= 1) return;
    project.drumRows.splice(index, 1);
    ensureDrumRowGains(true);
    buildDrumGrid();
    refreshDrumUI();
    saveToLocal();
  }

  function buildDrumGrid(){
    drumGridEl.innerHTML = "";

    const ROW_H = 44;
    const CELL_W = 35; // drum step cell width (px)
    drumGridEl.style.setProperty("--drumRows", String(project.drumRows.length || 8));
    drumGridEl.style.setProperty("--drumRowH", ROW_H + "px");
    drumGridEl.style.setProperty("--drumControlsW", "320px");
    drumGridEl.style.setProperty("--cellW", CELL_W + "px");
    drumGridEl.style.setProperty("--cellH", ROW_H + "px");

    const namesCol = document.createElement("div");
    namesCol.className = "trackNames";

    const stepsWrap = document.createElement("div");
    stepsWrap.className = "stepsWrap";

    const stepsCol = document.createElement("div");
    stepsCol.className = "steps";
    stepsCol.style.gridAutoRows = ROW_H + "px";

    project.drumRows.forEach((row, idx) => {
      // --- name / controls column (fixed width, no overlap) ---
      const nameRow = document.createElement("div");
      nameRow.className = "trackName";

      const del = document.createElement("button");
      del.className = "rowDel";
      del.title = "Delete row";
      del.textContent = "×";
      del.addEventListener("click", () => removeDrumRow(idx));

      const selectWrap = document.createElement("div");
      selectWrap.className = "trackSelectWrap";

      const select = document.createElement("select");
      select.className = "trackSelect";
      DRUM_SOUNDS.forEach(s => {
        const opt = document.createElement("option");
        opt.value = s.key;
        opt.textContent = s.name;
        select.appendChild(opt);
      });
      select.value = row.soundKey || "kick";
      select.addEventListener("change", () => {
        row.soundKey = select.value;
        refreshDrumUI();
        saveToLocal();
      });
      selectWrap.appendChild(select);

      const knob = document.createElement("div");
      knob.className = "knob";
      knob.dataset.row = String(idx);

      const knobVal = document.createElement("div");
      knobVal.className = "knobVal";
      knob.appendChild(knobVal);

      // knob interaction (volume)
      let dragging = false, startY=0, startVal=0;
      const setVol = (v) => {
        row.vol = Math.max(0, Math.min(120, v));
        knob.style.setProperty("--knob", (row.vol/120).toFixed(3));
        knobVal.textContent = `${row.vol|0}%`;
        if (drumRowGains[idx]) drumRowGains[idx].gain.value = (row.vol/100);
      };
      setVol(row.vol);

      knob.addEventListener("pointerdown", (e) => {
        dragging = true; startY = e.clientY; startVal = row.vol;
        knob.setPointerCapture(e.pointerId);
      });
      knob.addEventListener("pointermove", (e) => {
        if (!dragging) return;
        const dy = startY - e.clientY;
        setVol(startVal + dy * 0.25);
      });
      knob.addEventListener("pointerup", () => dragging = false);
      knob.addEventListener("pointercancel", () => dragging = false);
      knob.addEventListener("dblclick", () => { setVol(80); saveToLocal(); });

      nameRow.appendChild(del);
      nameRow.appendChild(selectWrap);
      nameRow.appendChild(knob);

      namesCol.appendChild(nameRow);

      // --- steps row ---
      const rowSteps = document.createElement("div");
      rowSteps.className = "rowSteps";
      rowSteps.dataset.row = String(idx);
      // square cells: width matches row height
      rowSteps.style.gridTemplateColumns = `repeat(${LOOP_STEPS}, ${CELL_W}px)`;
      rowSteps.style.gridAutoRows = `${ROW_H}px`;

      for (let s=0; s<LOOP_STEPS; s++){
        const cell = document.createElement("div");
        cell.className = "cell group" + ((s%8<4) ? "A" : "B");
        cell.dataset.row = String(idx);
        cell.dataset.step = String(s);
        rowSteps.appendChild(cell);
      }

      stepsCol.appendChild(rowSteps);
    });

    stepsWrap.appendChild(stepsCol);
    drumGridEl.appendChild(namesCol);
    drumGridEl.appendChild(stepsWrap);
  }


  

    function refreshDrumUI(){
    const rows = drumGridEl.querySelectorAll(".rowSteps");
    rows.forEach((rowEl, rIdx) => {
      const row = project.drumRows[rIdx];
      if (!row) return;
      const color = theme.drums[row.soundKey] || "#58a6ff";
      for (let s=0; s<LOOP_STEPS; s++){
        const cell = rowEl.children[s];
        if (!cell) continue;
        const on = !!row.steps[s];
        cell.classList.toggle("on", on);
        if (on) {
          cell.style.background = color;
          cell.style.borderColor = color;
          cell.style.boxShadow = "0 0 0 1px rgba(0,0,0,.0), 0 10px 26px rgba(0,0,0,.20)";
        } else {
          cell.style.background = "";
          cell.style.borderColor = "";
          cell.style.boxShadow = "";
        }
      }
    });
  }

  function updatePlayheadUI(step){
    drumGridEl.querySelectorAll(".cell").forEach(c => c.classList.remove("playhead"));
    if (step < 0) return;
    const rows = drumGridEl.querySelectorAll(".rowSteps");
    rows.forEach((rowEl) => {
      const cell = rowEl.children[step];
      if (cell) cell.classList.add("playhead");
    });
  }

  let drumPaint = { active:false, pointerId:null, value:true, visited:new Set(), row:null };

  function cellFromPoint(clientX, clientY){
    const el = document.elementFromPoint(clientX, clientY);
    if (!el) return null;
    return el.classList && el.classList.contains("cell") ? el : null;
  }
  function clearDragHover(){
    drumGridEl.querySelectorAll(".cell.drag-hover").forEach(c => c.classList.remove("drag-hover"));
  }
  function applyDrumCell(cell, value){
    const rowIdx = Number(cell.dataset.row);
    if (Number.isNaN(rowIdx)) return;
    if (drumPaint.row !== null && rowIdx !== drumPaint.row) return;

    const step = Number(cell.dataset.step);
    const id = `${rowIdx}:${step}`;
    if (drumPaint.visited.has(id)) return;
    drumPaint.visited.add(id);

    const row = project.drumRows[rowIdx];
    if (!row) return;
    row.steps[step] = value;

    const color = theme.drums[row.soundKey] || "#58a6ff";
    cell.classList.toggle("on", value);
    if (value){
      cell.style.background = color;
      cell.style.borderColor = color;
      cell.style.boxShadow = "0 0 0 1px rgba(0,0,0,.0), 0 10px 26px rgba(0,0,0,.20)";
    } else {
      cell.style.background = "";
      cell.style.borderColor = "";
      cell.style.boxShadow = "";
    }
    cell.classList.add("drag-hover");
  }

  function enableDrumPainting(container){
    container.addEventListener("pointerdown", (e) => {
      const cell = e.target.closest(".cell");
      if (!cell) return;
      e.preventDefault();

      drumPaint.active = true;
      drumPaint.pointerId = e.pointerId;
      drumPaint.visited.clear();
      drumPaint.row = Number(cell.dataset.row);
      const row = project.drumRows[drumPaint.row];
      if (!row) return;

      const step = Number(cell.dataset.step);
      drumPaint.value = !row.steps[step];
      applyDrumCell(cell, drumPaint.value);

      container.setPointerCapture(e.pointerId);
    });

    container.addEventListener("pointermove", (e) => {
      if (!drumPaint.active || e.pointerId !== drumPaint.pointerId) return;
      const cell = document.elementFromPoint(e.clientX, e.clientY)?.closest?.(".cell");
      if (!cell) return;
      applyDrumCell(cell, drumPaint.value);
    });

    container.addEventListener("pointerup", (e) => {
      if (e.pointerId !== drumPaint.pointerId) return;
      drumPaint.active = false;
      drumPaint.pointerId = null;
      drumPaint.row = null;
      drumPaint.visited.clear();
      container.releasePointerCapture(e.pointerId);
      saveToLocal();
    });

    container.addEventListener("lostpointercapture", () => {
      drumPaint.active = false;
      drumPaint.pointerId = null;
      drumPaint.row = null;
      drumPaint.visited.clear();
    });
  }

  enableDrumPainting(drumGridEl);

  const addDrumRowBtn = document.getElementById("addDrumRowBtn");
  function openAddDrumRowMenu(anchorEl){
    if (!anchorEl) return;
    if (project.drumRows.length >= MAX_DRUM_ROWS){
      flashMessage(`Max ${MAX_DRUM_ROWS} drum rows reached`, 1200);
      return;
    }

    // Remove existing menu if any
    document.getElementById("addDrumRowMenu")?.remove();

    const menu = document.createElement("div");
    menu.id = "addDrumRowMenu";
    menu.className = "card";
    menu.style.position = "fixed";
    menu.style.zIndex = "999999";
    menu.style.padding = "10px";
    menu.style.borderRadius = "14px";
    menu.style.width = "220px";
    menu.style.backdropFilter = "blur(14px)";
    menu.style.boxShadow = "0 16px 60px rgba(0,0,0,.45)";
    menu.style.pointerEvents = "auto";

    const title = document.createElement("div");
    title.className = "small";
    title.style.marginBottom = "8px";
    title.textContent = "Add drum sound";
    menu.appendChild(title);

    const sel = document.createElement("select");
    sel.className = "input";
    sel.style.width = "100%";
    sel.style.borderRadius = "999px";
    sel.style.padding = "10px 12px";
    DRUM_SOUNDS.forEach(d => {
      const opt = document.createElement("option");
      opt.value = d.key;
      opt.textContent = d.label;
      sel.appendChild(opt);
    });
    menu.appendChild(sel);

    const btnRow = document.createElement("div");
    btnRow.style.display = "flex";
    btnRow.style.justifyContent = "flex-end";
    btnRow.style.gap = "8px";
    btnRow.style.marginTop = "10px";

    const cancel = document.createElement("button");
    cancel.className = "miniBtn";
    cancel.textContent = "Cancel";
    cancel.addEventListener("click", () => menu.remove());

    const add = document.createElement("button");
    add.className = "miniBtn primary";
    add.textContent = "Add";
    add.addEventListener("click", () => { addDrumRow(sel.value); menu.remove(); });

    btnRow.appendChild(cancel);
    btnRow.appendChild(add);
    menu.appendChild(btnRow);

    document.body.appendChild(menu);

    const r = anchorEl.getBoundingClientRect();
    const x = Math.min(window.innerWidth - 240, Math.max(12, r.left));
    const y = Math.min(window.innerHeight - 200, Math.max(12, r.bottom + 8));
    menu.style.left = x + "px";
    menu.style.top  = y + "px";

    const onDoc = (ev) => {
      if (!menu.contains(ev.target) && ev.target !== anchorEl){
        menu.remove();
        document.removeEventListener("pointerdown", onDoc, true);
      }
    };
    document.addEventListener("pointerdown", onDoc, true);
  }

  addDrumRowBtn?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    openAddDrumRowMenu(addDrumRowBtn);
  });



  function isBlackKey(midi){
    const pc = midi % 12;
    return pc === 1 || pc === 3 || pc === 6 || pc === 8 || pc === 10;
  }
  function midiNameFlat(m){
    const pc = m % 12;
    const oct = Math.floor(m/12) - 1;
    const names = { 0:"C", 1:"Db", 2:"D", 3:"Eb", 4:"E", 5:"F", 6:"Gb", 7:"G", 8:"Ab", 9:"A", 10:"Bb", 11:"B" };
    return `${names[pc]}${oct}`;
  }

  function drawRoll(playheadStep = -1){
    const W = rollCanvas.width;
    const H = rollCanvas.height;
    const grid = getActiveGrid();

    const leftPad = KEY_PAD;
    const cellW = (W - leftPad) / LOOP_STEPS;
    const cellH = H / ROLL_PITCHES;

    g.clearRect(0,0,W,H);
    g.fillStyle = cssVar("--rollBg");
    g.fillRect(0,0,W,H);

    for (let p=0; p<ROLL_PITCHES; p++){
      const midi = ROLL_BASE_MIDI + p;
      const y = H - (p+1)*cellH;
      g.fillStyle = isBlackKey(midi) ? cssVar("--rowBlack") : ((p % 2 === 0) ? cssVar("--rowWhiteA") : cssVar("--rowWhiteB"));
      g.fillRect(leftPad, y, W-leftPad, cellH);
    }

    for (let s=0; s<=LOOP_STEPS; s++){
      const x = leftPad + s*cellW;
      g.strokeStyle = (s % 4 === 0) ? cssVar("--gridBeat") : cssVar("--gridLine");
      g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke();
    }
    for (let p=0; p<=ROLL_PITCHES; p++){
      const y = p*cellH;
      g.strokeStyle = cssVar("--gridLine");
      g.beginPath(); g.moveTo(leftPad,y); g.lineTo(W,y); g.stroke();
    }

    g.fillStyle = cssVar("--rollStrip");
    g.fillRect(0,0,leftPad,H);

    for (let p=0; p<ROLL_PITCHES; p++){
      const midi = ROLL_BASE_MIDI + p;
      const y = H - (p+1)*cellH;
      const black = isBlackKey(midi);

      if (!black){
        const grad = g.createLinearGradient(0,y,0,y+cellH);
        grad.addColorStop(0, cssVar("--whiteKeyA"));
        grad.addColorStop(1, cssVar("--whiteKeyB"));
        g.fillStyle = grad;
        g.fillRect(6, y+1, leftPad-12, cellH-2);
        g.strokeStyle = cssVar("--keyBorder");
        g.strokeRect(6.5, y+1.5, leftPad-13, cellH-3);

        g.fillStyle = "rgba(0,0,0,0.80)";
        g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
        g.fillText(midiNameFlat(midi), 12, y + cellH*0.68);
      } else {
        const grad = g.createLinearGradient(0,y,0,y+cellH);
        grad.addColorStop(0, cssVar("--blackKeyB"));
        grad.addColorStop(1, cssVar("--blackKeyA"));

        const insetLeft = 22;
        const insetRight = 20;
        g.fillStyle = grad;
        g.fillRect(insetLeft, y+2, leftPad - insetLeft - insetRight, cellH-4);
        g.strokeStyle = "rgba(255,255,255,.10)";
        g.strokeRect(insetLeft+0.5, y+2.5, leftPad - insetLeft - insetRight - 1, cellH-5);

        g.fillStyle = "rgba(255,255,255,0.80)";
        g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
        g.fillText(midiNameFlat(midi), insetLeft+6, y + cellH*0.68);
      }
    }

    for (let p=0; p<ROLL_PITCHES; p++){
      for (let s=0; s<LOOP_STEPS; s++){
        const len = grid[p][s];
        if (len <= 0) continue;

        const x = leftPad + s*cellW + 1;
        const y = H - (p+1)*cellH + 1;
        const clampedLen = Math.min(len, LOOP_STEPS - s);
        const w = (cellW * clampedLen) - 2;
        const h = cellH - 2;

        g.fillStyle = noteColor();
        g.fillRect(x,y,w,h);

        g.strokeStyle = "rgba(255,255,255,.18)";
        g.strokeRect(x+0.5,y+0.5,w-1,h-1);
      }
    }

    if (playheadStep >= 0){
      const x = leftPad + playheadStep*cellW;
      g.fillStyle = "rgba(255,255,255,.12)";
      g.fillRect(x,0,cellW,H);
    }
  }

  function rollHitTest(clientX, clientY){
    const rect = rollCanvas.getBoundingClientRect();
    const px = (clientX - rect.left) * (rollCanvas.width / rect.width);
    const py = (clientY - rect.top)  * (rollCanvas.height / rect.height);

    const W = rollCanvas.width;
    const H = rollCanvas.height;

    const leftPad = KEY_PAD;
    const cellW = (W - leftPad) / LOOP_STEPS;
    const cellH = H / ROLL_PITCHES;

    const pitch = Math.floor((H - py) / cellH);
    if (pitch < 0 || pitch >= ROLL_PITCHES) return null;

    if (px < leftPad) return { area:"keys", pitch };

    const step = Math.floor((px - leftPad) / cellW);
    if (step < 0 || step >= LOOP_STEPS) return null;

    return { area:"grid", pitch, step };
  }

  function findCoveringNote(row, step){
    for (let s=0; s<MASTER_STEPS; s++){
      const len = row[s];
      if (len <= 0) continue;
      if (step >= s && step < s + len) return {start:s, len};
    }
    return null;
  }

  function setNoteLenOnGrid(grid, pitch, start, len){
    const row = grid[pitch];
    len = Math.max(1, Math.min(len, MASTER_STEPS - start));
    for (let i=0; i<MASTER_STEPS; i++){
      const l = row[i];
      if (l <= 0) continue;
      if (rangesOverlap(i, l, start, len)) row[i] = 0;
    }
    row[start] = len;
  }

  let noteDrag = {active:false, pointerId:null, grid:null, pitch:0, start:0};

  rollCanvas.addEventListener("pointerdown", async (e) => {
    e.preventDefault();
    const hit = rollHitTest(e.clientX, e.clientY);
    if (!hit) return;

    const midi = ROLL_BASE_MIDI + hit.pitch;
    const grid = getActiveGrid();

    if (hit.area === "keys"){
      await previewMidiNote(midi);
      return;
    }

    const row = grid[hit.pitch];
    const existing = findCoveringNote(row, hit.step);
    if (existing){
      row[existing.start] = 0;
      drawRoll(isPlaying ? currentStep : -1);
      return;
    }

    await previewMidiNote(midi);

    setNoteLenOnGrid(grid, hit.pitch, hit.step, 1);
    noteDrag = {active:true, pointerId:e.pointerId, grid, pitch:hit.pitch, start:hit.step};
    rollCanvas.setPointerCapture(e.pointerId);
    drawRoll(isPlaying ? currentStep : -1);
  }, {passive:false});

  rollCanvas.addEventListener("pointermove", (e) => {
    if (!noteDrag.active) return;
    if (noteDrag.pointerId !== e.pointerId) return;
    e.preventDefault();
    const hit = rollHitTest(e.clientX, e.clientY);
    if (!hit || hit.area !== "grid") return;
    const len = Math.max(1, (hit.step - noteDrag.start) + 1);
    setNoteLenOnGrid(noteDrag.grid, noteDrag.pitch, noteDrag.start, len);
    drawRoll(isPlaying ? currentStep : -1);
  }, {passive:false});

  const endNoteDrag = (e) => {
    if (!noteDrag.active) return;
    if (noteDrag.pointerId !== e.pointerId) return;
    noteDrag.active = false;
    noteDrag.pointerId = null;
  };
  rollCanvas.addEventListener("pointerup", endNoteDrag);
  rollCanvas.addEventListener("pointercancel", endNoteDrag);
  rollCanvas.addEventListener("lostpointercapture", () => {
    noteDrag.active = false;
    noteDrag.pointerId = null;
  });

  // ---------- ABSOLUTE BPM LOOPING (unchanged) ----------
  function secondsPerStep(){
    const quarter = 60 / bpm;
    return quarter / 4; // base = 1/16 step
  }

  function scheduleStep(step, time){
    // Drums (dynamic rows)
    for (let r=0; r<project.drumRows.length; r++){
      const row = project.drumRows[r];
      if (!row || !row.steps[step]) continue;
      const out = drumRowGains[r] || buses.drum;
      playDrumSound(row.soundKey, time, out);
    }

    const sp = secondsPerStep();

    for (const lane of LANES){
      const grid = project[lane.key];
      for (let p=0; p<ROLL_PITCHES; p++){
        const len = grid[p][step];
        if (len <= 0) continue;
        const hz = midiToHz((ROLL_BASE_MIDI + p) + (transpose[lane.key]||0));
        const dur = sp * len;

        switch(lane.key){
          case "piano": playVoice(hz, time, dur, buses.piano, "square", 0.18, 4200, 0.14); break;
          case "ep":    playEP(hz, time, dur, buses.ep); break;
          case "poly":  playPoly(hz, time, dur, buses.poly); break;
          case "bell":  playBell(hz, time, dur, buses.bell); break;
          case "synth": playVoice(hz, time, dur, buses.synth, "sawtooth", 0.15, 6000, 0.18); break;
          case "bass":  playVoice(hz, time, dur, buses.bass, "triangle", 0.24, 1500, 0.35); break;
          case "pad":   playPad(hz, time, dur, buses.pad, 7200); break;
        }
      }
    }

    updatePlayheadUI(step);
    drawRoll(step);
  }

  function nextStep(){
    currentStep = (currentStep + 1) % LOOP_STEPS;
    nextNoteTime += secondsPerStep();
  }

  function tick(){
    while (nextNoteTime < ctx.currentTime + scheduleAhead){
      scheduleStep(currentStep, nextNoteTime);
      nextStep();
    }
    timerId = window.setTimeout(tick, lookAhead * 1000);
  }

  async function startFromCurrentStep(){
    await ensureRunning();
    ensureDrumRowGains();

    isPlaying = true;
    isPaused = false;

    playBtn.disabled = true;
    pauseBtn.disabled = false;
    stopBtn.disabled = false;

    nextNoteTime = ctx.currentTime + 0.06;
    tick();
  }

  function pause(){
    isPaused = true;
    isPlaying = false;

    playBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = false;

    if (timerId) { clearTimeout(timerId); timerId = null; }
  }

  function stopTransportOnly(){
    isPlaying = false;
    isPaused = false;
    if (timerId) { clearTimeout(timerId); timerId = null; }
    currentStep = 0;
    updatePlayheadUI(-1);
    drawRoll(-1);
    playBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
  }

  function togglePlayPause(){
    if (!ctx && !isPlaying && !isPaused){ startFromCurrentStep(); return; }
    if (isPlaying) pause();
    else startFromCurrentStep();
  }

  playBtn.addEventListener("click", () => { currentStep = 0; startFromCurrentStep(); });
  pauseBtn.addEventListener("click", pause);
  stopBtn.addEventListener("click", stopTransportOnly);

  function applyLoopSize(newLoopSteps, label){
    stopTransportOnly();
    LOOP_STEPS = newLoopSteps;

    // derive currentResIndex from steps
    const idx = RES_OPTIONS.findIndex(o => o.steps === newLoopSteps);
    currentResIndex = (idx >= 0 ? idx : currentResIndex);

    if (resText) resText.textContent = label;

    // keep both dropdowns in sync
    if (loopSelectDrum) loopSelectDrum.value = String(currentResIndex);
    if (loopSelectRoll) loopSelectRoll.value = String(currentResIndex);

    buildDrumGrid();
    drawRoll(-1);
  }

  // ---------- MIDI IMPORT (file picker) -> active lane ----------
  importMidiBtn.addEventListener("click", () => midiFileInput.click());
  midiFileInput.addEventListener("change", async () => {
    const file = midiFileInput.files && midiFileInput.files[0];
    if (!file) return;
    const arr = await file.arrayBuffer();
    importMidiArrayBufferToActiveLane(arr, { fit: true });
    midiFileInput.value = "";
  });

  // ---------- MIDI LIBRARY ----------
  let midiIndex = null;
  let activePackIdx = 0;
  let previewStopper = { stop:false };

  let pendingLaneSuggestion = null;

  function setLaneSuggestionUI(s){
    // s: { laneKey, confidence, reason } or null
    pendingLaneSuggestion = null;
    if (!laneSuggestPill || !laneSuggestText) return;

    if (!s || !s.laneKey || s.laneKey === activeRoll){
      laneSuggestPill.style.display = "none";
      return;
    }

    pendingLaneSuggestion = s.laneKey;
    laneSuggestText.textContent = `${laneLabel(s.laneKey)} • ${Math.round((s.confidence||0)*100)}%`;
    laneSuggestPill.style.display = "flex";
  }

  applyLaneSuggestionBtn?.addEventListener("click", () => {
    if (!pendingLaneSuggestion) return;
    const tab = document.querySelector(`.tab[data-roll="${pendingLaneSuggestion}"]`);
    if (tab) tab.click();
    setLaneSuggestionUI(null);
  });


  function showMidiModal(){
    targetLaneBadge.textContent = `Target: ${LANES.find(l=>l.key===activeRoll)?.label ?? "Piano"}`;
    midiModalOverlay.classList.add("show");
    midiModalOverlay.setAttribute("aria-hidden","false");
    midiSearch.value = "";
    midiFileStatus.textContent = "";
    loadMidiIndex();
  }
  function hideMidiModal(){
    midiModalOverlay.classList.remove("show");
    midiModalOverlay.setAttribute("aria-hidden","true");
    stopPreview();
  }

  function stopPreview(){
    previewStopper.stop = true;
    previewStopper = { stop:false };
  }

  midiLibraryBtn.addEventListener("click", showMidiModal);
  closeMidiModal.addEventListener("click", hideMidiModal);
  midiModalOverlay.addEventListener("click", (e) => {
    if (e.target === midiModalOverlay) hideMidiModal();
  });
  refreshMidiIndex.addEventListener("click", () => loadMidiIndex(true));
  window.addEventListener("keydown", (e) => {
    if (!midiModalOverlay.classList.contains("show")) return;
    if (e.key === "Escape") hideMidiModal();
  });

  midiSearch.addEventListener("input", () => renderMidiLibrary());
  fitToLoop.addEventListener("change", () => { /* preference only */ });

  async function loadMidiIndex(force=false){
    midiIndexStatus.textContent = "Loading MIDI index…";
    fileListEl.innerHTML = "";
    packListEl.innerHTML = "";
    try{
      const url = new URL(MIDI_INDEX_PATH, window.location.href).toString();
      const res = await fetch(url, { cache: force ? "no-store" : "default" });
      if (!res.ok) throw new Error(`Failed to load ${MIDI_INDEX_PATH} (${res.status})`);
      midiIndex = await res.json();
      activePackIdx = 0;
      midiIndexStatus.textContent = `Loaded ${midiIndex?.packs?.length ?? 0} packs from /midi`;
      renderMidiLibrary();
    }catch(err){
      console.warn(err);
      midiIndexStatus.textContent =
        `Couldn’t load ${MIDI_INDEX_PATH}. Make sure it exists and is committed to GitHub.\n` +
        `Tip: GitHub Pages won’t allow directory listing without an index.json.`;
    }
  }

  function renderMidiLibrary(){
    const q = (midiSearch.value || "").trim().toLowerCase();
    const packs = Array.isArray(midiIndex?.packs) ? midiIndex.packs : [];

    // filter packs by query (pack or file match)
    const filtered = packs.map((p, idx) => {
      const files = Array.isArray(p.files) ? p.files : [];
      const packMatch = (p.name || "").toLowerCase().includes(q);
      const fileMatch = files.some(f => (f.name||f.file||"").toLowerCase().includes(q));
      const keep = !q || packMatch || fileMatch;
      return { pack:p, idx, keep };
    }).filter(x => x.keep);

    packListEl.innerHTML = "";
    if (!filtered.length){
      packListEl.innerHTML = `<div class="status">No packs match “${q}”.</div>`;
      fileListEl.innerHTML = "";
      return;
    }

    // keep activePackIdx meaningful within filtered list
    const foundActive = filtered.find(x => x.idx === activePackIdx);
    if (!foundActive) activePackIdx = filtered[0].idx;

    filtered.forEach(({pack, idx}) => {
      const el = document.createElement("div");
      el.className = "pack" + (idx === activePackIdx ? " active" : "");
      el.innerHTML = `
        <div class="packName">${escapeHtml(pack.name || `Pack ${idx+1}`)}</div>
        <div class="packMeta">${(pack.files?.length ?? 0)} files • /midi/${escapeHtml(pack.path || "")}</div>
      `;
      el.addEventListener("click", () => {
        activePackIdx = idx;
        renderMidiLibrary();
      });
      packListEl.appendChild(el);
    });

    const pack = packs[activePackIdx] || filtered[0].pack;
    renderFileList(pack, q);
  }

  function renderFileList(pack, q){
    fileListEl.innerHTML = "";
    const files = Array.isArray(pack?.files) ? pack.files : [];
    const filteredFiles = files.filter(f => {
      if (!q) return true;
      return ((f.name || f.file || "").toLowerCase().includes(q)) || ((pack.name||"").toLowerCase().includes(q));
    });

    if (!filteredFiles.length){
      fileListEl.innerHTML = `<div class="status">No files match “${q}” in this pack.</div>`;
      return;
    }

    filteredFiles.forEach((f) => {
      const row = document.createElement("div");
      row.className = "fileRow";

      const left = document.createElement("div");
      left.style.minWidth = "0";
      left.innerHTML = `<div class="fileName">${escapeHtml(f.name || f.file)}</div>`;

      const btns = document.createElement("div");
      btns.className = "fileBtns";

      const previewBtn = document.createElement("button");
      previewBtn.className = "miniBtn";
      previewBtn.textContent = "Preview";

      const importBtn = document.createElement("button");
      importBtn.className = "miniBtn primary";
      importBtn.textContent = `Import → ${LANES.find(l=>l.key===activeRoll)?.label ?? "Piano"}`;

      previewBtn.addEventListener("click", async () => {
        await previewMidiFromLibrary(pack, f);
      });

      importBtn.addEventListener("click", async () => {
        await importMidiFromLibrary(pack, f);
      });

      btns.appendChild(previewBtn);
      btns.appendChild(importBtn);

      row.appendChild(left);
      row.appendChild(btns);
      fileListEl.appendChild(row);
    });

    midiFileStatus.textContent =
      `Tip: Preview plays the MIDI using the currently selected instrument sound (${LANES.find(l=>l.key===activeRoll)?.label ?? "Piano"}). Import writes notes into that lane’s piano roll.`;
  }

  
  // ---------- Auto-detect lane suggestion (lightweight heuristics) ----------
  // Goal: suggest a lane based on MIDI pitch range + chord density, without changing user selection.
  function suggestLaneForMidi(midi){
    // Returns: { laneKey, confidence, reason, byTrack: [...] }
    // - laneKey: best overall suggestion
    // - byTrack: best suggestion per MIDI track (for multi-track MIDIs)

    const tracks = (midi?.tracks || []).map((tr, i) => ({
      index: i,
      name: tr.name || `Track ${i+1}`,
      notes: (tr.notes || []).slice()
    })).filter(t => t.notes.length);

    if (!tracks.length){
      return { laneKey:"piano", confidence:0.25, reason:"No notes found", byTrack:[] };
    }

    function statsFor(notes){
      const midis = notes.map(n => n.midi).sort((a,b)=>a-b);
      const low = midis[0], high = midis[midis.length-1];
      const avg = midis.reduce((a,b)=>a+b,0) / midis.length;

      // overlap (polyphony estimate)
      const events = [];
      for (const n of notes){
        const s = n.time;
        const e = n.time + (n.duration || 0);
        events.push([s, +1]);
        events.push([e, -1]);
      }
      events.sort((a,b)=>a[0]-b[0] || b[1]-a[1]);
      let active=0, maxActive=0;
      for (const [,d] of events){
        active += d;
        if (active > maxActive) maxActive = active;
      }

      // sustain ratio (pads = longer notes)
      const durs = notes.map(n => n.duration || 0);
      const avgDur = durs.reduce((a,b)=>a+b,0) / durs.length;

      // density (notes per second)
      const start = Math.min(...notes.map(n=>n.time));
      const end   = Math.max(...notes.map(n=>n.time + (n.duration||0)));
      const span  = Math.max(0.001, end - start);
      const nps   = notes.length / span;

      // velocity usage (expressiveness -> piano/ep)
      const vels = notes.map(n => (n.velocity ?? 0.8));
      const velVar = (() => {
        const m = vels.reduce((a,b)=>a+b,0)/vels.length;
        const v = vels.reduce((a,b)=>a+Math.pow(b-m,2),0)/vels.length;
        return Math.sqrt(v);
      })();

      return { low, high, avg, maxActive, avgDur, nps, velVar, span, count:notes.length };
    }

    function scoreLane(s){
      const clamp01 = (x)=>Math.max(0, Math.min(1, x));
      const lowish   = clamp01((60 - s.avg)/18);       // avg below ~60
      const highish  = clamp01((s.avg - 66)/18);       // avg above ~66
      const chordy   = clamp01((s.maxActive - 2)/3);   // >=3 voices
      const monoph   = clamp01((2 - s.maxActive)/2);   // <=2 voices
      const sustain  = clamp01((s.avgDur - 0.35)/0.9); // longer notes
      const busy     = clamp01((s.nps - 3)/8);         // lots of notes/sec
      const velExpr  = clamp01((s.velVar - 0.08)/0.18);

      const scores = {
        bass:  0.55*lowish + 0.30*monoph + 0.15*(1-busy),
        pad:   0.50*sustain + 0.25*chordy + 0.25*(1-busy),
        piano: 0.35*chordy + 0.25*velExpr + 0.20*(1-highish) + 0.20*(1-lowish),
        ep:    0.30*velExpr + 0.25*(1-busy) + 0.25*(1-lowish) + 0.20*(1-highish),
        poly:  0.45*chordy + 0.20*(1-sustain) + 0.20*(1-lowish) + 0.15*(1-highish),
        bell:  0.40*highish + 0.25*(1-chordy) + 0.20*(1-sustain) + 0.15*(1-busy),
        synth: 0.35*highish + 0.25*busy + 0.25*monoph + 0.15*(1-sustain),
      };

      const entries = Object.entries(scores).sort((a,b)=>b[1]-a[1]);
      const [bestKey, bestScore] = entries[0];
      const [, secondScore] = entries[1];

      const confidence = Math.max(0.15, Math.min(0.98, (bestScore*0.7) + ((bestScore-secondScore)*0.6)));

      const reasonBits = [];
      if (bestKey === "bass")  reasonBits.push("low register", s.maxActive <= 2 ? "mostly mono" : "simple harmony");
      if (bestKey === "pad")   reasonBits.push("long notes", s.maxActive >= 3 ? "chords" : "sustained");
      if (bestKey === "piano") reasonBits.push(s.maxActive >= 3 ? "chords" : "mixed range", velExpr > 0.4 ? "velocity variety" : "");
      if (bestKey === "ep")    reasonBits.push("expressive velocity", "mid range");
      if (bestKey === "poly")  reasonBits.push("chords", "shorter sustain");
      if (bestKey === "bell")  reasonBits.push("high register", "sparser notes");
      if (bestKey === "synth") reasonBits.push("melodic/high", busy > 0.3 ? "busy lead" : "lead line");

      const reason = reasonBits.filter(Boolean).join(", ");
      return { bestKey, confidence, reason };
    }

    const byTrack = tracks.map(t => {
      const s = statsFor(t.notes);
      const r = scoreLane(s);
      return { trackIndex:t.index, trackName:t.name, stats:s, laneKey:r.bestKey, confidence:r.confidence, reason:r.reason };
    });

    const laneTotals = {};
    for (const t of byTrack){
      const w = Math.max(1, t.stats.count);
      laneTotals[t.laneKey] = (laneTotals[t.laneKey] || 0) + (t.confidence * w);
    }
    const overall = Object.entries(laneTotals).sort((a,b)=>b[1]-a[1])[0];
    const laneKey = overall ? overall[0] : "piano";

    const voters = byTrack.filter(x => x.laneKey === laneKey);
    const confidence = voters.length
      ? voters.reduce((a,b)=>a+b.confidence,0)/voters.length
      : 0.35;

    const reason = voters.length
      ? (voters.map(v => v.reason).filter(Boolean)[0] || "pattern fit")
      : "pattern fit";

    return { laneKey, confidence, reason, byTrack };
  }


async function fetchMidiArrayBuffer(path){
    const url = new URL(path, window.location.href).toString();
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch MIDI: ${path} (${res.status})`);
    return await res.arrayBuffer();
  }

  function buildMidiPath(pack, file){
    const p = (pack?.path || "").replace(/^\/+|\/+$/g,"");
    const f = (file?.file || "").replace(/^\/+/g,"");
    return `midi/${p}/${f}`;
  }

  async function previewMidiFromLibrary(pack, file){
    try{
      midiFileStatus.textContent = `Loading preview…`;
      await ensureRunning();
      stopPreview();

      const ab = await fetchMidiArrayBuffer(buildMidiPath(pack, file));
      const midi = new Midi(ab);

      
      const sug = suggestLaneForMidi(midi);


      
      setLaneSuggestionUI(sug);


      
      const suggested = sug?.laneKey;
      const sugTxt = (suggested && suggested !== activeRoll)
        ? ` • Suggested lane: ${laneLabel(suggested)}`
        : "";
// play first ~2 bars worth at current BPM (audition), quantized to our step length
      const stopper = previewStopper;
      const now = ctx.currentTime + 0.05;
      const quarter = 60 / bpm;

      // figure max audition time
      const maxSteps = LOOP_STEPS; // 1 loop worth
      const maxTime = now + (secondsPerStep() * maxSteps);

      // gather notes from all tracks (simple)
      const notes = [];
      midi.tracks.forEach(tr => (tr.notes||[]).forEach(n => notes.push(n)));
      notes.sort((a,b)=>a.time-b.time);

      for (const n of notes){
        if (stopper.stop) break;
        const t = now + (n.time * (quarter / (midi.header.tempos?.[0]?.bpm ? (60/midi.header.tempos[0].bpm) : quarter)));
        if (t > maxTime) break;

        // clamp to our playable MIDI range; octave wrapping not done (by design)
        const midiNum = n.midi;
        const freq = midiToHz(midiNum + (transpose[activeRoll]||0));
        const dur = Math.max(0.03, Math.min(0.5, (n.duration || 0.1)));

        // use the active lane synth voice
        switch(activeRoll){
          case "piano": playVoice(freq, t, dur, buses.piano, "square", 0.12, 4200, 0.12); break;
          case "ep": playEP(freq, t, dur, buses.ep); break;
          case "poly": playPoly(freq, t, dur, buses.poly); break;
          case "bell": playBell(freq, t, dur, buses.bell); break;
          case "synth": playVoice(freq, t, dur, buses.synth, "sawtooth", 0.12, 6000, 0.16); break;
          case "bass": playVoice(freq, t, dur, buses.bass, "triangle", 0.18, 1500, 0.28); break;
          case "pad": playPad(freq, t, dur, buses.pad, 7200); break;
        }
      }

      midiFileStatus.textContent = `Previewing: ${file.name || file.file}${sugTxt}`;
    }catch(err){
      console.warn(err);
      midiFileStatus.textContent = `Preview failed. Check file path + index.json entries.`;
    }
  }

  async function importMidiFromLibrary(pack, file){
    try{
      midiFileStatus.textContent = `Importing…`;
      const ab = await fetchMidiArrayBuffer(buildMidiPath(pack, file));
      
      let suggested = null;
      try{
        const midi = new Midi(ab);
        suggested = suggestLaneForMidi(midi);
      }catch(_){}
      const sugTxt = (suggested && suggested !== activeRoll)
        ? ` • Suggested lane: ${laneLabel(suggested)}`
        : "";
importMidiArrayBufferToActiveLane(ab, { fit: !!fitToLoop.checked });
      midiFileStatus.textContent = `Imported into ${LANES.find(l=>l.key===activeRoll)?.label ?? "Piano"}: ${file.name || file.file}${sugTxt}`;
    }catch(err){
      console.warn(err);
      midiFileStatus.textContent = `Import failed. Check file path + index.json entries.`;
    }
  }

  // Core importer used by BOTH file picker + library
  function importMidiArrayBufferToActiveLane(arrayBuffer, {fit=true} = {}){
    if (!window.Midi){
      alert("MIDI parser failed to load.");
      return;
    }
    const midi = new Midi(arrayBuffer);
    // Auto-detect lane suggestion (non-intrusive): show hint, do NOT switch lanes automatically.
    try{
      const sug = suggestLaneForMidi(midi);
      setLaneSuggestionUI(sug);

      if (sug?.laneKey && sug.laneKey !== activeRoll && midiFileStatus){
        midiFileStatus.textContent =
          `Suggestion: ${laneLabel(sug.laneKey)} (${Math.round((sug.confidence||0)*100)}%) — ${sug.reason}. ` +
          `Keeping target: ${laneLabel(activeRoll)}.`;
      }
    }catch(_){}
// Convert MIDI time -> steps.
    // If fit=true: scale the MIDI clip duration so it fills exactly LOOP_STEPS
    // If fit=false: map using current BPM (quarter note mapping) (may truncate)
    const grid = getActiveGrid();
    clearInstrumentGrid(grid);

    // Collect all notes
    const allNotes = [];
    midi.tracks.forEach(tr => (tr.notes||[]).forEach(n => allNotes.push(n)));
    allNotes.sort((a,b)=>a.time-b.time);

    if (!allNotes.length){
      drawRoll(isPlaying ? currentStep : -1);
      return;
    }

    const startTime = allNotes[0].time;
    const endTime = Math.max(...allNotes.map(n => n.time + (n.duration || 0)));
    const duration = Math.max(0.001, endTime - startTime);

    // fit mapping
    let toStep, toLen;
    if (fit){
      const scale = LOOP_STEPS / duration; // steps per second (relative)
      toStep = (t) => clamp(Math.round((t - startTime) * scale), 0, MASTER_STEPS-1);
      toLen  = (d) => clamp(Math.max(1, Math.round(d * scale)), 1, MASTER_STEPS);
    } else {
      const quarter = 60 / bpm;
      toStep = (t) => clamp(Math.round(((t - startTime) / quarter) * 4), 0, MASTER_STEPS-1);
      toLen  = (d) => clamp(Math.max(1, Math.round((d / quarter) * 4)), 1, MASTER_STEPS);
    }

    // Write notes to grid (clamps to our pitch range C3..C5)
    for (const n of allNotes){
      const s = toStep(n.time);
      const len = Math.min(toLen(n.duration || 0.12), MASTER_STEPS - s);
      const p = n.midi - ROLL_BASE_MIDI;
      if (p < 0 || p >= ROLL_PITCHES) continue;

      const row = grid[p];
      // remove overlaps (DAW-ish behavior)
      for (let i=0; i<MASTER_STEPS; i++){
        const l = row[i];
        if (l <= 0) continue;
        if (rangesOverlap(i, l, s, len)) row[i] = 0;
      }
      row[s] = len;
    }

    drawRoll(isPlaying ? currentStep : -1);
    // update “Import → label” text in modal if open
    if (midiModalOverlay.classList.contains("show")) renderMidiLibrary();
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  // ---------- Save/Load Project (existing) ----------
  function buildSavePayload(){
    return {
      version: 5,
      savedAt: new Date().toISOString(),
      bpm,
      resolutionLabel: RES_OPTIONS[currentResIndex]?.label ?? "1/64",
      resolutionIndex: currentResIndex,
      loopSteps: LOOP_STEPS,
      project: {
        drumRows: project.drumRows,
        lanes: Object.fromEntries(LANES.map(l => [l.key, project[l.key]])),
      },
      theme: JSON.parse(JSON.stringify(theme)),
      reverb: { return: rvReturn, size: rvSize },
      transpose: { ...transpose },
      busState: JSON.parse(JSON.stringify(busState)),
      faders: Object.fromEntries(busOrder.map(k => [k, Number(busUI[k]?.fader?.value ?? 0.3)])),
      mix: Object.fromEntries(busOrder.map(k => [k, { panVal: mix[k]?.panVal ?? 0, lpfVal: mix[k]?.lpfVal ?? 100, sendVal: mix[k]?.sendVal ?? 0 }])),
      midiLibrary: { indexPath: MIDI_INDEX_PATH } // optional breadcrumb
    };
  }
  function downloadJson(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  saveProjectBtn.addEventListener("click", async () => {
    await ensureRunning().catch(()=>{});
    const payload = buildSavePayload();
    const name = `RetroLoop_Project_${(new Date()).toISOString().replace(/[:.]/g,"-")}.json`;
    downloadJson(name, payload);
  });
  loadProjectBtn.addEventListener("click", () => projectFileInput.click());
  projectFileInput.addEventListener("change", async () => {
    const file = projectFileInput.files && projectFileInput.files[0];
    if (!file) return;
    const text = await file.text();
    let data;
    try { data = JSON.parse(text); } catch { alert("Invalid project JSON."); projectFileInput.value=""; return; }
    applyLoadedProject(data);
    projectFileInput.value = "";
  });

  function applyThemeLoaded(t){
    if (!t) return;
    if (typeof t.bgBase === "string") applyBgColor(t.bgBase);
    if (t.lanes){
      for (const lane of LANES){
        if (typeof t.lanes[lane.key] === "string") applyLaneColor(lane.key, t.lanes[lane.key]);
      }
    }
    if (t.drums){
      for (const k of Object.keys(t.drums)){
        if (typeof t.drums[k] === "string") applyDrumColor(k, t.drums[k]);
      }
    }
    if (t.labelText){
      theme.labelText = t.labelText;
      for (const lane of LANES) updateLaneLabelStyles(lane.key);
updateActiveTabStyles();
    }
  }

  function applyLoadedProject(data){
    stopTransportOnly();
    if (Number.isFinite(Number(data.bpm))){
      bpm = clampInt(data.bpm, 70, 180);
      bpmEl.value = String(bpm);
      bpmLabel.textContent = String(bpm);
    }
    if (data.theme) applyThemeLoaded(data.theme);

    let idx = Number.isFinite(Number(data.resolutionIndex))
      ? clampInt(data.resolutionIndex, 0, RES_OPTIONS.length - 1)
      : null;
    if (idx === null && typeof data.resolutionLabel === "string"){
      const found = RES_OPTIONS.findIndex(x => x.label === data.resolutionLabel);
      if (found >= 0) idx = found;
    }
    if (idx === null) idx = 2;
    currentResIndex = idx;
    const opt = RES_OPTIONS[idx];
    LOOP_STEPS = opt.steps;
        resText.textContent = opt.label;
    if (loopSelectDrum) loopSelectDrum.value = String(currentResIndex);
    if (loopSelectRoll) loopSelectRoll.value = String(currentResIndex);
    
        // --- drums ---
    const srcRows = data.project?.drumRows ?? data.drumRows ?? null;
    if (Array.isArray(srcRows)){
      // New format: array of rows
      project.drumRows = srcRows.slice(0, MAX_DRUM_ROWS).map(r => ({
        id: (r.id ?? (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random()))),
        soundKey: String(r.soundKey ?? "kick"),
        label: String(r.label ?? ((DRUM_SOUNDS.find(d=>d.key===r.soundKey)?.label) || r.soundKey || "Kick")),
        steps: Array.isArray(r.steps) ? r.steps.slice(0, MASTER_STEPS).map(Boolean).concat(new Array(Math.max(0, MASTER_STEPS-(r.steps?.length||0))).fill(false)) : new Array(MASTER_STEPS).fill(false),
        vol: clampInt((r.vol ?? 80), 0, 120),
      }));
    } else {
      // Legacy: object of named drum arrays (+ optional drumVols)
      const srcDrums = data.project?.drums ?? data.drums;
      const dv = data.project?.drumVols ?? data.drumVols ?? {};
      if (srcDrums && typeof srcDrums === "object"){
        const legacyKeys = Object.keys(srcDrums);
        const rows = [];
        for (const key of legacyKeys){
          const arr = srcDrums[key];
          if (!Array.isArray(arr)) continue;
          rows.push({
            id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random())),
            soundKey: key,
            label: (DRUM_SOUNDS.find(d=>d.key===key)?.label) || key,
            steps: arr.slice(0, MASTER_STEPS).map(Boolean).concat(new Array(Math.max(0, MASTER_STEPS-arr.length)).fill(false)),
            vol: clampInt((dv?.[key] ?? 80), 0, 120),
          });
        }
        project.drumRows = (rows.length ? rows : DEFAULT_DRUM_ROWS.map(k => ({
          id: (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random())),
          soundKey: k,
          label: (DRUM_SOUNDS.find(d=>d.key===k)?.label) || k,
          steps: new Array(MASTER_STEPS).fill(false),
          vol: 80,
        }))).slice(0, MAX_DRUM_ROWS);
      }
    }
    ensureDrumRowGains(true);

    const lanesObj = data.project?.lanes ?? data.lanes ?? null;
    function loadGrid(dst, src){
      if (!Array.isArray(src)) return;

      // Migration: some older saves may have lane grids stored as [steps][pitches] instead of [pitches][steps].
      const looksTransposed =
        (src.length === MASTER_STEPS) &&
        Array.isArray(src[0]) &&
        (src[0].length === ROLL_PITCHES);

      if (looksTransposed){
        for (let s=0; s<MASTER_STEPS; s++){
          const col = src[s];
          if (!Array.isArray(col)) continue;
          for (let p=0; p<ROLL_PITCHES; p++){
            dst[p][s] = clampInt(col[p] ?? 0, 0, MASTER_STEPS);
          }
        }
        return;
      }

      // Normal: [pitches][steps]
      for (let p=0; p<ROLL_PITCHES; p++){
        const row = src[p];
        if (!Array.isArray(row)) continue;
        for (let s=0; s<MASTER_STEPS; s++){
          dst[p][s] = clampInt(row[s] ?? 0, 0, MASTER_STEPS);
        }
      }
    }
    if (lanesObj){
      for (const lane of LANES){
        if (lanesObj[lane.key]) loadGrid(project[lane.key], lanesObj[lane.key]);
      }
    }

    if (data.transpose){
      for (const lane of LANES){
        setTranspose(lane.key, clampInt(data.transpose[lane.key] ?? 0, -24, 24));
      }
    } else {
      for (const lane of LANES) setTranspose(lane.key, 0);
    }

    buildDrumGrid();
    refreshDrumUI();
    updateActiveTabStyles();
    drawRoll(-1);
  }

  // ---------- Demo / Clear ----------
  function clearProject(){
    stopTransportOnly();
    const fresh = makeEmptyProject();
    // drums
    project.drumRows = fresh.drumRows.map(r => ({
      id: r.id,
      soundKey: r.soundKey,
      label: r.label,
      steps: r.steps.slice(),
      vol: r.vol
    }));
    ensureDrumRowGains(true);

    // lanes
    for (let p=0; p<ROLL_PITCHES; p++){
      for (const lane of LANES) project[lane.key][p] = fresh[lane.key][p].slice();
    }

    buildDrumGrid();
    refreshDrumUI();
    drawRoll(-1);
    saveToLocal();
  }
  clearProjectBtn.addEventListener("click", clearProject);

  async function loadDemoFromJson(){
    const url = new URL(DEMO_JSON_PATH, window.location.href).toString();
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to fetch demo JSON (${res.status})`);
    const data = await res.json();
    applyLoadedProject(data);
  }
  loadDemoBtn.addEventListener("click", async () => {
    try { await loadDemoFromJson(); }
    catch (e){ console.warn("Demo JSON load failed.", e); }
  });

  
  // ---------- Modular UI: drag + persist positions ----------
  const MODULE_IDS = ["mixerModule","drumModule","rollModule"];
  const TRANSPORT_Z = 2147483647; // keep transport always on top
  const MODULE_MAX_Z = 2147483000; // never exceed transport
  let moduleZ = 100;

  const moduleStateKey = "retroloop_module_layout_v1";

  function loadModuleLayout(){
    try{
      const raw = localStorage.getItem(moduleStateKey);
      if (!raw) return;
      const data = JSON.parse(raw);
      MODULE_IDS.forEach(id=>{
        const el = document.getElementById(id);
        if (!el) return;
        const st = data[id];
        if (!st) return;
        if (Number.isFinite(st.x) && Number.isFinite(st.y)){
          el.dataset.tx = String(st.x);
          el.dataset.ty = String(st.y);
          el.style.transform = `translate(${st.x}px, ${st.y}px)`;
        }
        if (Number.isFinite(st.w)) el.style.width = `${st.w}px`;
        if (Number.isFinite(st.h)) el.style.height = `${st.h}px`;
      });
    }catch(_){}
  }
  function saveModuleLayout(){
    try{
      const out = {};
      MODULE_IDS.forEach(id=>{
        const el = document.getElementById(id);
        if (!el) return;
        const x = Number(el.dataset.tx || 0);
        const y = Number(el.dataset.ty || 0);
        const rect = el.getBoundingClientRect();
        // width/height from inline style if set, else current
        const w = Number((el.style.width || "").replace("px","")) || rect.width;
        const h = Number((el.style.height || "").replace("px","")) || rect.height;
        out[id] = { x, y, w, h };
      });
      localStorage.setItem(moduleStateKey, JSON.stringify(out));
    }catch(_){}
  }

  function makeModuleDraggable(card){
    const hd = card.querySelector(".hd");
    if (!hd) return;

    let dragging=false, pid=null, startX=0, startY=0, baseX=0, baseY=0;

    const onDown = (e) => {
      // ignore if user is trying to interact with controls inside header
      const tag = (e.target?.tagName || "").toLowerCase();
      if (tag === "button" || tag === "input" || tag === "select" || tag === "textarea") return;

      if (e.target && e.target.closest && e.target.closest(".tabs, .tab, .miniBtn, .pill, .kbd, .trKnobs, .trKnob, .knob")) return;

      e.preventDefault();
      dragging = true;
      moduleZ = Math.min(MODULE_MAX_Z, moduleZ + 1);
      card.style.zIndex = String(moduleZ);

      pid = e.pointerId;
      startX = e.clientX;
      startY = e.clientY;
      baseX = Number(card.dataset.tx || 0);
      baseY = Number(card.dataset.ty || 0);
      card.classList.add("dragging");
      hd.setPointerCapture(pid);
    };

    const onMove = (e) => {
      if (!dragging || e.pointerId !== pid) return;
      e.preventDefault();

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      // Proposed translation
      let x = baseX + dx;
      let y = baseY + dy;

      // --- Clamp: never allow a module to go above the transport bar ---
      const t = document.getElementById("transportCard");
      const barBottom = t ? t.getBoundingClientRect().bottom : 0;
      const currentRect = card.getBoundingClientRect();
      // currentRect.top corresponds to current y; translate delta adjusts top by (y - currentY)
      const currentY = Number(card.dataset.ty || 0);
      const proposedTop = currentRect.top + (y - currentY);
      const minTop = barBottom + 8;
      if (proposedTop < minTop){
        // adjust y so proposedTop == minTop
        y += (minTop - proposedTop);
      }

      // --- No-overlap: prevent modules from overlapping each other ---
      // Build proposed rect based on current rect + delta
      const proposedLeft = currentRect.left + (x - Number(card.dataset.tx || 0));
      const proposedTop2 = currentRect.top + (y - Number(card.dataset.ty || 0));
      const proposedRect = {
        left: proposedLeft,
        top: proposedTop2,
        right: proposedLeft + currentRect.width,
        bottom: proposedTop2 + currentRect.height
      };

      const intersects = (a,b) => !(a.right <= b.left || a.left >= b.right || a.bottom <= b.top || a.top >= b.bottom);

      let blocked = false;
      for (const id of MODULE_IDS){
        if (id === card.id) continue;
        const other = document.getElementById(id);
        if (!other) continue;
        const r = other.getBoundingClientRect();
        // tiny tolerance so edge-to-edge is allowed
        const otherRect = { left:r.left+1, top:r.top+1, right:r.right-1, bottom:r.bottom-1 };
        if (intersects(proposedRect, otherRect)){
          blocked = true;
          break;
        }
      }
      if (blocked){
        // refuse the move; keep last valid position
        return;
      }

      card.dataset.tx = String(x);
      card.dataset.ty = String(y);
      card.style.transform = `translate(${x}px, ${y}px)`;
    };

    const onUp = (e) => {
      if (!dragging || e.pointerId !== pid) return;
      dragging=false; pid=null;
      card.classList.remove("dragging");
      saveModuleLayout();
    };

    hd.addEventListener("pointerdown", onDown, {passive:false});
    hd.addEventListener("pointermove", onMove, {passive:false});
    hd.addEventListener("pointerup", onUp);
    hd.addEventListener("pointercancel", onUp);
    hd.addEventListener("lostpointercapture", () => {
      if (!dragging) return;
      dragging=false; pid=null;
      card.classList.remove("dragging");
      saveModuleLayout();
    });

    // persist resize (best-effort): watch pointerup anywhere on card
    card.addEventListener("pointerup", () => saveModuleLayout());
  }

  
  function syncTransportSpacer(){
    const t = document.getElementById("transportCard");
    const s = document.getElementById("transportSpacer");
    if (!t || !s) return;
    const r = t.getBoundingClientRect();
    // keep enough space so content starts below fixed bar
    s.style.height = Math.ceil(r.height + 24) + "px";
  }

function initModules(){
    MODULE_IDS.forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      makeModuleDraggable(el);
    });

    // Save on window resize as well
    window.addEventListener("resize", () => { saveModuleLayout(); syncTransportSpacer(); });
    loadModuleLayout();
    syncTransportSpacer();
  }


// ---------- Init ----------
  bpm = 115;
  bpmEl.value = "115";
  bpmLabel.textContent = "115";

  currentResIndex = 2;
  const initialOpt = RES_OPTIONS[currentResIndex];
  LOOP_STEPS = initialOpt.steps;
  resText.textContent = initialOpt.label;

  applyBgColor(theme.bgBase);
  for (const lane of LANES) if (theme.lanes[lane.key]) applyLaneColor(lane.key, theme.lanes[lane.key]);
  for (const dk of Object.keys(theme.drums)) if (theme.drums[dk]) applyDrumColor(dk, theme.drums[dk]);

  buildLoopDropdowns();
  buildTabs();
  buildTransposeKnobs();
  buildMixer();
  buildDrumGrid();
  drawRoll(-1);

  initModules();

  (async () => {
    try{ await loadDemoFromJson(); }
    catch (e){ console.warn("Auto demo JSON load failed; starting empty.", e); }
  })();

})();
</script>
</body>
</html>
