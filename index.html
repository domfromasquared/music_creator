<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>RetroLoop Studio</title>
  <style>
    :root{
      --bg:#0f1115;
      --ink:#e9eef5;
      --muted:#97a3b6;
      --card: rgba(255,255,255,.04);
      --card2: rgba(255,255,255,.02);
      --stroke: rgba(255,255,255,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --groupA:#121a28;
      --groupB:#211a2f;

      --kick: rgba(255,139,90,0.95);
      --snare: rgba(88,166,255,0.92);
      --clap: rgba(255,255,255,0.88);
      --shaker: rgba(186, 140, 255, 0.90);
      --ch: rgba(124,255,178,0.92);
      --oh: rgba(255, 210, 120, 0.92);

      --rollBg: rgba(0,0,0,.18);
      --rollStrip: rgba(0,0,0,.32);
      --gridLine: rgba(255,255,255,.06);
      --gridBeat: rgba(255,255,255,.14);

      --whiteKeyA: rgba(255,255,255,0.92);
      --whiteKeyB: rgba(255,255,255,0.82);
      --blackKeyA: rgba(12,14,20,0.98);
      --blackKeyB: rgba(22,24,32,0.98);

      --pianoNote: rgba(124,255,178,.85);
      --bassNote: rgba(88,166,255,.80);
      --synthNote: rgba(255,139,90,.78);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 20% -10%, #1b2040 0%, transparent 60%),
                  radial-gradient(900px 500px at 90% 0%, #223022 0%, transparent 55%),
                  var(--bg);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 18px;
    }
    h1{margin:0 0 6px 0; font-size:18px; letter-spacing:.2px}
    .sub{color:var(--muted); margin:0 0 16px 0; font-size:13px}

    .wrap{
      display:grid;
      grid-template-columns: 440px 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, var(--card), var(--card2));
      border:1px solid var(--stroke);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .hd{
      padding: 12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .bd{padding: 12px}
    .title{
      font-size:13px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.12em
    }

    button{
      background: rgba(0,0,0,.22);
      color:var(--ink);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 700;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:disabled{opacity:.5; cursor:not-allowed}

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--muted);
      display:flex; gap:8px; align-items:center;
      white-space:nowrap;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:8px;
      background: rgba(0,0,0,.25);
      color: var(--ink);
    }
    input[type="range"]{width: 150px}
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}

    /* =========================
       TOP BAR (NEW UI PLACEMENT)
       ========================= */
    #topBar{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
      width:100%;
    }
    #topTransportRow{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      flex-wrap:wrap;
    }
    #topPillsRow{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    /* =========================
       MIXER VOLUME SLOT (NEW)
       ========================= */
    #mixerVolumeSlot{
      display:flex;
      gap:14px;
      align-items:flex-end;
      flex-wrap:wrap;
      padding:10px;
      border-radius:14px;
      background: rgba(0,0,0,.14);
      border:1px solid rgba(255,255,255,.08);
    }

    .mixerVolBlock{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      padding:10px 10px;
      border-radius:14px;
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.08);
      min-width: 84px;
    }
    .mixerVolBlock .lbl{
      font-size:12px;
      color: rgba(255,255,255,.70);
      font-weight:800;
      letter-spacing:.08em;
      text-transform:uppercase;
      user-select:none;
    }

    /* Rotate ONLY the existing sliders by ID (keeps JS intact) */
    #pianoVol, #synthVol, #bassVol, #drumVol{
      width: 120px;             /* becomes “height” after rotation */
      transform: rotate(-90deg);
      transform-origin: center;
      touch-action: pan-y;
    }

    /* =========================
       DRUM GRID
       ========================= */
    .drumGrid{
      display:grid;
      grid-template-columns: 160px minmax(0, 1fr);
      gap:10px;
      align-items:start;
      touch-action: none;
    }
    .trackNames{display:grid; gap:8px;}
    .trackName{
      height:40px;
      border-radius: 12px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.08);
      padding: 6px 8px;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .trackLabel{
      font-size:12px;
      color: var(--muted);
      text-transform:uppercase;
      letter-spacing:.08em;
      line-height:1;
    }
    .steps{
      display:grid;
      gap:8px;
      overflow:hidden;
      border-radius: 12px;
      min-width: 0;
    }
    .rowSteps{
      display:grid;
      gap:6px;
      height:40px;
      align-items:stretch;
      touch-action: none;
      width: 100%;
      min-width: 0;
    }
    .cell{
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      position:relative;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      min-width: 0;
    }
    .cell.groupA{ background: var(--groupA); }
    .cell.groupB{ background: var(--groupB); }
    .cell::after{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.38);
      opacity:.55;
      pointer-events:none;
    }
    .cell.on::after{opacity:.07}
    .cell.on.kick{  background: linear-gradient(180deg, var(--kick), rgba(255,139,90,0.45)); border-color: rgba(255,139,90,0.75); }
    .cell.on.snare{ background: linear-gradient(180deg, var(--snare),rgba(88,166,255,0.30)); border-color: rgba(88,166,255,0.65); }
    .cell.on.clap{  background: linear-gradient(180deg, var(--clap), rgba(255,255,255,0.18)); border-color: rgba(255,255,255,0.45); }
    .cell.on.shaker{ background: linear-gradient(180deg, var(--shaker), rgba(186,140,255,0.28)); border-color: rgba(186,140,255,0.60); }
    .cell.on.ch{     background: linear-gradient(180deg, var(--ch), rgba(124,255,178,0.30)); border-color: rgba(124,255,178,0.65); }
    .cell.on.oh{     background: linear-gradient(180deg, var(--oh), rgba(255,210,120,0.24)); border-color: rgba(255,210,120,0.60); }

    .cell.beatDivider{ box-shadow: inset -2px 0 0 rgba(255,255,255,0.18); }
    .cell.playhead{ outline: 2px solid rgba(255,255,255,0.30); outline-offset: 1px; }
    .cell.drag-hover{
      outline: 2px solid rgba(255,255,255,0.45);
      outline-offset: -2px;
      box-shadow: inset 0 0 0 999px rgba(255,255,255,0.10);
    }

    /* =========================
       PIANO ROLL
       ========================= */
    .rollWrap{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      overflow:hidden;
      touch-action: none;
    }
    canvas{display:block; width:100%; height:auto; touch-action:none}

    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tab{
      padding: 7px 14px;
      border-radius: 999px;
      font-size:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: background .15s ease, border-color .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .tab.active{ color: var(--ink); }
    .tab.active[data-roll="piano"]{ background: rgba(124,255,178,.16); border-color: rgba(124,255,178,.45); }
    .tab.active[data-roll="synth"]{ background: rgba(255,139,90,.16); border-color: rgba(255,139,90,.45); }
    .tab.active[data-roll="bass"]{  background: rgba(88,166,255,.16); border-color: rgba(88,166,255,.45); }

    /* simple transpose pills (kept minimal; you can already have your own) */
    .trPill{display:flex; align-items:center; gap:8px;}
    .trPill .kbd{min-width:34px; text-align:center}

    #midiFile{display:none}

    /* legacy area hidden (we move from here) */
    #legacyControls{display:none;}
  </style>
</head>

<body>
  <h1>RetroLoop Studio</h1>
  <p class="sub">
    4/4 • Drum sequencer + piano roll • Loop size:
    <span class="kbd" id="resText">1/64</span> • Keys: C3 → C5
  </p>

  <div class="wrap">
    <!-- LEFT: DAW -->
    <div class="card">
      <div class="hd">
        <div class="title">DAW</div>
        <!-- NEW top bar slot -->
        <div id="topBar">
          <div id="topTransportRow"></div>
          <div id="topPillsRow"></div>
        </div>
      </div>

      <div class="bd">
        <!-- Mixer area with NEW volume slot -->
        <div class="title" style="margin-bottom:8px;">Mixer</div>
        <div id="mixerVolumeSlot"></div>

        <div class="btnRow" style="margin-top:12px;">
          <button id="loadDemo">Reload Demo</button>
          <button id="clearProject">Clear Project</button>
          <button id="importMidiBtn">Import MIDI</button>
          <input id="midiFile" type="file" accept=".mid,.midi" />
        </div>

        <p class="hint">
          <span class="kbd">Space</span> toggles Play/Pause (desktop).<br/>
          Demo MIDI loads from <span class="kbd">MIDI/</span> (GitHub Pages: relative paths).
        </p>

        <!-- =========================
             LEGACY CONTROLS (SOURCE)
             We keep the SAME elements+IDs here,
             then move them into the new slots.
             ========================= -->
        <div id="legacyControls">
          <!-- Play/Pause/Stop (same IDs) -->
          <div id="transportRow" class="btnRow">
            <button id="playBtn">Play</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="stopBtn" disabled>Stop</button>
          </div>

          <!-- BPM pill (same exact element, same ID wrapper) -->
          <div class="pill" id="bpmPill">
            <span style="min-width:38px;">BPM</span>
            <input id="bpm" type="range" min="70" max="180" value="115"/>
            <span id="bpmLabel" class="kbd">115</span>
          </div>

          <!-- Loop/Resolution pill (same exact element, same ID wrapper) -->
          <div class="pill" id="resolutionPill">
            <span>Loop</span>
            <input id="resolution" type="range" min="0" max="2" step="1" value="2"/>
            <span id="resolutionLabel" class="kbd">1/64</span>
          </div>

          <!-- Existing instrument volume controls (same slider IDs) -->
          <div id="instrumentVolumes" class="btnRow">
            <div class="pill"><span>Piano</span><input id="pianoVol" type="range" min="0" max="1" step="0.01" value="0.35"></div>
            <div class="pill"><span>Synth</span><input id="synthVol" type="range" min="0" max="1" step="0.01" value="0.32"></div>
            <div class="pill"><span>Bass</span><input id="bassVol" type="range" min="0" max="1" step="0.01" value="0.40"></div>
            <div class="pill"><span>Drums</span><input id="drumVol" type="range" min="0" max="1" step="0.01" value="0.85"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Drum Sequencer -->
    <div class="card">
      <div class="hd">
        <div class="title">Drum Sequencer</div>
        <div class="pill">
          <span>Loop</span>
          <span class="kbd" id="groupText2">1/64</span>
        </div>
      </div>
      <div class="bd">
        <div class="drumGrid" id="drumGrid"></div>
      </div>
    </div>

    <!-- BOTTOM: Piano Roll -->
    <div class="card" style="grid-column:1 / -1;">
      <div class="hd">
        <div class="title">Piano Roll</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
          <div class="tabs">
            <div class="tab active" data-roll="piano">Piano</div>
            <div class="tab" data-roll="synth">Synth</div>
            <div class="tab" data-roll="bass">Bass</div>
          </div>
          <div class="pill trPill">
            <span style="opacity:.9;">Transpose</span>
            <span class="kbd" id="pianoTr">0</span>
            <span class="kbd" id="synthTr">0</span>
            <span class="kbd" id="bassTr">0</span>
          </div>
        </div>
      </div>
      <div class="bd">
        <div class="rollWrap">
          <canvas id="roll" width="1280" height="560"></canvas>
        </div>
      </div>
    </div>
  </div>

  <!-- MIDI parser -->
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>

  <script>
  (() => {
    /* ==========================================
       UI RE-PARENTING (ONLY MOVING EXISTING NODES)
       ========================================== */
    document.addEventListener("DOMContentLoaded", () => {
      const topTransportRow = document.getElementById("topTransportRow");
      const topPillsRow = document.getElementById("topPillsRow");
      const mixerVolumeSlot = document.getElementById("mixerVolumeSlot");

      const transportRow = document.getElementById("transportRow");
      const bpmPill = document.getElementById("bpmPill");
      const resolutionPill = document.getElementById("resolutionPill");
      const instrumentVolumes = document.getElementById("instrumentVolumes");

      // Move Play/Pause/Stop into top bar row 1
      if (topTransportRow && transportRow) topTransportRow.appendChild(transportRow);

      // Move BPM + Loop into top bar row 2
      if (topPillsRow) {
        if (bpmPill) topPillsRow.appendChild(bpmPill);
        if (resolutionPill) topPillsRow.appendChild(resolutionPill);
      }

      // Move existing instrument volume sliders into mixer slot, vertical (IDs unchanged)
      function mountVol(label, inputId){
        const el = document.getElementById(inputId);
        if (!mixerVolumeSlot || !el) return;
        const block = document.createElement("div");
        block.className = "mixerVolBlock";
        const lbl = document.createElement("div");
        lbl.className = "lbl";
        lbl.textContent = label;
        block.appendChild(lbl);
        block.appendChild(el); // re-parent the SAME input node
        mixerVolumeSlot.appendChild(block);
      }

      // Re-parent the original sliders (same IDs)
      mountVol("Piano", "pianoVol");
      mountVol("Synth", "synthVol");
      mountVol("Bass",  "bassVol");
      mountVol("Drums", "drumVol");

      // Keep legacy wrapper hidden (it was just a source container)
      if (instrumentVolumes) instrumentVolumes.remove();
    });

    /* ==========================================
       CORE APP (simple, stable, no extra refactor)
       ========================================== */

    const RES_OPTIONS = [
      { label: "1/16", steps: 16 },
      { label: "1/32", steps: 32 },
      { label: "1/64", steps: 64 },
    ];
    const MASTER_STEPS = 64;

    const ROLL_BASE_MIDI = 48; // C3
    const ROLL_TOP_MIDI  = 72; // C5
    const ROLL_PITCHES   = (ROLL_TOP_MIDI - ROLL_BASE_MIDI) + 1;
    const KEY_PAD = 128;

    const drumNames = ["Kick", "Clap", "Shaker", "Snare", "CH", "OH"];
    const drumKeys  = ["kick", "clap", "shaker", "snare", "ch", "oh"];

    const MIDI_PATHS = {
      bass:  "MIDI/NW_EID_115_synth_pluck_nightlife_Abmaj.mid",
      piano: "MIDI/NW_EID_115_synth_chords_nightlife_Abmaj.mid",
      synth: "MIDI/NW_EID_115_synth_arp_nightlife_Abmaj.mid",
    };

    const transpose = { piano:0, synth:0, bass:0 };

    function makeEmptyProject(){
      return {
        drums: Object.fromEntries(drumKeys.map(k => [k, new Array(MASTER_STEPS).fill(false)])),
        piano: Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0)),
        synth: Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0)),
        bass:  Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0)),
      };
    }
    const project = makeEmptyProject();

    let LOOP_STEPS = 64;

    // UI refs (IDs unchanged)
    const playBtn = document.getElementById("playBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const stopBtn = document.getElementById("stopBtn");

    const bpmEl = document.getElementById("bpm");
    const bpmLabel = document.getElementById("bpmLabel");

    const resEl = document.getElementById("resolution");
    const resLabel = document.getElementById("resolutionLabel");
    const resText = document.getElementById("resText");
    const groupText2 = document.getElementById("groupText2");

    const pianoVol = document.getElementById("pianoVol");
    const synthVol = document.getElementById("synthVol");
    const bassVol  = document.getElementById("bassVol");
    const drumVol  = document.getElementById("drumVol");

    const loadDemoBtn = document.getElementById("loadDemo");
    const clearProjectBtn = document.getElementById("clearProject");
    const importMidiBtn = document.getElementById("importMidiBtn");
    const midiFileInput = document.getElementById("midiFile");

    const drumGridEl = document.getElementById("drumGrid");
    const rollCanvas = document.getElementById("roll");
    const g = rollCanvas.getContext("2d");

    // tabs
    let activeRoll = "piano";
    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => {
        document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
        t.classList.add("active");
        activeRoll = t.dataset.roll;
        drawRoll(isPlaying ? currentStep : -1);
      });
    });

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let ctx=null, master=null;
    let pianoBus=null, synthBus=null, bassBus=null, drumBus=null;
    let drumGains = {};
    let noiseBuf=null;

    let bpm = 115;

    function ensureAudio(){
      if (ctx) return;
      ctx = new AudioContext();

      master = ctx.createGain();
      master.gain.value = 0.9;
      master.connect(ctx.destination);

      pianoBus = ctx.createGain();
      synthBus = ctx.createGain();
      bassBus  = ctx.createGain();
      drumBus  = ctx.createGain();

      pianoBus.connect(master);
      synthBus.connect(master);
      bassBus.connect(master);
      drumBus.connect(master);

      drumKeys.forEach(k => {
        const gn = ctx.createGain();
        gn.gain.value = 1;
        gn.connect(drumBus);
        drumGains[k] = gn;
      });

      // volumes (IDs unchanged)
      const applyVols = () => {
        pianoBus.gain.value = Number(pianoVol.value);
        synthBus.gain.value = Number(synthVol.value);
        bassBus.gain.value  = Number(bassVol.value);
        drumBus.gain.value  = Number(drumVol.value);
      };
      pianoVol.addEventListener("input", applyVols);
      synthVol.addEventListener("input", applyVols);
      bassVol.addEventListener("input", applyVols);
      drumVol.addEventListener("input", applyVols);
      applyVols();
    }

    async function ensureRunning(){
      ensureAudio();
      if (ctx.state !== "running") await ctx.resume();
    }

    // Spacebar play/pause
    function isTypingTarget(el){
      if (!el) return false;
      const tag = (el.tagName || "").toLowerCase();
      return tag === "input" || tag === "textarea" || el.isContentEditable;
    }
    window.addEventListener("keydown", (e) => {
      if (e.code !== "Space") return;
      if (isTypingTarget(document.activeElement)) return;
      e.preventDefault();
      togglePlayPause();
    }, {passive:false});

    bpmEl.addEventListener("input", () => {
      bpm = Number(bpmEl.value);
      bpmLabel.textContent = String(bpm);
    });

    // Resolution: absolute BPM, loop just changes step count
    resEl.addEventListener("input", () => {
      const opt = RES_OPTIONS[Number(resEl.value)];
      applyLoopSize(opt.steps, opt.label);
    });

    function applyLoopSize(newSteps, label){
      stop();
      LOOP_STEPS = newSteps;
      resLabel.textContent = label;
      resText.textContent = label;
      groupText2.textContent = label;
      buildDrumGrid();
      drawRoll(-1);
    }

    /* ========= MIDI loading ========= */
    async function fetchMidiArrayBuffer(relPath){
      const url = new URL(relPath, window.location.href).toString();
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch MIDI (${res.status})`);
      return await res.arrayBuffer();
    }

    function clearInstrumentGrid(grid){
      for (let p=0; p<ROLL_PITCHES; p++) grid[p].fill(0);
    }

    function rangesOverlap(aStart,aLen,bStart,bLen){
      const aEnd=aStart+aLen, bEnd=bStart+bLen;
      return aStart < bEnd && bStart < aEnd;
    }
    function clearOverlaps(row,start,len){
      for (let s=0; s<MASTER_STEPS; s++){
        const l=row[s];
        if (l<=0) continue;
        if (rangesOverlap(s,l,start,len)) row[s]=0;
      }
    }
    function setNoteLen(grid, midi, start, len){
      const p = midi - ROLL_BASE_MIDI;
      if (p<0 || p>=ROLL_PITCHES) return;
      len = Math.max(1, Math.min(len, MASTER_STEPS-start));
      const row = grid[p];
      clearOverlaps(row,start,len);
      row[start]=len;
    }

    async function importMidiIntoGrid(arrayBuffer, targetGrid){
      const midi = new Midi(arrayBuffer);
      const quarter = 60 / bpm;
      const toStep = (t) => Math.max(0, Math.min(MASTER_STEPS-1, Math.round((t/quarter)*4)));
      const toLen  = (d) => Math.max(1, Math.min(MASTER_STEPS, Math.round((d/quarter)*4)));

      clearInstrumentGrid(targetGrid);

      midi.tracks.forEach(tr => {
        tr.notes?.forEach(n => {
          const s = toStep(n.time);
          const l = Math.min(toLen(n.duration), MASTER_STEPS - s);
          setNoteLen(targetGrid, n.midi, s, l);
        });
      });
    }

    function setDemoDrums(){
      // simple modern-ish groove (you can swap later)
      drumKeys.forEach(k => project.drums[k].fill(false));
      const K=[11,30,32,43,56,62];
      const S=[24,56];
      const C=[24,56];
      const CH=[6,14,22,30,38,46,54,62];
      const OH=[3,17,35,49];
      const SH=[8,26,40,58];

      K.forEach(s => project.drums.kick[s]=true);
      S.forEach(s => project.drums.snare[s]=true);
      C.forEach(s => project.drums.clap[s]=true);
      CH.forEach(s => project.drums.ch[s]=true);
      OH.forEach(s => project.drums.oh[s]=true);
      SH.forEach(s => project.drums.shaker[s]=true);
    }

    async function loadDemoFromMidiFolder(){
      const [pluckBuf, chordsBuf, arpBuf] = await Promise.all([
        fetchMidiArrayBuffer(MIDI_PATHS.bass),
        fetchMidiArrayBuffer(MIDI_PATHS.piano),
        fetchMidiArrayBuffer(MIDI_PATHS.synth),
      ]);
      stop();
      await importMidiIntoGrid(pluckBuf, project.bass);
      await importMidiIntoGrid(chordsBuf, project.piano);
      await importMidiIntoGrid(arpBuf, project.synth);
      setDemoDrums();
      buildDrumGrid();
      drawRoll(-1);
    }

    /* ========= Drum UI ========= */
    function buildDrumGrid(){
      drumGridEl.innerHTML = "";

      const namesCol = document.createElement("div");
      namesCol.className = "trackNames";

      const stepsCol = document.createElement("div");
      stepsCol.className = "steps";

      drumKeys.forEach((key, idx) => {
        const nameRow = document.createElement("div");
        nameRow.className = "trackName";
        const label = document.createElement("div");
        label.className = "trackLabel";
        label.textContent = drumNames[idx];
        nameRow.appendChild(label);
        namesCol.appendChild(nameRow);

        const row = document.createElement("div");
        row.className = "rowSteps";
        row.style.gridTemplateColumns = `repeat(${LOOP_STEPS}, minmax(0, 1fr))`;

        for (let s=0; s<LOOP_STEPS; s++){
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.classList.add((Math.floor(s/4)%2===0) ? "groupA" : "groupB");
          cell.classList.add(key);
          if ((s+1)%4===0 && s!==LOOP_STEPS-1) cell.classList.add("beatDivider");
          cell.dataset.track = key;
          cell.dataset.step = String(s);
          cell.classList.toggle("on", project.drums[key][s]);
          row.appendChild(cell);
        }
        stepsCol.appendChild(row);
      });

      drumGridEl.appendChild(namesCol);
      drumGridEl.appendChild(stepsCol);

      enableDrumPainting(stepsCol);
    }

    // row-locked drag paint
    let drumPaint = { active:false, pointerId:null, value:true, visited:new Set(), track:null };

    function cellFromPoint(clientX, clientY){
      const el = document.elementFromPoint(clientX, clientY);
      return (el && el.classList && el.classList.contains("cell")) ? el : null;
    }
    function clearDragHover(){
      drumGridEl.querySelectorAll(".cell.drag-hover").forEach(c => c.classList.remove("drag-hover"));
    }
    function applyDrumCell(cell, value){
      const key = cell.dataset.track;
      if (drumPaint.track && key !== drumPaint.track) return; // lock row
      const step = Number(cell.dataset.step);
      const id = `${key}:${step}`;
      if (drumPaint.visited.has(id)) return;
      drumPaint.visited.add(id);

      project.drums[key][step] = value;
      cell.classList.toggle("on", value);
      cell.classList.add("drag-hover");
    }
    function enableDrumPainting(container){
      container.addEventListener("pointerdown", (e) => {
        const cell = e.target.closest(".cell");
        if (!cell) return;
        e.preventDefault();

        drumPaint.active = true;
        drumPaint.pointerId = e.pointerId;
        drumPaint.visited.clear();
        clearDragHover();

        const key = cell.dataset.track;
        const step = Number(cell.dataset.step);

        drumPaint.track = key;
        drumPaint.value = !project.drums[key][step];

        container.setPointerCapture(e.pointerId);
        applyDrumCell(cell, drumPaint.value);
      }, {passive:false});

      container.addEventListener("pointermove", (e) => {
        if (!drumPaint.active || drumPaint.pointerId !== e.pointerId) return;
        e.preventDefault();
        const cell = cellFromPoint(e.clientX, e.clientY);
        if (!cell) return;
        applyDrumCell(cell, drumPaint.value);
      }, {passive:false});

      const end = (e) => {
        if (!drumPaint.active || drumPaint.pointerId !== e.pointerId) return;
        drumPaint.active = false;
        drumPaint.pointerId = null;
        drumPaint.track = null;
        drumPaint.visited.clear();
        setTimeout(clearDragHover, 40);
      };
      container.addEventListener("pointerup", end);
      container.addEventListener("pointercancel", end);
      container.addEventListener("lostpointercapture", () => {
        drumPaint.active = false;
        drumPaint.pointerId = null;
        drumPaint.track = null;
        drumPaint.visited.clear();
        setTimeout(clearDragHover, 40);
      });
    }

    /* ========= Piano Roll ========= */
    function isBlackKey(midi){
      const pc = midi % 12;
      return pc === 1 || pc === 3 || pc === 6 || pc === 8 || pc === 10;
    }
    function midiNameFlat(m){
      const pc = m % 12;
      const oct = Math.floor(m/12) - 1;
      const names = {0:"C",1:"Db",2:"D",3:"Eb",4:"E",5:"F",6:"Gb",7:"G",8:"Ab",9:"A",10:"Bb",11:"B"};
      return `${names[pc]}${oct}`;
    }
    function cssVar(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

    function getActiveGrid(){
      if (activeRoll === "bass") return project.bass;
      if (activeRoll === "synth") return project.synth;
      return project.piano;
    }
    function noteColor(){
      if (activeRoll === "bass") return cssVar("--bassNote");
      if (activeRoll === "synth") return cssVar("--synthNote");
      return cssVar("--pianoNote");
    }

    function drawRoll(playheadStep=-1){
      const W = rollCanvas.width, H = rollCanvas.height;
      const grid = getActiveGrid();

      const leftPad = KEY_PAD;
      const cellW = (W - leftPad) / LOOP_STEPS;
      const cellH = H / ROLL_PITCHES;

      g.clearRect(0,0,W,H);
      g.fillStyle = cssVar("--rollBg");
      g.fillRect(0,0,W,H);

      // rows
      for (let p=0; p<ROLL_PITCHES; p++){
        const midi = ROLL_BASE_MIDI + p;
        const y = H - (p+1)*cellH;
        g.fillStyle = isBlackKey(midi) ? "rgba(0,0,0,.22)" : (p%2===0 ? "rgba(255,255,255,.03)" : "rgba(255,255,255,.015)");
        g.fillRect(leftPad, y, W-leftPad, cellH);
      }

      // grid
      for (let s=0; s<=LOOP_STEPS; s++){
        const x = leftPad + s*cellW;
        g.strokeStyle = (s%4===0) ? cssVar("--gridBeat") : cssVar("--gridLine");
        g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke();
      }
      for (let p=0; p<=ROLL_PITCHES; p++){
        const y = p*cellH;
        g.strokeStyle = cssVar("--gridLine");
        g.beginPath(); g.moveTo(leftPad,y); g.lineTo(W,y); g.stroke();
      }

      // keys strip
      g.fillStyle = cssVar("--rollStrip");
      g.fillRect(0,0,leftPad,H);

      for (let p=0; p<ROLL_PITCHES; p++){
        const midi = ROLL_BASE_MIDI + p;
        const y = H - (p+1)*cellH;
        const black = isBlackKey(midi);

        if (!black){
          const grad = g.createLinearGradient(0,y,0,y+cellH);
          grad.addColorStop(0, cssVar("--whiteKeyA"));
          grad.addColorStop(1, cssVar("--whiteKeyB"));
          g.fillStyle = grad;
          g.fillRect(6, y+1, leftPad-12, cellH-2);
          g.strokeStyle = "rgba(0,0,0,.35)";
          g.strokeRect(6.5, y+1.5, leftPad-13, cellH-3);
          g.fillStyle = "rgba(0,0,0,.80)";
          g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
          g.fillText(midiNameFlat(midi), 12, y + cellH*0.68);
        } else {
          const grad = g.createLinearGradient(0,y,0,y+cellH);
          grad.addColorStop(0, cssVar("--blackKeyB"));
          grad.addColorStop(1, cssVar("--blackKeyA"));
          const insetLeft = 22, insetRight = 20;
          g.fillStyle = grad;
          g.fillRect(insetLeft, y+2, leftPad - insetLeft - insetRight, cellH-4);
          g.strokeStyle = "rgba(255,255,255,.10)";
          g.strokeRect(insetLeft+0.5, y+2.5, leftPad - insetLeft - insetRight - 1, cellH-5);
          g.fillStyle = "rgba(255,255,255,.80)";
          g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
          g.fillText(midiNameFlat(midi), insetLeft+6, y + cellH*0.68);
        }
      }

      // notes
      for (let p=0; p<ROLL_PITCHES; p++){
        for (let s=0; s<LOOP_STEPS; s++){
          const len = grid[p][s];
          if (len <= 0) continue;
          const x = leftPad + s*cellW + 1;
          const y = H - (p+1)*cellH + 1;
          const w = (cellW * Math.min(len, LOOP_STEPS - s)) - 2;
          const h = cellH - 2;
          g.fillStyle = noteColor();
          g.fillRect(x,y,w,h);
          g.strokeStyle = "rgba(255,255,255,.18)";
          g.strokeRect(x+0.5,y+0.5,w-1,h-1);
        }
      }

      // playhead
      if (playheadStep >= 0){
        const x = leftPad + playheadStep*cellW;
        g.fillStyle = "rgba(255,255,255,.12)";
        g.fillRect(x,0,cellW,H);
      }
    }

    function rollHitTest(clientX, clientY){
      const rect = rollCanvas.getBoundingClientRect();
      const px = (clientX - rect.left) * (rollCanvas.width / rect.width);
      const py = (clientY - rect.top)  * (rollCanvas.height / rect.height);

      const W = rollCanvas.width, H = rollCanvas.height;
      const leftPad = KEY_PAD;
      const cellW = (W - leftPad) / LOOP_STEPS;
      const cellH = H / ROLL_PITCHES;

      const pitch = Math.floor((H - py) / cellH);
      if (pitch < 0 || pitch >= ROLL_PITCHES) return null;
      if (px < leftPad) return { area:"keys", pitch };
      const step = Math.floor((px - leftPad) / cellW);
      if (step < 0 || step >= LOOP_STEPS) return null;
      return { area:"grid", pitch, step };
    }

    function findCoveringNote(row, step){
      for (let s=0; s<MASTER_STEPS; s++){
        const len = row[s];
        if (len <= 0) continue;
        if (step >= s && step < s + len) return {start:s, len};
      }
      return null;
    }

    function midiToHz(midi){
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    function playTone(freq, time, dur, bus, wave, peak, cutoff){
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      const lp = ctx.createBiquadFilter();

      osc.type = wave;
      osc.frequency.setValueAtTime(freq, time);

      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(peak, time + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + dur + 0.06);

      lp.type = "lowpass";
      lp.frequency.setValueAtTime(cutoff, time);

      osc.connect(lp).connect(gain).connect(bus);
      osc.start(time);
      osc.stop(time + dur + 0.12);
    }

    async function previewMidi(midi){
      await ensureRunning();
      const now = ctx.currentTime + 0.001;

      if (activeRoll === "bass"){
        playTone(midiToHz(midi + transpose.bass), now, 0.12, bassBus, "triangle", 0.22, 1500);
        return;
      }
      if (activeRoll === "synth"){
        playTone(midiToHz(midi + transpose.synth), now, 0.12, synthBus, "sawtooth", 0.18, 5200);
        return;
      }
      playTone(midiToHz(midi + transpose.piano), now, 0.12, pianoBus, "square", 0.18, 4200);
    }

    function setNoteLenOnGrid(grid, pitch, start, len){
      const row = grid[pitch];
      len = Math.max(1, Math.min(len, MASTER_STEPS - start));
      clearOverlaps(row, start, len);
      row[start] = len;
    }

    let noteDrag = {active:false, pointerId:null, grid:null, pitch:0, start:0};

    rollCanvas.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      const hit = rollHitTest(e.clientX, e.clientY);
      if (!hit) return;

      const midi = ROLL_BASE_MIDI + hit.pitch;
      const grid = getActiveGrid();

      if (hit.area === "keys"){
        await previewMidi(midi);
        return;
      }

      const row = grid[hit.pitch];
      const existing = findCoveringNote(row, hit.step);
      if (existing){
        row[existing.start] = 0;
        drawRoll(isPlaying ? currentStep : -1);
        return;
      }

      await previewMidi(midi);
      setNoteLenOnGrid(grid, hit.pitch, hit.step, 1);

      noteDrag = {active:true, pointerId:e.pointerId, grid, pitch:hit.pitch, start:hit.step};
      rollCanvas.setPointerCapture(e.pointerId);
      drawRoll(isPlaying ? currentStep : -1);
    }, {passive:false});

    rollCanvas.addEventListener("pointermove", (e) => {
      if (!noteDrag.active || noteDrag.pointerId !== e.pointerId) return;
      e.preventDefault();
      const hit = rollHitTest(e.clientX, e.clientY);
      if (!hit || hit.area !== "grid") return;
      const len = Math.max(1, (hit.step - noteDrag.start) + 1);
      setNoteLenOnGrid(noteDrag.grid, noteDrag.pitch, noteDrag.start, len);
      drawRoll(isPlaying ? currentStep : -1);
    }, {passive:false});

    rollCanvas.addEventListener("pointerup", (e) => {
      if (noteDrag.pointerId !== e.pointerId) return;
      noteDrag.active=false;
      noteDrag.pointerId=null;
    });
    rollCanvas.addEventListener("pointercancel", () => {
      noteDrag.active=false;
      noteDrag.pointerId=null;
    });

    /* ========= Sound: drums ========= */
    function getNoiseBuffer(){
      if (noiseBuf) return noiseBuf;
      const len = ctx.sampleRate * 0.5;
      const b = ctx.createBuffer(1, len, ctx.sampleRate);
      const d = b.getChannelData(0);
      for (let i=0;i<len;i++) d[i] = Math.random()*2 - 1;
      noiseBuf = b;
      return b;
    }

    function playKick(time){
      const out = drumGains.kick;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(160, time);
      osc.frequency.exponentialRampToValueAtTime(50, time + 0.09);
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(1.0, time + 0.004);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.14);
      osc.connect(gain).connect(out);
      osc.start(time); osc.stop(time + 0.16);
    }
    function playSnare(time){
      const out = drumGains.snare;
      const src = ctx.createBufferSource();
      src.buffer = getNoiseBuffer();
      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(1800, time);
      bp.Q.setValueAtTime(0.8, time);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.9, time + 0.003);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.10);
      src.connect(bp).connect(gain).connect(out);
      src.start(time); src.stop(time + 0.12);
    }
    function playClap(time){
      const out = drumGains.clap;
      const src = ctx.createBufferSource();
      src.buffer = getNoiseBuffer();
      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(2200, time);
      bp.Q.setValueAtTime(0.7, time);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.55, time + 0.002);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.07);
      src.connect(bp).connect(gain).connect(out);
      src.start(time); src.stop(time + 0.09);
    }
    function playShaker(time){
      const out = drumGains.shaker;
      const src = ctx.createBufferSource();
      src.buffer = getNoiseBuffer();
      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(6500, time);
      bp.Q.setValueAtTime(1.2, time);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.22, time + 0.003);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.06);
      src.connect(bp).connect(gain).connect(out);
      src.start(time); src.stop(time + 0.08);
    }
    function playCH(time){
      const out = drumGains.ch;
      const src = ctx.createBufferSource();
      src.buffer = getNoiseBuffer();
      const hp = ctx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.setValueAtTime(7500, time);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.33, time + 0.002);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.04);
      src.connect(hp).connect(gain).connect(out);
      src.start(time); src.stop(time + 0.06);
    }
    function playOH(time){
      const out = drumGains.oh;
      const src = ctx.createBufferSource();
      src.buffer = getNoiseBuffer();
      const hp = ctx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.setValueAtTime(6800, time);
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.28, time + 0.003);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.18);
      src.connect(hp).connect(gain).connect(out);
      src.start(time); src.stop(time + 0.22);
    }

    /* ========= Transport ========= */
    let isPlaying=false, isPaused=false;
    let currentStep=0, nextNoteTime=0, timerId=null;
    const lookAhead=0.025;
    const scheduleAhead=0.12;

    function secondsPerStep(){
      // absolute BPM (16th notes)
      const quarter = 60 / bpm;
      return quarter / 4;
    }

    function scheduleStep(step, time){
      if (project.drums.kick[step])   playKick(time);
      if (project.drums.snare[step])  playSnare(time);
      if (project.drums.clap[step])   playClap(time);
      if (project.drums.shaker[step]) playShaker(time);
      if (project.drums.ch[step])     playCH(time);
      if (project.drums.oh[step])     playOH(time);

      for (let p=0; p<ROLL_PITCHES; p++){
        const len = project.piano[p][step];
        if (len>0) playTone(midiToHz((ROLL_BASE_MIDI+p)+transpose.piano), time, secondsPerStep()*len*0.98, pianoBus, "square", 0.18, 4200);
      }
      for (let p=0; p<ROLL_PITCHES; p++){
        const len = project.synth[p][step];
        if (len>0) playTone(midiToHz((ROLL_BASE_MIDI+p)+transpose.synth), time, secondsPerStep()*len*0.98, synthBus, "sawtooth", 0.15, 6000);
      }
      for (let p=0; p<ROLL_PITCHES; p++){
        const len = project.bass[p][step];
        if (len>0) playTone(midiToHz((ROLL_BASE_MIDI+p)+transpose.bass), time, secondsPerStep()*len*0.98, bassBus, "triangle", 0.24, 1500);
      }

      updatePlayheadUI(step);
      drawRoll(step);
    }

    function updatePlayheadUI(step){
      drumGridEl.querySelectorAll(".cell").forEach(c => c.classList.remove("playhead"));
      if (step < 0) return;
      drumGridEl.querySelectorAll(".rowSteps").forEach(row => {
        const cell = row.children[step];
        if (cell) cell.classList.add("playhead");
      });
    }

    function nextStep(){
      currentStep = (currentStep + 1) % LOOP_STEPS;
      nextNoteTime += secondsPerStep();
    }

    function tick(){
      while (nextNoteTime < ctx.currentTime + scheduleAhead){
        scheduleStep(currentStep, nextNoteTime);
        nextStep();
      }
      timerId = window.setTimeout(tick, lookAhead * 1000);
    }

    async function play(){
      await ensureRunning();
      isPlaying=true; isPaused=false;
      playBtn.disabled=true;
      pauseBtn.disabled=false;
      stopBtn.disabled=false;
      nextNoteTime = ctx.currentTime + 0.06;
      tick();
    }

    function pause(){
      isPaused=true; isPlaying=false;
      playBtn.disabled=false;
      pauseBtn.disabled=true;
      stopBtn.disabled=false;
      if (timerId){ clearTimeout(timerId); timerId=null; }
    }

    function stop(){
      isPlaying=false; isPaused=false;
      if (timerId){ clearTimeout(timerId); timerId=null; }
      currentStep=0;
      updatePlayheadUI(-1);
      drawRoll(-1);
      playBtn.disabled=false;
      pauseBtn.disabled=true;
      stopBtn.disabled=true;
    }

    function togglePlayPause(){
      if (isPlaying) pause();
      else play();
    }

    playBtn.addEventListener("click", () => { currentStep=0; play(); });
    pauseBtn.addEventListener("click", pause);
    stopBtn.addEventListener("click", stop);

    /* ========= Project buttons ========= */
    loadDemoBtn.addEventListener("click", async () => {
      try { await loadDemoFromMidiFolder(); }
      catch (e){
        console.warn("Demo MIDI load failed; using drum demo only.", e);
        setDemoDrums();
        buildDrumGrid();
        drawRoll(-1);
      }
    });

    clearProjectBtn.addEventListener("click", () => {
      stop();
      const fresh = makeEmptyProject();
      drumKeys.forEach(k => project.drums[k] = fresh.drums[k].slice());
      for (let p=0; p<ROLL_PITCHES; p++){
        project.piano[p] = fresh.piano[p].slice();
        project.synth[p] = fresh.synth[p].slice();
        project.bass[p]  = fresh.bass[p].slice();
      }
      buildDrumGrid();
      drawRoll(-1);
    });

    importMidiBtn.addEventListener("click", () => midiFileInput.click());
    midiFileInput.addEventListener("change", async () => {
      const file = midiFileInput.files && midiFileInput.files[0];
      if (!file) return;
      const arr = await file.arrayBuffer();
      const grid = getActiveGrid();
      await importMidiIntoGrid(arr, grid);
      drawRoll(isPlaying ? currentStep : -1);
      midiFileInput.value = "";
    });

    /* ========= Init ========= */
    bpm = 115;
    bpmEl.value = "115";
    bpmLabel.textContent = "115";

    resEl.value = "2"; // 1/64 on launch
    const opt = RES_OPTIONS[Number(resEl.value)];
    LOOP_STEPS = opt.steps;
    resLabel.textContent = opt.label;
    resText.textContent = opt.label;
    groupText2.textContent = opt.label;

    buildDrumGrid();
    drawRoll(-1);

    // auto demo load
    (async () => {
      try { await loadDemoFromMidiFolder(); }
      catch (e){
        console.warn("Auto demo MIDI load failed; using drum demo only.", e);
        setDemoDrums();
        buildDrumGrid();
        drawRoll(-1);
      }
    })();

  })();
  </script>
</body>
</html>
