<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Mini DAW — Drum Sequencer + Piano Roll</title>

  <style>
    :root{
      --bg0:#0b0f14;
      --bg1:#0e1522;
      --panel:#0f1621;
      --panel2:#0c131d;
      --line:#243244;
      --text:#e6edf3;
      --muted:#9fb3c8;
      --good:#39d98a;
      --warn:#f4d35e;
      --bad:#ff5c5c;

      --btn:#162133;
      --btn2:#1a2a43;

      --k-bg:#0b1018;
      --k-ring:#2a3c57;
      --k-fill:#e6edf3;
    }

    html,body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(1200px 800px at 40% 20%, #111f37 0%, var(--bg0) 45%, #05070a 100%);
    }

    #wrap{
      display:flex;
      flex-wrap:wrap;
      gap:16px;
      padding:16px;
      align-items:flex-start;
      justify-content:center;
    }

    .panel{
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(15,22,33,0.9);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }

    .hdr{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,0));
    }

    .hdr h2{
      margin:0;
      font-size:14px;
      letter-spacing:.2px;
      color:var(--text);
      font-weight:700;
    }

    .hdr .sub{
      font-size:12px;
      color:var(--muted);
    }

    .btn{
      appearance:none;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.05));
      color:var(--text);
      border-radius:10px;
      padding:7px 10px;
      font-size:12px;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(0,0,0,.02)); }
    .btn:active{ transform: translateY(1px); }

    .btn.small{ padding:5px 8px; border-radius:9px; font-size:11px; }
    .btn.primary{ border-color:#2b4d7a; background: linear-gradient(180deg, rgba(56,131,255,.25), rgba(56,131,255,.08)); }
    .btn.danger{ border-color:#7a2b2b; background: linear-gradient(180deg, rgba(255,92,92,.22), rgba(255,92,92,.07)); }

    .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .row.tight{ gap:8px; }
    .spacer{ flex:1; }

    .pill{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.15);
      color:var(--muted);
      white-space:nowrap;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px;
      padding:3px 6px;
      border-radius:7px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.15);
      color:var(--text);
    }

    .grid{
      display:grid;
      gap:12px;
      padding:12px;
    }

    /* ===== TRANSPORT / TOP ===== */
    #top{
      width:min(1220px, calc(100vw - 32px));
    }

    #transport{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      padding:12px;
    }

    .field{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background: rgba(0,0,0,.14);
    }
    .field label{ font-size:12px; color:var(--muted); }
    .field input[type="number"]{
      width:64px;
      background: transparent;
      border:1px solid var(--line);
      color:var(--text);
      border-radius:10px;
      padding:6px 8px;
      font-size:12px;
      outline:none;
    }

    /* ===== DRUMS ===== */
    #drums{
      width:min(1220px, calc(100vw - 32px));
    }

    .drumHeader{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      padding:12px;
      border-bottom:1px solid var(--line);
    }

    .drumGridWrap{
      padding:12px;
      overflow:hidden;
    }

    .drumGrid{
      display:grid;
      grid-template-columns: 140px 1fr;
      gap:10px;
      align-items:start;
    }

    .drumLabels{
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .drLabel{
      height:34px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:0 10px;
      border:1px solid var(--line);
      border-radius:12px;
      background: rgba(0,0,0,.14);
      user-select:none;
      touch-action:none;
    }

    .drLabel .name{
      font-size:12px;
      font-weight:800;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }

    .tag{
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color:rgba(255,255,255,.85);
    }

    .drSteps{
      overflow:hidden;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.10);
    }

    .drStepsInner{
      display:grid;
      grid-auto-flow: column;
      grid-auto-columns: 1fr;
      gap:0;
      width:100%;
      min-width:0;
    }

    .step{
      height:34px;
      border-right:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      touch-action:none;
      position:relative;
    }
    .step:last-child{ border-right:none; }

    .step::after{
      content:"";
      width:13px; height:13px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      transform: rotate(45deg);
      opacity:.6;
      transition: .08s ease;
    }

    .step.on::after{
      transform: rotate(0deg);
      border-radius:4px;
      opacity:1;
      background: rgba(255,255,255,.9);
    }

    .step.playing{
      outline:2px solid rgba(255,255,255,.25);
      outline-offset:-2px;
    }

    .step.dragHover{
      box-shadow: inset 0 0 0 999px rgba(255,255,255,.08);
    }

    /* group shading (every N steps) */
    .step.grpA{ background: rgba(255,255,255,.02); }
    .step.grpB{ background: rgba(255,255,255,.06); }
    .step.grpC{ background: rgba(255,255,255,.03); }
    .step.grpD{ background: rgba(255,255,255,.07); }

    /* ===== PIANO ROLL ===== */
    #roll{
      width:min(1220px, calc(100vw - 32px));
    }

    .rollHeader{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      padding:12px;
      border-bottom:1px solid var(--line);
    }

    .instBtns{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }

    .instBtn{
      border:1px solid var(--line);
      background: rgba(0,0,0,.14);
      border-radius:12px;
      padding:7px 10px;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      touch-action:none;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .instBtn .dot{
      width:10px; height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.35);
      border:1px solid rgba(255,255,255,.18);
    }
    .instBtn.active{
      border-color: rgba(255,255,255,.22);
      background: rgba(255,255,255,.10);
    }

    .rollWrap{
      padding:12px;
      overflow:auto;
    }

    .rollGrid{
      display:grid;
      grid-template-columns: 92px 1fr;
      gap:10px;
      min-width: 920px;
    }

    .keys{
      display:flex;
      flex-direction:column;
      gap:0;
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background: rgba(0,0,0,.12);
    }

    .key{
      height:24px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 8px;
      border-bottom:1px solid rgba(255,255,255,.06);
      user-select:none;
      touch-action:none;
      cursor:pointer;
      font-size:11px;
      font-weight:800;
    }
    .key:last-child{ border-bottom:none; }

    .key.white{ background: rgba(255,255,255,.06); color:#0b0f14; }
    .key.black{ background: rgba(0,0,0,.45); color:#e6edf3; }

    .rollSteps{
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background: rgba(0,0,0,.10);
      position:relative;
    }

    .rollStepsInner{
      display:grid;
      grid-template-columns: repeat(var(--steps), 1fr);
    }

    .cell{
      height:24px;
      border-right:1px solid rgba(255,255,255,.06);
      border-bottom:1px solid rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      touch-action:none;
      position:relative;
    }
    .cell:nth-child(var(--steps)n){ border-right:none; }

    .cell.grpA{ background: rgba(255,255,255,.01); }
    .cell.grpB{ background: rgba(255,255,255,.05); }
    .cell.grpC{ background: rgba(255,255,255,.02); }
    .cell.grpD{ background: rgba(255,255,255,.06); }

    .note{
      position:absolute;
      left:0;
      top:2px;
      bottom:2px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.22);
      opacity:.95;
      pointer-events:none;
    }

    /* ===== MIXER ===== */
    #mixer{
      width:min(1220px, calc(100vw - 32px));
    }

    .mixerWrap{
      padding:12px;
      overflow-x:auto;
    }

    .stripRow{
      display:flex;
      gap:12px;
      align-items:stretch;
      min-width: 980px;
    }

    .strip{
      width: 180px;
      border:1px solid var(--line);
      border-radius:16px;
      background: rgba(0,0,0,.12);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .stripTop{
      padding:10px 10px 8px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .stripTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      user-select:none;
      touch-action:none;
      cursor:default;
    }
    .stripTitle .left{
      display:flex; align-items:center; gap:8px;
      font-size:12px; font-weight:900;
      min-width:0;
    }
    .stripTitle .sw{
      width:10px; height:10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.35);
      flex:0 0 auto;
    }
    .stripTitle .nm{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .stripBtns{
      display:flex;
      gap:6px;
      align-items:center;
    }

    .miniBtn{
      width:34px;
      height:28px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.88);
      font-size:11px;
      font-weight:900;
      cursor:pointer;
      user-select:none;
      touch-action:none;
    }
    .miniBtn.on{
      background: rgba(255,255,255,.14);
      border-color: rgba(255,255,255,.22);
    }

    .stripBody{
      display:grid;
      grid-template-columns: 56px 1fr; /* fader column + knobs column */
      gap:10px;
      padding:10px;
      align-items:start;
    }

    .faderCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      min-width:0;
    }

    .fader{
      -webkit-appearance:none;
      appearance:none;
      width: 120px;
      height: 24px;
      transform: rotate(-90deg);
      border-radius:999px;
      background: rgba(255,255,255,.12);
      outline:none;
      cursor:pointer;
    }
    .fader::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:16px; height:16px;
      border-radius:999px;
      background: rgba(255,255,255,.9);
      border:1px solid rgba(0,0,0,.2);
    }
    .fader::-moz-range-thumb{
      width:16px; height:16px;
      border-radius:999px;
      background: rgba(255,255,255,.9);
      border:1px solid rgba(0,0,0,.2);
    }

    .fval{
      font-size:11px;
      color:var(--muted);
      text-align:center;
      width:100%;
    }

    /* === FIX: Knob alignment (PAN, LPF, VERB stacked vertically) === */
    .stripKnobs{
      /* Stack PAN / LPF / VERB vertically, in a consistent top-to-bottom order */
      display:grid;
      grid-auto-flow: row;
      grid-template-rows: repeat(3, auto);
      gap: 10px;
      align-items: start;
      justify-items: center;
      align-content: start;
      min-width: 0;
    }

    .kCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      min-width:0;
    }
    .kLab{
      font-size:10px;
      color:var(--muted);
      letter-spacing:.4px;
      font-weight:900;
      text-transform:uppercase;
    }

    .knob{
      width:42px; height:42px;
      border-radius:999px;
      background: radial-gradient(20px 20px at 30% 30%, rgba(255,255,255,.10), rgba(0,0,0,.18));
      border:1px solid rgba(255,255,255,.12);
      position:relative;
      cursor:pointer;
      user-select:none;
      touch-action:none;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.20);
    }
    .knob .ring{
      position:absolute;
      inset:7px;
      border-radius:999px;
      border:2px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.18);
    }
    .knob .needle{
      position:absolute;
      left:50%;
      top:50%;
      width:2px;
      height:16px;
      background: rgba(255,255,255,.9);
      transform-origin: 50% 100%;
      transform: translate(-50%,-100%) rotate(0deg);
      border-radius:2px;
      box-shadow: 0 0 0 1px rgba(0,0,0,.25);
    }

    /* ===== MODALS ===== */
    .modalBackdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:50;
    }
    .modalBackdrop.show{ display:flex; }

    .modal{
      width:min(900px, 100%);
      max-height:min(90vh, 900px);
      overflow:hidden;
      border:1px solid var(--line);
      border-radius:18px;
      background: rgba(15,22,33,0.96);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      display:flex;
      flex-direction:column;
    }

    .modalHdr{
      padding:12px 14px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modalHdr h3{
      margin:0;
      font-size:13px;
      font-weight:900;
      letter-spacing:.2px;
    }

    .modalBody{
      padding:12px 14px;
      overflow:auto;
      display:grid;
      gap:12px;
    }

    .list{
      display:grid;
      gap:8px;
    }

    .listItem{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      background: rgba(0,0,0,.14);
      padding:10px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .listItem .meta{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
    }
    .listItem .meta .t{
      font-size:12px;
      font-weight:900;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .listItem .meta .s{
      font-size:11px;
      color:var(--muted);
    }

    .colorPop{
      position:fixed;
      inset:auto auto auto auto;
      z-index:60;
      display:none;
      background: rgba(15,22,33,0.96);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
      box-shadow: 0 18px 50px rgba(0,0,0,.6);
    }
    .colorPop.show{ display:block; }
    .colorPop input[type="color"]{
      width: 180px;
      height: 46px;
      border:none;
      background: transparent;
      padding:0;
      cursor:pointer;
    }

    @media (max-width: 760px){
      .drumGrid{ grid-template-columns: 1fr; }
      .drumLabels{ flex-direction:row; flex-wrap:wrap; }
      .drLabel{ width:calc(50% - 5px); }
      .rollGrid{ grid-template-columns: 84px 1fr; min-width: 780px; }
      .strip{ width: 172px; }
    }
  </style>
</head>

<body>
  <div id="wrap">

    <!-- TOP / TRANSPORT -->
    <section id="top" class="panel">
      <div class="hdr">
        <div>
          <h2>Mini DAW</h2>
          <div class="sub">Space = play/pause • Tap/drag to paint • MIDI demo + project save/load</div>
        </div>
        <div class="row tight">
          <span class="pill" id="statusPill">Stopped</span>
          <span class="kbd">Space</span>
        </div>
      </div>

      <div id="transport">
        <button class="btn primary" id="playBtn">Play</button>
        <button class="btn" id="stopBtn">Stop</button>

        <div class="field">
          <label for="bpm">BPM</label>
          <input id="bpm" type="number" min="40" max="240" step="1" value="115" />
        </div>

        <div class="field">
          <label>Resolution</label>
          <select id="resSel" class="btn" style="padding:6px 10px">
            <option value="16">1/16</option>
            <option value="32">1/32</option>
            <option value="64" selected>1/64</option>
          </select>
        </div>

        <span class="pill" id="resPill">1/64</span>

        <div class="spacer"></div>

        <button class="btn" id="loadBtn">Load</button>
        <button class="btn" id="saveBtn">Save</button>
        <button class="btn" id="importBtn">Import MIDI</button>
        <button class="btn" id="midiLibBtn">MIDI Library</button>
        <button class="btn" id="bgBtn">Background</button>
        <button class="btn danger" id="clearBtn">Clear</button>
      </div>
    </section>

    <!-- DRUMS -->
    <section id="drums" class="panel">
      <div class="hdr">
        <h2>Drum Sequencer</h2>
        <div class="sub">Paint steps (drag works) • Groups reflect current resolution</div>
      </div>

      <div class="drumHeader">
        <span class="pill" id="drInfo">Steps: 64</span>
        <span class="pill" id="drGroupInfo">Resolution: 1/64</span>
      </div>

      <div class="drumGridWrap">
        <div class="drumGrid" id="drumGrid"></div>
      </div>
    </section>

    <!-- PIANO ROLL -->
    <section id="roll" class="panel">
      <div class="hdr">
        <h2>Piano Roll</h2>
        <div class="sub">2+ octaves (C3–C5) • Sustain notes by dragging length • Tap keys to preview</div>
      </div>

      <div class="rollHeader">
        <div class="instBtns" id="instBtns"></div>

        <div class="spacer"></div>

        <!-- transpose knobs in header -->
        <span class="pill" id="transposePill">Transpose</span>
        <div id="transposeKnobs" class="row tight"></div>
      </div>

      <div class="rollWrap">
        <div class="rollGrid">
          <div class="keys" id="keys"></div>
          <div class="rollSteps" id="rollSteps">
            <div class="rollStepsInner" id="rollStepsInner"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- MIXER -->
    <section id="mixer" class="panel">
      <div class="hdr">
        <h2>Mixer</h2>
        <div class="sub">Vertical faders • Solo/Mute • PAN / LPF / VERB per channel</div>
      </div>

      <div class="mixerWrap">
        <div class="stripRow" id="stripRow"></div>
      </div>
    </section>

  </div>

  <!-- MIDI LIBRARY MODAL -->
  <div class="modalBackdrop" id="midiModalBack">
    <div class="modal">
      <div class="modalHdr">
        <h3>MIDI Library</h3>
        <div class="row tight">
          <span class="pill" id="targetLaneBadge">Target: Piano</span>
          <button class="btn small" id="midiModalClose">Close</button>
        </div>
      </div>

      <div class="modalBody">
        <div class="row">
          <span class="pill" id="midiPackInfo">Loading…</span>
          <span class="pill" id="midiFileStatus">Pick a MIDI to preview/import.</span>
        </div>
        <div class="list" id="midiList"></div>
      </div>
    </div>
  </div>

  <!-- color picker pop -->
  <div class="colorPop" id="colorPop">
    <div class="row" style="justify-content:space-between; margin-bottom:8px;">
      <span class="pill" id="colorPopTitle">Color</span>
      <button class="btn small" id="colorPopClose">Close</button>
    </div>
    <input type="color" id="colorPicker" value="#ffffff" />
  </div>

  <input id="fileInput" type="file" accept=".mid,.midi,application/json" style="display:none" />

  <!-- MIDI parser -->
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.min.js"></script>

  <script>
  // ============================================================
  // State / Constants
  // ============================================================
  const AudioContextClass = window.AudioContext || window.webkitAudioContext;
  const actx = new AudioContextClass();

  const statusPill = document.getElementById("statusPill");
  const playBtn = document.getElementById("playBtn");
  const stopBtn = document.getElementById("stopBtn");
  const bpmEl = document.getElementById("bpm");
  const resSel = document.getElementById("resSel");
  const resPill = document.getElementById("resPill");

  const loadBtn = document.getElementById("loadBtn");
  const saveBtn = document.getElementById("saveBtn");
  const importBtn = document.getElementById("importBtn");
  const clearBtn = document.getElementById("clearBtn");
  const bgBtn = document.getElementById("bgBtn");
  const midiLibBtn = document.getElementById("midiLibBtn");

  const drumGrid = document.getElementById("drumGrid");
  const drInfo = document.getElementById("drInfo");
  const drGroupInfo = document.getElementById("drGroupInfo");

  const instBtns = document.getElementById("instBtns");
  const transposeKnobs = document.getElementById("transposeKnobs");
  const keysEl = document.getElementById("keys");
  const rollStepsInner = document.getElementById("rollStepsInner");

  const stripRow = document.getElementById("stripRow");

  const midiModalBack = document.getElementById("midiModalBack");
  const midiModalClose = document.getElementById("midiModalClose");
  const midiPackInfo = document.getElementById("midiPackInfo");
  const midiList = document.getElementById("midiList");
  const midiFileStatus = document.getElementById("midiFileStatus");
  const targetLaneBadge = document.getElementById("targetLaneBadge");

  const fileInput = document.getElementById("fileInput");

  const colorPop = document.getElementById("colorPop");
  const colorPopClose = document.getElementById("colorPopClose");
  const colorPicker = document.getElementById("colorPicker");
  const colorPopTitle = document.getElementById("colorPopTitle");

  // 4 bars, base grid = 1/16 in "music land", but UI can be 1/16 1/32 1/64
  const BARS = 4;
  const BEATS_PER_BAR = 4;
  const STEPS_PER_BEAT_AT_16 = 4; // 1/16
  const BASE_STEPS_16 = BARS * BEATS_PER_BAR * STEPS_PER_BEAT_AT_16; // 64

  const RES_OPTIONS = [16,32,64];

  // Piano roll keys C3..C5 (inclusive)
  const PITCHES = [];
  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const MIDI_C3 = 48;
  const MIDI_C5 = 72;
  for(let m=MIDI_C5; m>=MIDI_C3; m--){
    PITCHES.push(m);
  }
  const isBlack = (midi)=> {
    const nn = NOTE_NAMES[midi%12];
    return nn.includes("#");
  }
  const midiToLabel = (m)=>{
    const n = NOTE_NAMES[m%12];
    const oct = Math.floor(m/12)-1;
    return `${n}${oct}`;
  }

  // Instruments / lanes
  const LANES = [
    { key:"bass",  label:"Bass",  color:"#3ddc97", osc:"triangle" },
    { key:"piano", label:"Piano", color:"#7aa7ff", osc:"sine" },
    { key:"synth", label:"Synth", color:"#ff7ad9", osc:"sawtooth" },
    { key:"pad",   label:"Pad",   color:"#ffd26a", osc:"square" },
    { key:"ep",    label:"EP",    color:"#6ff7ff", osc:"sine" },
    { key:"bell",  label:"Bell",  color:"#c8a6ff", osc:"sine" },
    { key:"poly",  label:"Poly",  color:"#ffb36a", osc:"sawtooth" }
  ];

  // Drum rows
  const DRUMS = [
    { key:"kick",   label:"Kick",   color:"#ff6b6b" },
    { key:"snare",  label:"Snare",  color:"#f4d35e" },
    { key:"clhat",  label:"Closed Hat", color:"#a0e7ff" },
    { key:"ophat",  label:"Open Hat",   color:"#6fa8ff" },
    { key:"shaker", label:"Shaker", color:"#7cffc4" },
    { key:"tom",    label:"Tom",    color:"#ff9d6b" },
    { key:"ride",   label:"Ride",   color:"#9ad06b" },
    { key:"crash",  label:"Crash",  color:"#d7d7d7" }
  ];

  // mixer channels: lanes + drum bus
  const CHANNELS = [
    ...LANES.map(l=>({ key:l.key, label:l.label, color:l.color, type:"inst" })),
    { key:"drums", label:"Drum Bus", color:"#c0c0c0", type:"bus" }
  ];

  // project state
  let state = {
    bpm: 115,
    resolution: 64,
    background: {
      a:"#111f37",
      b:"#0b0f14",
      c:"#05070a",
      x:40,
      y:20
    },

    colors: {
      lanes: Object.fromEntries(LANES.map(l=>[l.key,l.color])),
      drums: Object.fromEntries(DRUMS.map(d=>[d.key,d.color])),
      channels: Object.fromEntries(CHANNELS.map(c=>[c.key,c.color]))
    },

    transpose: Object.fromEntries(LANES.map(l=>[l.key,0])),

    drums: Object.fromEntries(DRUMS.map(d=>[d.key, new Set()])), // selected steps
    notes: Object.fromEntries(LANES.map(l=>[l.key, []])) // each note: {midi, start, len}
  };

  // UI selection
  let activeRoll = "piano";

  // Playback
  let playing = false;
  let nextTickId = null;
  let stepIndex = 0;
  let startTime = 0;

  // derived
  function stepsPerLoop(){
    const res = state.resolution;
    return (BASE_STEPS_16 * (res/16));
  }

  // ============================================================
  // Utilities
  // ============================================================
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function hexToRgb(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if(!m) return {r:255,g:255,b:255};
    return {r:parseInt(m[1],16), g:parseInt(m[2],16), b:parseInt(m[3],16)};
  }
  function luminance(hex){
    const {r,g,b} = hexToRgb(hex);
    const srgb=[r,g,b].map(v=>{
      v/=255;
      return v<=0.03928? v/12.92 : Math.pow((v+0.055)/1.055, 2.4);
    });
    return 0.2126*srgb[0]+0.7152*srgb[1]+0.0722*srgb[2];
  }
  function contrastText(bg){
    // simple: pick black/white based on luminance
    return luminance(bg) > 0.55 ? "#0b0f14" : "#e6edf3";
  }

  function setBodyBackground(){
    const bg = state.background;
    document.body.style.background =
      `radial-gradient(1200px 800px at ${bg.x}% ${bg.y}%, ${bg.a} 0%, ${bg.b} 45%, ${bg.c} 100%)`;
  }

  // ============================================================
  // Audio Graph
  // ============================================================
  const master = actx.createGain();
  master.gain.value = 0.9;
  master.connect(actx.destination);

  // Global reverb
  const reverb = actx.createConvolver();
  const reverbGain = actx.createGain();
  reverbGain.gain.value = 0.35;
  reverb.connect(reverbGain);
  reverbGain.connect(master);

  // simple impulse
  (function makeImpulse(){
    const len = actx.sampleRate * 1.2;
    const buf = actx.createBuffer(2, len, actx.sampleRate);
    for(let ch=0; ch<2; ch++){
      const d = buf.getChannelData(ch);
      for(let i=0;i<len;i++){
        d[i] = (Math.random()*2-1) * Math.pow(1 - i/len, 2.8);
      }
    }
    reverb.buffer = buf;
  })();

  // Channels
  const ch = {};
  for(const c of CHANNELS){
    const inGain = actx.createGain();
    const pan = actx.createStereoPanner();
    const filter = actx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 16000;
    const outGain = actx.createGain();
    const send = actx.createGain();
    send.gain.value = 0.0;

    inGain.connect(pan);
    pan.connect(filter);
    filter.connect(outGain);
    outGain.connect(master);

    // reverb send taps AFTER filter for a "DAW-ish" feel
    filter.connect(send);
    send.connect(reverb);

    ch[c.key] = { inGain, pan, filter, outGain, send };

    // defaults
    outGain.gain.value = 0.85;
    pan.pan.value = 0;
    filter.frequency.value = 16000;
    send.gain.value = 0.0;
  }

  // ============================================================
  // Synth helpers
  // ============================================================
  function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

  function triggerTone({midi, t, dur, laneKey}){
    const lane = LANES.find(l=>l.key===laneKey);
    const oscType = lane?.osc || "sine";
    const transpose = state.transpose[laneKey] || 0;
    const freq = midiToFreq(midi + transpose);

    const osc = actx.createOscillator();
    const g = actx.createGain();
    const f = actx.createBiquadFilter();
    f.type = "lowpass";
    f.frequency.value = 18000;

    osc.type = oscType;
    osc.frequency.setValueAtTime(freq, t);

    // ADSR-ish
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.55, t + 0.01);
    g.gain.linearRampToValueAtTime(0.42, t + Math.min(0.08, dur*0.2));
    g.gain.setValueAtTime(0.42, t + Math.max(0.01, dur-0.05));
    g.gain.linearRampToValueAtTime(0.0001, t + dur);

    osc.connect(f);
    f.connect(g);
    g.connect(ch[laneKey].inGain);

    osc.start(t);
    osc.stop(t + dur + 0.02);
  }

  // Drums (simple synthesized)
  function triggerDrum({key, t}){
    const out = ch["drums"].inGain;

    if(key==="kick"){
      const osc = actx.createOscillator();
      const g = actx.createGain();
      osc.type="sine";
      osc.frequency.setValueAtTime(140, t);
      osc.frequency.exponentialRampToValueAtTime(50, t+0.08);
      g.gain.setValueAtTime(0.9, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      osc.connect(g);
      g.connect(out);
      osc.start(t); osc.stop(t+0.14);
      return;
    }

    if(key==="snare"){
      const noise = actx.createBufferSource();
      const buf = actx.createBuffer(1, actx.sampleRate*0.2, actx.sampleRate);
      const d = buf.getChannelData(0);
      for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
      noise.buffer=buf;

      const hp = actx.createBiquadFilter();
      hp.type="highpass";
      hp.frequency.value=1200;

      const g = actx.createGain();
      g.gain.setValueAtTime(0.55, t);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.16);

      noise.connect(hp);
      hp.connect(g);
      g.connect(out);
      noise.start(t);
      noise.stop(t+0.18);
      return;
    }

    // hats/shaker/ride/crash -> noise bursts with filtering
    const isOpen = (key==="ophat" || key==="crash");
    const isRide = (key==="ride");
    const isTom  = (key==="tom");
    const isShaker = (key==="shaker");
    const noise = actx.createBufferSource();
    const lenSec = isOpen ? 0.35 : (isRide?0.22:(isTom?0.25:(isShaker?0.18:0.10)));
    const buf = actx.createBuffer(1, actx.sampleRate*lenSec, actx.sampleRate);
    const d = buf.getChannelData(0);
    for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    noise.buffer=buf;

    const bp = actx.createBiquadFilter();
    bp.type = isTom ? "bandpass" : "highpass";
    bp.frequency.value = isTom ? 220 : (isRide?7000:(isShaker?5200:8200));
    bp.Q.value = isTom ? 2.0 : 0.7;

    const g = actx.createGain();
    const a = isOpen ? 0.32 : 0.22;
    g.gain.setValueAtTime(a, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t+lenSec);

    noise.connect(bp);
    bp.connect(g);
    g.connect(out);

    noise.start(t);
    noise.stop(t+lenSec+0.02);
  }

  // ============================================================
  // Sequencing (ABSOLUTE BPM: resolution only changes loop length)
  // ============================================================
  function stepDurSeconds(){
    // base: one beat = 60/bpm
    const beat = 60 / state.bpm;

    // for a given resolution:
    // 1/16 => 4 steps per beat
    // 1/32 => 8 steps per beat
    // 1/64 => 16 steps per beat
    const stepsPerBeat = (state.resolution/4); // 16->4, 32->8, 64->16
    return beat / stepsPerBeat;
  }

  function loopDuration(){
    return stepsPerLoop() * stepDurSeconds();
  }

  function scheduleTick(){
    if(!playing) return;
    const sd = stepDurSeconds();
    const now = actx.currentTime;

    // schedule in small slices
    const lookahead = 0.12;

    while(startTime + stepIndex*sd < now + lookahead){
      const t = startTime + stepIndex*sd;

      // drums
      for(const d of DRUMS){
        if(state.drums[d.key].has(stepIndex)){
          triggerDrum({key:d.key, t});
        }
      }

      // notes
      for(const lane of LANES){
        for(const n of state.notes[lane.key]){
          if(n.start === stepIndex){
            const dur = n.len * sd;
            triggerTone({midi:n.midi, t, dur, laneKey: lane.key});
          }
        }
      }

      stepIndex = (stepIndex + 1) % stepsPerLoop();
      updatePlayheads();
    }

    nextTickId = requestAnimationFrame(scheduleTick);
  }

  function play(){
    if(playing) return;
    playing = true;
    statusPill.textContent = "Playing";
    statusPill.style.borderColor = "rgba(57,217,138,.45)";
    statusPill.style.background = "rgba(57,217,138,.12)";
    startTime = actx.currentTime + 0.03;
    stepIndex = 0;
    updatePlayheads(true);
    scheduleTick();
  }

  function stop(){
    playing = false;
    statusPill.textContent = "Stopped";
    statusPill.style.borderColor = "";
    statusPill.style.background = "";
    if(nextTickId) cancelAnimationFrame(nextTickId);
    nextTickId = null;
    clearPlayheads();
  }

  function togglePlay(){
    if(playing) stop();
    else play();
  }

  // ============================================================
  // UI: Build drums grid
  // ============================================================
  function groupClass(i){
    // 4-group coloring, but keep a repeating A/B/C/D for clarity
    const g = Math.floor(i/4) % 4;
    return g===0?"grpA":g===1?"grpB":g===2?"grpC":"grpD";
  }

  function rebuildDrums(){
    drumGrid.innerHTML = "";

    const steps = stepsPerLoop();
    drInfo.textContent = `Steps: ${steps}`;
    drGroupInfo.textContent = `Resolution: 1/${state.resolution}`;

    const labels = document.createElement("div");
    labels.className = "drumLabels";

    const stepsWrap = document.createElement("div");
    stepsWrap.className = "drSteps";

    const stepsInner = document.createElement("div");
    stepsInner.className = "drStepsInner";
    stepsInner.style.gridAutoColumns = `${100/steps}%`;

    // Create per drum row: label + steps row
    DRUMS.forEach((d, rowIdx)=>{
      const lab = document.createElement("div");
      lab.className = "drLabel";
      lab.dataset.kind = "drum";
      lab.dataset.key = d.key;

      const name = document.createElement("div");
      name.className = "name";
      const sw = document.createElement("span");
      sw.className = "tag";
      sw.textContent = "DR";
      const nm = document.createElement("span");
      nm.textContent = d.label;
      nm.style.color = contrastText(getDrumColor(d.key));
      nm.style.fontWeight = "900";
      name.appendChild(sw);
      name.appendChild(nm);

      lab.style.borderColor = "rgba(255,255,255,.10)";
      lab.style.background = "rgba(0,0,0,.14)";
      lab.style.boxShadow = `inset 0 0 0 2px ${hexWithAlpha(getDrumColor(d.key), .22)}`;

      labels.appendChild(lab);

      // row steps
      const row = document.createElement("div");
      row.style.display = "grid";
      row.style.gridAutoFlow = "column";
      row.style.gridAutoColumns = `${100/steps}%`;

      for(let i=0;i<steps;i++){
        const s = document.createElement("div");
        s.className = `step ${groupClass(i)}`;
        s.dataset.row = rowIdx;
        s.dataset.drum = d.key;
        s.dataset.step = i;

        if(state.drums[d.key].has(i)) s.classList.add("on");

        row.appendChild(s);
      }

      stepsInner.appendChild(row);
    });

    stepsWrap.appendChild(stepsInner);

    drumGrid.appendChild(labels);
    drumGrid.appendChild(stepsWrap);

    wireDrumPainting();
  }

  // ============================================================
  // Drum painting with drag (row-locked)
  // ============================================================
  let drumDrag = null; // { drumKey, mode: "add"|"remove" }

  function wireDrumPainting(){
    const stepsEl = drumGrid.querySelectorAll(".step");
    stepsEl.forEach(el=>{
      el.addEventListener("pointerdown", onDrumPointerDown);
      el.addEventListener("pointerenter", onDrumPointerEnter);
    });
    window.addEventListener("pointerup", onDrumPointerUp);
  }

  function onDrumPointerDown(e){
    e.preventDefault();
    const el = e.currentTarget;
    el.setPointerCapture?.(e.pointerId);
    const drumKey = el.dataset.drum;
    const step = +el.dataset.step;
    const set = state.drums[drumKey];

    const willAdd = !set.has(step);
    drumDrag = { drumKey, mode: willAdd ? "add":"remove" };

    applyDrumPaint(el, drumKey, step, drumDrag.mode);
  }

  function onDrumPointerEnter(e){
    if(!drumDrag) return;
    const el = e.currentTarget;
    const drumKey = el.dataset.drum;
    if(drumKey !== drumDrag.drumKey) return; // row-locked
    const step = +el.dataset.step;
    applyDrumPaint(el, drumKey, step, drumDrag.mode, true);
  }

  function onDrumPointerUp(){
    if(!drumDrag) return;
    drumDrag = null;
    drumGrid.querySelectorAll(".step.dragHover").forEach(el=>el.classList.remove("dragHover"));
  }

  function applyDrumPaint(el, drumKey, step, mode, hover=false){
    const set = state.drums[drumKey];
    if(mode==="add") set.add(step);
    else set.delete(step);

    // update UI in row
    const row = el.parentElement;
    const node = row.querySelector(`.step[data-step="${step}"]`);
    if(node){
      node.classList.toggle("on", set.has(step));
      if(hover) node.classList.add("dragHover");
    }
  }

  // ============================================================
  // Piano roll UI
  // ============================================================
  function rebuildInstrumentButtons(){
    instBtns.innerHTML = "";
    LANES.forEach(l=>{
      const b = document.createElement("button");
      b.className = "instBtn";
      b.dataset.kind = "lane";
      b.dataset.key = l.key;

      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = getLaneColor(l.key);

      const txt = document.createElement("span");
      txt.textContent = l.label;

      b.appendChild(dot);
      b.appendChild(txt);

      if(l.key===activeRoll) b.classList.add("active");
      applySelectedColorToButton(b, l.key, "lane");

      b.addEventListener("click", ()=>{
        activeRoll = l.key;
        rebuildInstrumentButtons();
        rebuildRoll();
        updateTargetLaneBadge();
      });

      instBtns.appendChild(b);
    });
  }

  function rebuildTransposeKnobs(){
    transposeKnobs.innerHTML = "";
    LANES.forEach(l=>{
      const wrap = document.createElement("div");
      wrap.className = "kCol";
      wrap.style.width = "62px";

      const k = makeKnob({
        label: l.label,
        min:-24,
        max:24,
        step:1,
        value: state.transpose[l.key] || 0,
        onChange:(v)=>{
          state.transpose[l.key] = v;
        }
      });
      wrap.appendChild(k);
      transposeKnobs.appendChild(wrap);
    });
  }

  function rebuildKeys(){
    keysEl.innerHTML = "";
    PITCHES.forEach(m=>{
      const k = document.createElement("div");
      k.className = "key " + (isBlack(m) ? "black":"white");
      k.dataset.midi = m;

      const label = midiToLabel(m);
      k.textContent = label;

      // preview
      k.addEventListener("pointerdown", (e)=>{
        e.preventDefault();
        previewKey(m);
      });

      keysEl.appendChild(k);
    });
  }

  let keyPreviewOsc = null;
  function previewKey(midi){
    stopKeyPreview();
    const t = actx.currentTime + 0.01;
    keyPreviewOsc = actx.createOscillator();
    const g = actx.createGain();
    keyPreviewOsc.type = "sine";
    keyPreviewOsc.frequency.value = midiToFreq(midi + (state.transpose[activeRoll]||0));
    g.gain.value = 0.22;
    keyPreviewOsc.connect(g);
    g.connect(ch[activeRoll].inGain);
    keyPreviewOsc.start(t);
    keyPreviewOsc.stop(t+0.22);
    keyPreviewOsc.onended = ()=>{ keyPreviewOsc=null; };
  }
  function stopKeyPreview(){
    try{ keyPreviewOsc?.stop(); }catch(_){}
    keyPreviewOsc=null;
  }

  function rebuildRoll(){
    rollStepsInner.innerHTML = "";
    const steps = stepsPerLoop();
    rollStepsInner.style.setProperty("--steps", steps);
    rollStepsInner.style.gridTemplateColumns = `repeat(${steps}, 1fr)`;

    // build cells row by row
    PITCHES.forEach((m, rIdx)=>{
      for(let i=0;i<steps;i++){
        const c = document.createElement("div");
        c.className = `cell ${groupClass(i)}`;
        c.dataset.midi = m;
        c.dataset.step = i;
        c.dataset.row = rIdx;
        rollStepsInner.appendChild(c);
      }
    });

    // draw notes
    drawNotes();

    // wire painting (supports sustain length)
    wireRollPainting();
  }

  function drawNotes(){
    // clear old
    rollStepsInner.querySelectorAll(".note").forEach(n=>n.remove());

    const notes = state.notes[activeRoll];
    const steps = stepsPerLoop();

    // map midi->rowIndex
    const pitchToRow = new Map();
    PITCHES.forEach((m, idx)=>pitchToRow.set(m, idx));

    for(const n of notes){
      const row = pitchToRow.get(n.midi);
      if(row==null) continue;

      const idx = row*steps + n.start;
      const cell = rollStepsInner.children[idx];
      if(!cell) continue;

      const div = document.createElement("div");
      div.className = "note";
      const laneColor = getLaneColor(activeRoll);
      div.style.background = hexWithAlpha(laneColor, .86);
      div.style.borderColor = hexWithAlpha(laneColor, .95);
      div.style.width = `calc(${(n.len)} * 100% + ${(n.len-1)}px)`;
      cell.appendChild(div);
    }
  }

  function normalizeNotes(){
    // clamp notes to loop
    const steps = stepsPerLoop();
    for(const lane of LANES){
      const arr = state.notes[lane.key];
      for(const n of arr){
        n.start = clamp(n.start, 0, steps-1);
        n.len = clamp(n.len, 1, steps - n.start);
      }
      // remove overlaps duplicates? keep as-is (user may want overlaps)
    }
  }

  // roll painting / resizing notes
  let rollDrag = null; // {midi, start, mode, noteRefIndex, startStep}
  function wireRollPainting(){
    const cells = rollStepsInner.querySelectorAll(".cell");
    cells.forEach(c=>{
      c.addEventListener("pointerdown", onRollDown);
      c.addEventListener("pointerenter", onRollEnter);
    });
    window.addEventListener("pointerup", onRollUp);
  }

  function findNoteAt(midi, step){
    const arr = state.notes[activeRoll];
    return arr.findIndex(n => n.midi===midi && step>=n.start && step<(n.start+n.len));
  }

  function onRollDown(e){
    e.preventDefault();
    const el = e.currentTarget;
    el.setPointerCapture?.(e.pointerId);

    const midi = +el.dataset.midi;
    const step = +el.dataset.step;

    const arr = state.notes[activeRoll];
    const idx = findNoteAt(midi, step);

    if(idx>=0){
      // remove note
      arr.splice(idx,1);
      rollDrag = { mode:"remove" };
      drawNotes();
      return;
    }

    // add new note; drag to extend length
    const note = { midi, start: step, len: 1 };
    arr.push(note);
    rollDrag = { mode:"add", midi, start, noteRef: note, startStep: step };
    drawNotes();
  }

  function onRollEnter(e){
    if(!rollDrag || rollDrag.mode!=="add") return;
    const el = e.currentTarget;
    const midi = +el.dataset.midi;
    const step = +el.dataset.step;

    if(midi !== rollDrag.midi) return;
    const steps = stepsPerLoop();
    const len = clamp(step - rollDrag.startStep + 1, 1, steps-rollDrag.startStep);
    rollDrag.noteRef.len = len;
    drawNotes();
  }

  function onRollUp(){
    if(!rollDrag) return;
    rollDrag = null;
    normalizeNotes();
    drawNotes();
  }

  // ============================================================
  // Playheads
  // ============================================================
  function clearPlayheads(){
    drumGrid.querySelectorAll(".step.playing").forEach(el=>el.classList.remove("playing"));
  }
  function updatePlayheads(reset=false){
    if(reset) clearPlayheads();
    const steps = stepsPerLoop();

    // drums highlight column in each row
    drumGrid.querySelectorAll(".drStepsInner > div").forEach(row=>{
      row.querySelectorAll(".step.playing").forEach(el=>el.classList.remove("playing"));
      const el = row.querySelector(`.step[data-step="${stepIndex}"]`);
      if(el) el.classList.add("playing");
    });
  }

  // ============================================================
  // Colors (customizable via color wheel)
  // ============================================================
  function getLaneColor(key){ return state.colors.lanes[key] || LANES.find(l=>l.key===key)?.color || "#7aa7ff"; }
  function getDrumColor(key){ return state.colors.drums[key] || DRUMS.find(d=>d.key===key)?.color || "#ff6b6b"; }
  function getChannelColor(key){ return state.colors.channels[key] || CHANNELS.find(c=>c.key===key)?.color || "#c0c0c0"; }

  function hexWithAlpha(hex,a){
    const {r,g,b} = hexToRgb(hex);
    return `rgba(${r},${g},${b},${a})`;
  }

  function applySelectedColorToButton(btn, key, kind){
    // kind: lane|drum
    const col = kind==="lane" ? getLaneColor(key) : getDrumColor(key);
    if(btn.classList.contains("active")){
      btn.style.background = hexWithAlpha(col, .22);
      btn.style.borderColor = hexWithAlpha(col, .55);
      btn.style.boxShadow = `inset 0 0 0 2px ${hexWithAlpha(col, .18)}`;
    }else{
      btn.style.background = "rgba(0,0,0,.14)";
      btn.style.borderColor = "var(--line)";
      btn.style.boxShadow = "";
    }
    btn.style.color = "var(--text)";
  }

  // Double click/tap color pop
  let colorTarget = null; // {kind, key, applyFn}
  let lastTap = {t:0, key:""};

  function setupColorWheel(){
    // drums labels
    drumGrid.addEventListener("pointerdown", (e)=>{
      const lab = e.target.closest(".drLabel");
      if(!lab) return;
      const key = lab.dataset.key;
      const now = performance.now();
      const id = `drum:${key}`;
      if(now - lastTap.t < 320 && lastTap.key === id){
        openColorPop(e.clientX, e.clientY, `Drum: ${DRUMS.find(d=>d.key===key)?.label||key}`, getDrumColor(key), (hex)=>{
          state.colors.drums[key] = hex;
          rebuildDrums();
          rebuildMixer();
        });
      }
      lastTap = {t:now, key:id};
    });

    // instrument buttons
    instBtns.addEventListener("pointerdown", (e)=>{
      const b = e.target.closest(".instBtn");
      if(!b) return;
      const key = b.dataset.key;
      const now = performance.now();
      const id = `lane:${key}`;
      if(now - lastTap.t < 320 && lastTap.key === id){
        openColorPop(e.clientX, e.clientY, `Instrument: ${LANES.find(l=>l.key===key)?.label||key}`, getLaneColor(key), (hex)=>{
          state.colors.lanes[key] = hex;
          rebuildInstrumentButtons();
          rebuildRoll();
          rebuildMixer();
        });
      }
      lastTap = {t:now, key:id};
    });

    // mixer strip titles
    stripRow.addEventListener("pointerdown", (e)=>{
      const st = e.target.closest(".stripTitle");
      if(!st) return;
      const key = st.dataset.key;
      const now = performance.now();
      const id = `ch:${key}`;
      if(now - lastTap.t < 320 && lastTap.key === id){
        openColorPop(e.clientX, e.clientY, `Channel: ${CHANNELS.find(c=>c.key===key)?.label||key}`, getChannelColor(key), (hex)=>{
          state.colors.channels[key] = hex;
          rebuildMixer();
        });
      }
      lastTap = {t:now, key:id};
    });
  }

  function openColorPop(x,y,title,initial,applyFn){
    colorPopTitle.textContent = title;
    colorPicker.value = initial;
    colorPop.style.left = clamp(x-90, 12, window.innerWidth-220) + "px";
    colorPop.style.top  = clamp(y+10, 12, window.innerHeight-90) + "px";
    colorPop.classList.add("show");
    colorTarget = {applyFn};
  }

  colorPicker.addEventListener("input", ()=>{
    if(!colorTarget) return;
    colorTarget.applyFn(colorPicker.value);
  });
  colorPopClose.addEventListener("click", ()=>{
    colorPop.classList.remove("show");
    colorTarget=null;
  });

  // ============================================================
  // Mixer UI
  // ============================================================
  function makeKnob({label,min,max,step,value,onChange}){
    const wrap = document.createElement("div");
    wrap.className = "kCol";
    const k = document.createElement("div");
    k.className = "knob";
    const ring = document.createElement("div");
    ring.className = "ring";
    const needle = document.createElement("div");
    needle.className = "needle";
    k.appendChild(ring);
    k.appendChild(needle);

    const lab = document.createElement("div");
    lab.className = "kLab";
    lab.textContent = label;

    // angle mapping -135..135
    function setNeedle(v){
      const t = (v-min)/(max-min);
      const ang = -135 + t*270;
      needle.style.transform = `translate(-50%,-100%) rotate(${ang}deg)`;
    }
    setNeedle(value);

    let dragging = false;
    let startY=0;
    let startVal=value;

    const getV = ()=>value;
    const setV = (v)=>{
      v = Math.round(v/step)*step;
      v = clamp(v, min, max);
      value = v;
      setNeedle(v);
      onChange?.(v);
    };

    k.addEventListener("pointerdown", (e)=>{
      e.preventDefault();
      dragging=true;
      startY = e.clientY;
      startVal = getV();
      k.setPointerCapture?.(e.pointerId);
    });
    k.addEventListener("pointermove", (e)=>{
      if(!dragging) return;
      const dy = startY - e.clientY;
      const span = (max-min);
      const delta = (dy/120) * span;
      setV(startVal + delta);
    });
    window.addEventListener("pointerup", ()=> dragging=false);

    wrap.appendChild(lab);
    wrap.appendChild(k);
    return wrap;
  }

  function rebuildMixer(){
    stripRow.innerHTML = "";
    CHANNELS.forEach(c=>{
      const strip = document.createElement("div");
      strip.className = "strip";

      const top = document.createElement("div");
      top.className = "stripTop";

      const title = document.createElement("div");
      title.className = "stripTitle";
      title.dataset.key = c.key;

      const left = document.createElement("div");
      left.className = "left";
      const sw = document.createElement("span");
      sw.className = "sw";
      sw.style.background = hexWithAlpha(getChannelColor(c.key), .65);
      const nm = document.createElement("span");
      nm.className = "nm";
      nm.textContent = c.label;
      nm.style.color = contrastText(getChannelColor(c.key));
      left.appendChild(sw);
      left.appendChild(nm);

      const btns = document.createElement("div");
      btns.className = "stripBtns";

      const solo = document.createElement("button");
      solo.className = "miniBtn";
      solo.textContent = "S";
      solo.dataset.key = c.key;
      solo.dataset.type = "solo";

      const mute = document.createElement("button");
      mute.className = "miniBtn";
      mute.textContent = "M";
      mute.dataset.key = c.key;
      mute.dataset.type = "mute";

      btns.appendChild(solo);
      btns.appendChild(mute);

      title.appendChild(left);
      title.appendChild(btns);

      top.appendChild(title);

      const body = document.createElement("div");
      body.className = "stripBody";

      const faderCol = document.createElement("div");
      faderCol.className = "faderCol";

      const fader = document.createElement("input");
      fader.type = "range";
      fader.min = "0";
      fader.max = "1";
      fader.step = "0.01";
      fader.value = ch[c.key].outGain.gain.value;
      fader.className = "fader";

      const fval = document.createElement("div");
      fval.className = "fval";
      fval.textContent = Math.round(ch[c.key].outGain.gain.value*100);

      fader.addEventListener("input", ()=>{
        const v = +fader.value;
        ch[c.key].outGain.gain.value = v;
        fval.textContent = Math.round(v*100);
      });

      faderCol.appendChild(fader);
      faderCol.appendChild(fval);

      const knobs = document.createElement("div");
      knobs.className = "stripKnobs";

      const panK = makeKnob({
        label:"PAN",
        min:-1, max:1, step:0.01,
        value: ch[c.key].pan.pan.value,
        onChange:(v)=> ch[c.key].pan.pan.value = v
      });
      const lpfK = makeKnob({
        label:"LPF",
        min: 200, max: 16000, step: 1,
        value: ch[c.key].filter.frequency.value,
        onChange:(v)=> ch[c.key].filter.frequency.value = v
      });
      const verbK = makeKnob({
        label:"VERB",
        min:0, max:1, step:0.01,
        value: ch[c.key].send.gain.value,
        onChange:(v)=> ch[c.key].send.gain.value = v
      });

      knobs.appendChild(panK);
      knobs.appendChild(lpfK);
      knobs.appendChild(verbK);

      body.appendChild(faderCol);
      body.appendChild(knobs);

      strip.appendChild(top);
      strip.appendChild(body);

      stripRow.appendChild(strip);
    });

    wireSoloMute();
  }

  let soloState = Object.fromEntries(CHANNELS.map(c=>[c.key,false]));
  let muteState = Object.fromEntries(CHANNELS.map(c=>[c.key,false]));

  function applySoloMute(){
    const anySolo = Object.values(soloState).some(v=>v);
    CHANNELS.forEach(c=>{
      const g = ch[c.key].outGain.gain;
      const base = +document.querySelector(`.stripTitle[data-key="${c.key}"]`) ? ch[c.key].outGain.gain.value : g.value;
      // We don't have a separate "base" store; instead use current slider.
      const slider = document.querySelector(`.stripTitle[data-key="${c.key}"]`)?.closest(".strip")?.querySelector(".fader");
      const baseVal = slider ? +slider.value : g.value;

      const muted = muteState[c.key];
      const soloed = soloState[c.key];

      let v = baseVal;
      if(anySolo && !soloed) v = 0;
      if(muted) v = 0;

      g.value = v;
    });
  }

  function wireSoloMute(){
    stripRow.querySelectorAll(".miniBtn").forEach(b=>{
      b.addEventListener("click", ()=>{
        const key = b.dataset.key;
        const type = b.dataset.type;
        if(type==="solo"){
          soloState[key] = !soloState[key];
          b.classList.toggle("on", soloState[key]);
        }else{
          muteState[key] = !muteState[key];
          b.classList.toggle("on", muteState[key]);
        }
        applySoloMute();
      });
    });
  }

  // ============================================================
  // Background control
  // ============================================================
  bgBtn.addEventListener("click", ()=>{
    // quick + simple: cycle a few nice gradients
    const presets = [
      {a:"#111f37", b:"#0b0f14", c:"#05070a", x:40, y:20},
      {a:"#2a1138", b:"#0b0f14", c:"#030305", x:50, y:30},
      {a:"#11382a", b:"#0b0f14", c:"#05070a", x:30, y:20},
      {a:"#2a2f4a", b:"#0b0f14", c:"#05070a", x:50, y:10},
    ];
    const cur = JSON.stringify(state.background);
    let idx = presets.findIndex(p=>JSON.stringify(p)===cur);
    idx = (idx+1) % presets.length;
    state.background = presets[idx];
    setBodyBackground();
  });

  // ============================================================
  // Save / Load / Clear
  // ============================================================
  function serialize(){
    // convert Sets to arrays
    const drums = {};
    for(const d of DRUMS){
      drums[d.key] = Array.from(state.drums[d.key]).sort((a,b)=>a-b);
    }
    return {
      bpm: state.bpm,
      resolution: state.resolution,
      background: state.background,
      colors: state.colors,
      transpose: state.transpose,
      drums,
      notes: state.notes
    };
  }

  function loadFrom(obj){
    if(!obj) return;

    state.bpm = obj.bpm ?? state.bpm;
    state.resolution = obj.resolution ?? state.resolution;
    state.background = obj.background ?? state.background;

    state.colors = obj.colors ?? state.colors;
    state.transpose = obj.transpose ?? state.transpose;

    // drums
    const dmap = {};
    for(const d of DRUMS){
      const arr = (obj.drums && obj.drums[d.key]) ? obj.drums[d.key] : [];
      dmap[d.key] = new Set(arr);
    }
    state.drums = dmap;

    // notes
    const nmap = {};
    for(const l of LANES){
      nmap[l.key] = (obj.notes && obj.notes[l.key]) ? obj.notes[l.key].map(n=>({...n})) : [];
    }
    state.notes = nmap;

    // reflect UI
    bpmEl.value = state.bpm;
    resSel.value = String(state.resolution);
    resPill.textContent = `1/${state.resolution}`;
    setBodyBackground();

    rebuildAll();
  }

  saveBtn.addEventListener("click", ()=>{
    const data = serialize();
    const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "project.json";
    a.click();
    URL.revokeObjectURL(a.href);
  });

  loadBtn.addEventListener("click", ()=>{
    fileInput.accept = "application/json";
    fileInput.click();
    fileInput.onchange = async ()=>{
      const f = fileInput.files?.[0];
      if(!f) return;
      const txt = await f.text();
      const obj = JSON.parse(txt);
      loadFrom(obj);
      fileInput.value = "";
    };
  });

  clearBtn.addEventListener("click", ()=>{
    stop();
    // reset state but keep colors/background
    const keepColors = state.colors;
    const keepBg = state.background;
    const keepTranspose = state.transpose;

    state = {
      bpm: state.bpm,
      resolution: state.resolution,
      background: keepBg,
      colors: keepColors,
      transpose: keepTranspose,
      drums: Object.fromEntries(DRUMS.map(d=>[d.key, new Set()])),
      notes: Object.fromEntries(LANES.map(l=>[l.key, []]))
    };
    rebuildAll();
  });

  // ============================================================
  // MIDI Import + Demo
  // ============================================================
  importBtn.addEventListener("click", ()=>{
    fileInput.accept = ".mid,.midi";
    fileInput.click();
    fileInput.onchange = async ()=>{
      const f = fileInput.files?.[0];
      if(!f) return;
      const ab = await f.arrayBuffer();
      importMidiArrayBufferToActiveLane(ab);
      fileInput.value = "";
    };
  });

  function quantizeToSteps(seconds){
    const sd = stepDurSeconds();
    return Math.round(seconds / sd);
  }

  function importMidiArrayBufferToActiveLane(arrayBuffer, {fit=true} = {}){
    if (!window.Midi){
      alert("MIDI parser failed to load.");
      return;
    }
    const midi = new Midi(arrayBuffer);

    // Auto-detect lane suggestion (non-intrusive): show hint, do NOT switch lanes automatically.
    try{
      const suggested = suggestLaneForMidi(midi);
      if (suggested && suggested !== activeRoll && midiFileStatus){
        const current = laneLabel(activeRoll);
        midiFileStatus.textContent = `Imported MIDI detected as ${laneLabel(suggested)}-range; keeping target lane: ${current}.`;
      }
    }catch(_){}

    // Collect notes from all tracks
    const notes = [];
    midi.tracks.forEach(tr=>{
      tr.notes.forEach(n=>notes.push(n));
    });

    if(!notes.length) return;

    // Convert to our grid: step start + length (in steps)
    const steps = stepsPerLoop();
    const sd = stepDurSeconds();

    // Determine span in seconds and map into loop if fit
    const maxEnd = Math.max(...notes.map(n=>n.time+n.duration));
    const fitScale = fit ? (loopDuration() / maxEnd) : 1;

    const laneArr = state.notes[activeRoll];
    for(const n of notes){
      const t = n.time * fitScale;
      const d = n.duration * fitScale;
      let s = Math.max(0, Math.round(t/sd));
      let l = Math.max(1, Math.round(d/sd));
      if(s>=steps) continue;
      l = clamp(l, 1, steps - s);
      laneArr.push({ midi: n.midi, start: s, len: l });
    }

    // sort by start then midi
    laneArr.sort((a,b)=>a.start-b.start || a.midi-b.midi);

    rebuildRoll();
  }

  // Load demo from /demos/demo01.json
  async function loadDefaultDemo(){
    try{
      const r = await fetch("./demos/demo01.json", {cache:"no-store"});
      if(!r.ok) throw new Error("no demo01.json");
      const obj = await r.json();
      loadFrom(obj);
    }catch(e){
      // if demo missing, just build UI defaults
      rebuildAll();
    }
  }

  // ============================================================
  // MIDI Library (loads /midi directory packs via midi_index.json)
  // ============================================================
  midiLibBtn.addEventListener("click", openMidiLibrary);
  midiModalClose.addEventListener("click", closeMidiLibrary);
  midiModalBack.addEventListener("click", (e)=>{
    if(e.target === midiModalBack) closeMidiLibrary();
  });

  function updateTargetLaneBadge(){
    const lab = LANES.find(l=>l.key===activeRoll)?.label || "Piano";
    targetLaneBadge.textContent = `Target: ${lab}`;
  }

  async function openMidiLibrary(){
    updateTargetLaneBadge();
    midiModalBack.classList.add("show");
    await loadMidiIndexAndRender();
  }
  function closeMidiLibrary(){
    stopPreview();
    midiModalBack.classList.remove("show");
  }

  let midiIndex = null;
  let previewTimer = null;

  function stopPreview(){
    if(previewTimer){
      clearTimeout(previewTimer);
      previewTimer = null;
    }
  }

  async function loadMidiIndexAndRender(){
    midiPackInfo.textContent = "Loading…";
    midiList.innerHTML = "";
    midiFileStatus.textContent = "Pick a MIDI to preview/import.";

    try{
      // Expect a generated index at /midi/midi_index.json
      const r = await fetch("./midi/midi_index.json", {cache:"no-store"});
      if(!r.ok) throw new Error("Missing midi_index.json");
      midiIndex = await r.json();
      renderMidiLibrary(midiIndex);
    }catch(err){
      midiPackInfo.textContent = "No library index found. Add /midi/midi_index.json";
      midiList.innerHTML = "";
    }
  }

  function renderMidiLibrary(idx){
    const packs = idx.packs || [];
    midiPackInfo.textContent = `${packs.length} folder(s)`;

    midiList.innerHTML = "";
    for(const p of packs){
      const header = document.createElement("div");
      header.className = "pill";
      header.textContent = p.name || p.folder;
      midiList.appendChild(header);

      for(const f of (p.files||[])){
        const item = document.createElement("div");
        item.className = "listItem";

        const meta = document.createElement("div");
        meta.className = "meta";
        const t = document.createElement("div");
        t.className = "t";
        t.textContent = f.name || f.file;
        const s = document.createElement("div");
        s.className = "s";
        s.textContent = `• ${f.bpm ? f.bpm+" BPM" : "MIDI"} • ${f.bars ? f.bars+" bars" : "loop"}`;
        meta.appendChild(t);
        meta.appendChild(s);

        const actions = document.createElement("div");
        actions.className = "row tight";
        const prev = document.createElement("button");
        prev.className = "btn small";
        prev.textContent = "Preview";
        prev.addEventListener("click", ()=> previewMidiFromLibrary(p, f));

        const imp = document.createElement("button");
        imp.className = "btn small primary";
        imp.textContent = "Import";
        imp.addEventListener("click", ()=> importMidiFromLibrary(p, f));

        actions.appendChild(prev);
        actions.appendChild(imp);

        item.appendChild(meta);
        item.appendChild(actions);
        midiList.appendChild(item);
      }
    }
  }

  function buildMidiPath(pack, file){
    // pack.folder + file.file relative to /midi
    const folder = pack.folder || pack.name || "";
    return `./midi/${folder}/${file.file || file.name}`;
  }

  // ---------- Auto-detect lane suggestion (lightweight heuristics) ----------
  // Goal: suggest a lane based on MIDI pitch range + chord density, without changing user selection.
  function suggestLaneForMidi(midi){
    const notes = [];
    midi.tracks.forEach(tr => (tr.notes||[]).forEach(n => notes.push(n)));
    if (!notes.length) return "piano";

    // basic pitch stats
    const midis = notes.map(n => n.midi).sort((a,b)=>a-b);
    const avg = midis.reduce((a,b)=>a+b,0) / midis.length;
    const low = midis[0], high = midis[midis.length-1];

    // estimate chord density: sample overlaps via simple sweep
    const events = [];
    for (const n of notes){
      const s = n.time;
      const e = n.time + (n.duration || 0);
      events.push([s, +1]);
      events.push([e, -1]);
    }
    events.sort((a,b)=>a[0]-b[0] || b[1]-a[1]);
    let active=0, maxActive=0;
    for (const [t, delta] of events){
      active += delta;
      if (active > maxActive) maxActive = active;
    }

    // Heuristics:
    // - Very low average or low range -> Bass
    if (avg < 54 || high <= 60) return "bass";

    // - Dense chords -> Piano (keeps it familiar; user can swap to Poly/Pad manually)
    if (maxActive >= 3) return "piano";

    // - High register / melodic -> Synth (lead lane)
    if (avg >= 70 || low >= 62) return "synth";

    // default
    return "piano";
  }

  function laneLabel(key){
    return (LANES.find(l=>l.key===key)?.label) || key;
  }

  async function fetchMidiArrayBuffer(path){
    const r = await fetch(path, {cache:"no-store"});
    if(!r.ok) throw new Error("Failed to fetch MIDI: "+path);
    return await r.arrayBuffer();
  }

  async function previewMidiFromLibrary(pack, file){
    try{
      midiFileStatus.textContent = `Loading preview…`;
      await ensureRunning();
      stopPreview();

      const ab = await fetchMidiArrayBuffer(buildMidiPath(pack, file));
      const midi = new Midi(ab);

      const suggested = suggestLaneForMidi(midi);
      const sugTxt = (suggested && suggested !== activeRoll)
        ? ` • Suggested lane: ${laneLabel(suggested)}`
        : "";

      // play first 1 bar quickly using current active lane sound
      const sd = stepDurSeconds();
      const now = actx.currentTime + 0.03;

      const notes = [];
      midi.tracks.forEach(tr=>tr.notes.forEach(n=>notes.push(n)));
      if(!notes.length){
        midiFileStatus.textContent = `No notes in file.`;
        return;
      }

      const maxEnd = Math.max(...notes.map(n=>n.time+n.duration));
      const fitScale = loopDuration() / maxEnd;

      notes.forEach(n=>{
        const t = now + (n.time*fitScale);
        const dur = Math.max(0.05, n.duration*fitScale);
        triggerTone({midi:n.midi, t, dur, laneKey: activeRoll});
      });

      midiFileStatus.textContent = `Previewing: ${file.name || file.file}${sugTxt}`;
      previewTimer = setTimeout(()=>{ midiFileStatus.textContent = `Pick a MIDI to preview/import.`; }, 1200);
    }catch(e){
      midiFileStatus.textContent = `Preview failed.`;
      console.warn(e);
    }
  }

  async function importMidiFromLibrary(pack, file){
    try{
      midiFileStatus.textContent = `Importing…`;
      const ab = await fetchMidiArrayBuffer(buildMidiPath(pack, file));

      let suggested = null;
      try{
        const midi = new Midi(ab);
        suggested = suggestLaneForMidi(midi);
      }catch(_){}
      const sugTxt = (suggested && suggested !== activeRoll)
        ? ` • Suggested lane: ${laneLabel(suggested)}`
        : "";

      importMidiArrayBufferToActiveLane(ab, {fit:true});
      midiFileStatus.textContent = `Imported into ${LANES.find(l=>l.key===activeRoll)?.label ?? "Piano"}: ${file.name || file.file}${sugTxt}`;
      setTimeout(()=>{ midiFileStatus.textContent = `Pick a MIDI to preview/import.`; }, 1400);
    }catch(e){
      midiFileStatus.textContent = `Import failed.`;
      console.warn(e);
    }
  }

  async function ensureRunning(){
    if(actx.state !== "running"){
      await actx.resume();
    }
  }

  // ============================================================
  // Drum demo pattern (kept in demo JSON normally)
  // ============================================================
  // (No changes here to avoid regressions as requested)

  // ============================================================
  // Events
  // ============================================================
  playBtn.addEventListener("click", async ()=>{
    await ensureRunning();
    togglePlay();
  });
  stopBtn.addEventListener("click", ()=> stop());

  bpmEl.addEventListener("input", ()=>{
    state.bpm = clamp(+bpmEl.value, 40, 240);
  });

  resSel.addEventListener("change", ()=>{
    // keep selections; just change timing/loop length
    state.resolution = +resSel.value;
    resPill.textContent = `1/${state.resolution}`;
    rebuildAll();
  });

  document.addEventListener("keydown", (e)=>{
    if(e.code==="Space"){
      e.preventDefault();
      togglePlay();
    }
  });

  // ============================================================
  // Build everything
  // ============================================================
  function rebuildAll(){
    rebuildDrums();
    rebuildInstrumentButtons();
    rebuildTransposeKnobs();
    rebuildKeys();
    rebuildRoll();
    rebuildMixer();
    setupColorWheel(); // safe (idempotent-ish in this version)
    updateTargetLaneBadge();
  }

  // init
  setBodyBackground();
  loadDefaultDemo();

  </script>
</body>
</html>
