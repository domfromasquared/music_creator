<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>RetroLoop Studio — Drum Sequencer + Piano Roll</title>

  <style>
    :root{
      --bg:#0f1115;
      --ink:#e9eef5;
      --muted:#97a3b6;

      --btn:#22283a;
      --btn2:#2a3150;
      --shadow: 0 10px 30px rgba(0,0,0,.35);

      --groupA:#121a28;
      --groupB:#211a2f;

      --inactiveOverlay: rgba(0,0,0,0.38);
      --playheadOutline: rgba(255,255,255,0.30);
      --beatDivider: rgba(255,255,255,0.18);
      --dragOutline: rgba(255,255,255,0.45);
      --dragFill: rgba(255,255,255,0.10);

      --userBg: #0f1115;

      --kick: #ff8b5a;
      --snare:#58a6ff;
      --clap: #ffffff;

      --shaker:#ba8cff;
      --ch:#7cffb2;
      --oh:#ffd278;

      --tom:#ff78c8;
      --ride:#78d2ff;
      --crash:#ff7878;

      --rollBg: rgba(0,0,0,.18);
      --rollStrip: rgba(0,0,0,.32);
      --gridLine: rgba(255,255,255,.06);
      --gridBeat: rgba(255,255,255,.14);

      --whiteKeyA: rgba(255,255,255,0.92);
      --whiteKeyB: rgba(255,255,255,0.82);
      --blackKeyA: rgba(12,14,20,0.98);
      --blackKeyB: rgba(22,24,32,0.98);
      --keyBorder: rgba(0,0,0,0.35);

      --rowWhiteA: rgba(255,255,255,.03);
      --rowWhiteB: rgba(255,255,255,.015);
      --rowBlack: rgba(0,0,0,.22);

      --pianoNote: rgba(124,255,178,.85);
      --epNote: rgba(255, 215, 120, .82);
      --polyNote: rgba(120, 255, 240, .76);
      --bellNote: rgba(255, 150, 230, .76);
      --synthNote: rgba(255,139,90,.78);
      --bassNote: rgba(88,166,255,.80);
      --padNote: rgba(186,140,255,.72);

      --knobBg: rgba(0,0,0,.30);

      --knobFillPiano: rgba(124,255,178,.95);
      --knobGlowPiano: rgba(124,255,178,.28);

      --knobFillEP: rgba(255, 215, 120, .95);
      --knobGlowEP: rgba(255, 215, 120, .24);

      --knobFillPoly: rgba(120,255,240,.95);
      --knobGlowPoly: rgba(120,255,240,.22);

      --knobFillBell: rgba(255,150,230,.95);
      --knobGlowBell: rgba(255,150,230,.22);

      --knobFillSynth: rgba(255,139,90,.95);
      --knobGlowSynth: rgba(255,139,90,.28);

      --knobFillBass: rgba(88,166,255,.95);
      --knobGlowBass: rgba(88,166,255,.28);

      --knobFillPad: rgba(186,140,255,.95);
      --knobGlowPad: rgba(186,140,255,.26);

      --knobFillDrum: rgba(255,255,255,.92);
      --knobGlowDrum: rgba(255,255,255,.18);

      --knobFillFx: rgba(186,140,255,.92);
      --knobGlowFx: rgba(186,140,255,.22);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 20% -10%, #1b2040 0%, transparent 60%),
        radial-gradient(900px 500px at 90% 0%, #223022 0%, transparent 55%),
        var(--userBg);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 18px;
    }

    h1{margin:0 0 6px 0; font-size:18px; letter-spacing:.2px}
    .sub{color:var(--muted); margin:0 0 16px 0; font-size:13px}

    .wrap{
      display:grid;
      grid-template-columns: 440px 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.07);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .card .hd{
      padding: 12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .title{
      font-size:13px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.12em
    }
    .bd{padding: 12px}

    button{
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ink);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 700;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:disabled{opacity:.5; cursor:not-allowed}

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    input[type="range"]{width: 150px}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:8px;
      background: rgba(0,0,0,.25);
      color: var(--ink);
    }
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}

    .msBtn{
      padding: 6px 9px;
      border-radius: 10px;
      font-size: 12px;
      line-height: 1;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: var(--muted);
      user-select:none;
    }
    .msBtn.active{
      color: var(--ink);
      border-color: rgba(255,255,255,.28);
      background: rgba(255,255,255,.10);
    }
    .msBtn.mute.active{
      background: rgba(255,80,80,.18);
      border-color: rgba(255,80,80,.35);
    }
    .msBtn.solo.active{
      background: rgba(124,255,178,.14);
      border-color: rgba(124,255,178,.30);
    }

    /* ===================== MIXER ===================== */
    .mixer{
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      overflow-x: auto;
    }
    .mixerTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .mixerTitle{
      font-size:12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .12em;
    }
    .mixerGrid{
      display:grid;
      grid-template-columns: repeat(8, minmax(230px, 1fr));
      gap: 10px;
      min-width: 1600px;
    }
    @media (max-width: 980px){
      .mixerGrid{
        grid-template-columns: repeat(2, minmax(240px, 1fr));
        min-width: unset;
      }
    }

    .strip{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.16);
      padding: 12px;
      min-width: 0;
      overflow:hidden;
    }
    .stripHd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom: 10px;
    }
    .stripName{
      font-weight: 800;
      font-size: 12px;
      letter-spacing: .06em;
      color: var(--ink);
      white-space:nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
    }

    .stripBody{
      display:grid;
      grid-template-columns: 56px 1fr;
      gap: 12px;
      align-items: stretch;
      min-width: 0;
    }

    .faderCol{
      width: 56px;
      min-width: 56px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.16);
      padding: 10px 7px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      gap: 8px;
    }
    .faderLbl{
      font-size: 10px;
      color: var(--muted);
      letter-spacing:.10em;
      text-transform: uppercase;
      user-select:none;
    }
    .faderVal{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      width: 44px;
      text-align:center;
      user-select:none;
    }
    .vFaderWrap{
      height: 138px;
      width: 34px;
      display:flex;
      align-items:center;
      justify-content:center;
      touch-action:none;
    }
    .vFader{
      width: 138px;
      height: 32px;
      transform: rotate(-90deg);
      transform-origin: center;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
    }
    .vFader::-webkit-slider-runnable-track{
      height: 10px;
      background: rgba(255,255,255,.12);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .vFader::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      margin-top: -5px;
      background: rgba(0,140,255,.95);
    }
    .vFader::-moz-range-track{
      height: 10px;
      background: rgba(255,255,255,.12);
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .vFader::-moz-range-thumb{
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 6px 16px rgba(0,0,0,.35);
      background: rgba(0,140,255,.95);
    }

    .faderCol[data-inst="piano"] .vFader::-webkit-slider-thumb{ background: var(--knobFillPiano); }
    .faderCol[data-inst="ep"]    .vFader::-webkit-slider-thumb{ background: var(--knobFillEP); }
    .faderCol[data-inst="poly"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillPoly); }
    .faderCol[data-inst="bell"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillBell); }
    .faderCol[data-inst="synth"] .vFader::-webkit-slider-thumb{ background: var(--knobFillSynth); }
    .faderCol[data-inst="bass"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillBass); }
    .faderCol[data-inst="pad"]   .vFader::-webkit-slider-thumb{ background: var(--knobFillPad); }
    .faderCol[data-inst="drum"]  .vFader::-webkit-slider-thumb{ background: var(--knobFillDrum); }

    .faderCol[data-inst="piano"] .vFader::-moz-range-thumb{ background: var(--knobFillPiano); }
    .faderCol[data-inst="ep"]    .vFader::-moz-range-thumb{ background: var(--knobFillEP); }
    .faderCol[data-inst="poly"]  .vFader::-moz-range-thumb{ background: var(--knobFillPoly); }
    .faderCol[data-inst="bell"]  .vFader::-moz-range-thumb{ background: var(--knobFillBell); }
    .faderCol[data-inst="synth"] .vFader::-moz-range-thumb{ background: var(--knobFillSynth); }
    .faderCol[data-inst="bass"]  .vFader::-moz-range-thumb{ background: var(--knobFillBass); }
    .faderCol[data-inst="pad"]   .vFader::-moz-range-thumb{ background: var(--knobFillPad); }
    .faderCol[data-inst="drum"]  .vFader::-moz-range-thumb{ background: var(--knobFillDrum); }

    .faderMS{
      display:flex;
      gap:6px;
      margin-top: 2px;
    }

    .knob{
      width:34px;
      height:34px;
      border-radius:999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.10), rgba(0,0,0,.24)), var(--knobBg);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25), 0 0 0 2px rgba(0,0,0,.12);
      position:relative;
      touch-action:none;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      --knobDeg: 0deg;
      --knobRot: -135deg;
      --knobFill: rgba(0,140,255,.95);
      --knobGlow: rgba(0,140,255,.28);
    }
    .knob::before{
      content:"";
      position:absolute;
      inset:4px;
      border-radius:999px;
      background:
        conic-gradient(from 225deg,
          var(--knobFill) 0deg,
          var(--knobFill) var(--knobDeg),
          rgba(255,255,255,.10) var(--knobDeg),
          rgba(255,255,255,.10) 270deg
        );
      filter: drop-shadow(0 0 10px var(--knobGlow));
      mask: radial-gradient(circle, transparent 55%, #000 56%);
      -webkit-mask: radial-gradient(circle, transparent 55%, #000 56%);
    }
    .knobDot{
      position:absolute;
      left:50%;
      top:50%;
      width:4px;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.85);
      transform-origin: 50% calc(100% + 4px);
      transform: translate(-50%,-90%) rotate(var(--knobRot));
      opacity:.9;
    }
    .kCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      width: 56px;
      min-width: 56px;
    }
    .kLbl{
      font-size: 10px;
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase;
      user-select:none;
    }
    .kMiniVal{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      width: 48px;
      text-align:center;
      user-select:none;
    }

    /* ✅ EXACT MIXER KNOB ALIGNMENT FIX (PAN -> LPF -> VERB always vertical, no drift) */
    .stripKnobs{
      display:flex;
      flex-direction: column;      /* vertical stack */
      flex-wrap: nowrap;           /* no wrap drift */
      gap: 12px;
      align-items: center;         /* perfect alignment */
      justify-content: flex-start;
      min-width: 0;
      flex: 1 1 auto;
      align-content: flex-start;
      padding-right: 6px;
    }
    /* FX strip stays horizontal */
    .stripKnobs.fxRow{
      flex-direction: row;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: flex-start;
    }

    /* ===================== DRUMS ===================== */
    .drumGrid{
      display:grid;
      grid-template-columns: 180px minmax(0, 1fr);
      gap:10px;
      align-items:start;
      touch-action: none;
    }
    .trackNames{display:grid; gap:8px;}
    .trackName{
      height:40px;
      border-radius: 12px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.08);
      padding: 6px 8px;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      overflow:hidden;
    }
    .trackLabel{
      font-size:12px;
      color: var(--muted);
      text-transform:uppercase;
      letter-spacing:.08em;
      line-height:1;
      flex: 1 1 auto;
      min-width: 0;
      cursor:pointer;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      white-space:nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .steps{
      display:grid;
      gap:8px;
      overflow:hidden;
      border-radius: 12px;
      min-width: 0;
    }
    .rowSteps{
      display:grid;
      gap:6px;
      height:40px;
      align-items:stretch;
      touch-action: none;
      width: 100%;
      min-width: 0;
    }
    .cell{
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      position:relative;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      min-width: 0;
    }
    .cell.groupA{ background: var(--groupA); }
    .cell.groupB{ background: var(--groupB); }
    .cell::after{
      content:"";
      position:absolute;
      inset:0;
      background: var(--inactiveOverlay);
      opacity:.55;
      pointer-events:none;
    }
    .cell.on::after{opacity:.07}
    .cell.beatDivider{ box-shadow: inset -2px 0 0 var(--beatDivider); }
    .cell.playhead{ outline: 2px solid var(--playheadOutline); outline-offset: 1px; }
    .cell.drag-hover{
      outline: 2px solid var(--dragOutline);
      outline-offset: -2px;
      box-shadow: inset 0 0 0 999px var(--dragFill);
    }

    .cell.on.kick{  background: linear-gradient(180deg, var(--kick), rgba(255,139,90,0.45)); border-color: rgba(255,139,90,0.75); }
    .cell.on.snare{ background: linear-gradient(180deg, var(--snare),rgba(88,166,255,0.30)); border-color: rgba(88,166,255,0.65); }
    .cell.on.clap{  background: linear-gradient(180deg, var(--clap), rgba(255,255,255,0.18)); border-color: rgba(255,255,255,0.45); }
    .cell.on.shaker{ background: linear-gradient(180deg, var(--shaker), rgba(186,140,255,0.28)); border-color: rgba(186,140,255,0.60); }
    .cell.on.ch{     background: linear-gradient(180deg, var(--ch), rgba(124,255,178,0.30)); border-color: rgba(124,255,178,0.65); }
    .cell.on.oh{     background: linear-gradient(180deg, var(--oh), rgba(255,210,120,0.24)); border-color: rgba(255,210,120,0.60); }
    .cell.on.tom{    background: linear-gradient(180deg, var(--tom), rgba(255,120,200,0.22)); border-color: rgba(255,120,200,0.60); }
    .cell.on.ride{   background: linear-gradient(180deg, var(--ride), rgba(120,210,255,0.18)); border-color: rgba(120,210,255,0.55); }
    .cell.on.crash{  background: linear-gradient(180deg, var(--crash), rgba(255,120,120,0.18)); border-color: rgba(255,120,120,0.55); }

    /* ===================== PIANO ROLL ===================== */
    .rollHeaderRight{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .tabs{display:flex; gap:8px; flex-wrap:wrap}
    .tab{
      padding: 7px 14px;
      border-radius: 999px;
      font-size:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: background .15s ease, border-color .15s ease, color .15s ease, box-shadow .15s ease;
    }
    .tab.active{ color: var(--ink); }

    .trKnobs{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .trGroup{
      display:flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.20);
    }
    .trLabel{
      font-size:12px;
      color: var(--muted);
      letter-spacing:.04em;
      user-select:none;
      white-space:nowrap;
    }
    .trKnob{ width:30px; height:30px; }
    .trVal{ width: 42px; }

    .rollWrap{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      overflow:hidden;
      touch-action: none;
    }
    canvas{display:block; width:100%; height:auto; touch-action:none}

    #midiFile{display:none}
    #projectFile{display:none}
    #colorPicker{display:none}

    /* ===================== MIDI LIBRARY MODAL ===================== */
    .modalOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      z-index: 9999;
    }
    .modalOverlay.show{ display:flex; }
    .modal{
      width: min(980px, 100%);
      max-height: min(78vh, 720px);
      overflow:hidden;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(20,22,34,.98), rgba(10,10,15,.98));
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      display:flex;
      flex-direction:column;
    }
    .modalHd{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      gap: 10px;
    }
    .modalTitle{
      font-weight: 900;
      letter-spacing: .06em;
      text-transform: uppercase;
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .modalControls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .modalBd{
      display:grid;
      grid-template-columns: 260px 1fr;
      min-height: 360px;
      overflow:hidden;
    }
    @media (max-width: 820px){
      .modalBd{ grid-template-columns: 1fr; }
    }
    .libLeft{
      border-right:1px solid rgba(255,255,255,.08);
      padding: 12px;
      overflow:auto;
      background: rgba(0,0,0,.18);
    }
    .libRight{
      padding: 12px;
      overflow:auto;
    }
    .searchRow{
      display:flex;
      gap:10px;
      align-items:center;
      margin-bottom: 10px;
      flex-wrap:wrap;
    }
    .input{
      flex: 1 1 220px;
      min-width: 160px;
      padding: 10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      color: var(--ink);
      outline:none;
    }
    .toggle{
      display:flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: var(--muted);
      font-size: 12px;
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }
    .pack{
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      cursor:pointer;
      user-select:none;
      margin-bottom: 10px;
    }
    .pack.active{
      border-color: rgba(124,255,178,.30);
      background: rgba(124,255,178,.08);
    }
    .packName{
      font-weight: 900;
      font-size: 13px;
    }
    .packMeta{
      color: var(--muted);
      font-size: 12px;
      margin-top: 4px;
    }
    .fileRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      margin-bottom: 10px;
    }
    .fileName{
      font-weight: 850;
      font-size: 13px;
      min-width: 0;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .fileBtns{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .miniBtn{
      padding: 7px 10px;
      border-radius: 12px;
      font-size: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.26);
      color: var(--ink);
      cursor:pointer;
    }
    .miniBtn.primary{
      border-color: rgba(124,255,178,.28);
      background: rgba(124,255,178,.12);
    }
    .status{
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
      line-height: 1.35;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <h1>RetroLoop Studio</h1>
  <p class="sub">
    4/4 • Drum sequencer + piano roll • Loop size:
    <span class="kbd" id="resText">1/64</span> • Keys: C3 → C5
  </p>

  <div class="wrap">
    <div class="card">
      <div class="hd">
        <div class="title">Transport</div>
        <div class="btnRow">
          <button id="playBtn">Play</button>
          <button id="pauseBtn" disabled>Pause</button>
          <button id="stopBtn" disabled>Stop</button>
        </div>
      </div>

      <div class="bd">
        <div class="btnRow" style="margin-bottom:10px;">
          <div class="pill">
            <span style="min-width:38px;">BPM</span>
            <input id="bpm" type="range" min="70" max="180" value="115"/>
            <span id="bpmLabel" class="kbd">115</span>
          </div>

          <div class="pill">
            <span>Loop</span>
            <input id="resolution" type="range" min="0" max="2" step="1" value="2"/>
            <span id="resolutionLabel" class="kbd">1/64</span>
          </div>
        </div>

        <div class="mixer">
          <div class="mixerTop">
            <div class="mixerTitle">Mixer</div>
            <div class="pill" style="padding:6px 10px;">
              <span>Reverb</span><span class="kbd">Return</span>
            </div>
          </div>
          <div class="mixerGrid" id="mixerGrid"></div>
        </div>

        <div class="btnRow" style="margin-top:10px;">
          <button id="loadDemo">Reload Demo</button>
          <button id="clearProject">Clear Project</button>

          <button id="saveProjectBtn">Save Project</button>
          <button id="loadProjectBtn">Load Project</button>
          <input id="projectFile" type="file" accept=".json,application/json"/>

          <button id="importMidiBtn">Import MIDI</button>
          <input id="midiFile" type="file" accept=".mid,.midi" />

          <button id="midiLibraryBtn">MIDI Library</button>

          <button id="bgBtn">Background</button>
        </div>

        <p class="hint">
          <span class="kbd">Space</span> toggles Play/Pause (desktop).
          Double-click / double-tap any <span class="kbd">instrument</span> tab, <span class="kbd">mixer label</span>, or <span class="kbd">drum label</span> to customize its color.
          <br/>Piano roll: drag to paint. Drag right to extend note length. Shift-click to erase.
        </p>
      </div>
    </div>

    <div class="card">
      <div class="hd">
        <div class="title">Drum Sequencer</div>
        <div class="pill">
          <span>Loop</span>
          <span class="kbd" id="groupText">1/64</span>
        </div>
      </div>
      <div class="bd">
        <div class="drumGrid" id="drumGrid"></div>
      </div>
    </div>

    <div class="card" style="grid-column: 1 / -1;">
      <div class="hd">
        <div class="title">Piano Roll</div>
        <div class="rollHeaderRight">
          <div class="tabs" id="tabs"></div>
          <div class="trKnobs" id="trKnobs" aria-label="Transpose knobs"></div>
        </div>
      </div>
      <div class="bd">
        <div class="rollWrap">
          <canvas id="roll" width="1280" height="560"></canvas>
        </div>
      </div>
    </div>
  </div>

  <input id="colorPicker" type="color" style="display:none;" />

  <!-- MIDI LIBRARY MODAL -->
  <div class="modalOverlay" id="midiModalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-label="MIDI Library">
      <div class="modalHd">
        <div class="modalTitle">
          <span>MIDI Library</span>
          <span class="kbd" id="targetLaneBadge">Suggested: Piano • Current: Piano</span>
        </div>
        <div class="modalControls">
          <button class="miniBtn" id="refreshMidiIndex">Refresh</button>
          <button class="miniBtn" id="closeMidiModal">Close</button>
        </div>
      </div>
      <div class="modalBd">
        <div class="libLeft">
          <div class="searchRow">
            <input class="input" id="midiSearch" placeholder="Search packs / files..." />
            <label class="toggle">
              <input type="checkbox" id="fitToLoop" checked />
              Fit to loop
            </label>
          </div>
          <div id="packList"></div>
          <div class="status" id="midiIndexStatus"></div>
        </div>
        <div class="libRight">
          <div id="fileList"></div>
          <div class="status" id="midiFileStatus"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- MIDI parser -->
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>

  <script>
  (() => {
    /* ===================== CONFIG ===================== */
    const RES_OPTIONS = [
      { label: "1/16", steps: 16 },
      { label: "1/32", steps: 32 },
      { label: "1/64", steps: 64 },
    ];
    const MASTER_STEPS = 64;        // storage resolution (always)
    const DEMO_JSON_PATH = "demos/demo01.json";
    const MIDI_INDEX_PATH = "midi/index.json";

    // Piano roll range: C3 (48) to C5 (72)
    const ROLL_BASE_MIDI = 48;
    const ROLL_TOP_MIDI  = 72;
    const ROLL_PITCHES   = (ROLL_TOP_MIDI - ROLL_BASE_MIDI) + 1;

    // Drum lanes
    const drumNames = ["Kick", "Clap", "Shaker", "Snare", "CH", "OH", "Tom", "Ride", "Crash"];
    const drumKeys  = ["kick", "clap", "shaker", "snare", "ch", "oh", "tom", "ride", "crash"];

    const LANES = [
      { key:"piano", label:"Piano",        noteVar:"--pianoNote", knobFill:"--knobFillPiano", knobGlow:"--knobGlowPiano" },
      { key:"ep",    label:"E-Piano",      noteVar:"--epNote",    knobFill:"--knobFillEP",    knobGlow:"--knobGlowEP" },
      { key:"poly",  label:"Poly Synth",   noteVar:"--polyNote",  knobFill:"--knobFillPoly",  knobGlow:"--knobGlowPoly" },
      { key:"bell",  label:"Bell",         noteVar:"--bellNote",  knobFill:"--knobFillBell",  knobGlow:"--knobGlowBell" },
      { key:"synth", label:"Synth",        noteVar:"--synthNote", knobFill:"--knobFillSynth", knobGlow:"--knobGlowSynth" },
      { key:"bass",  label:"Bass",         noteVar:"--bassNote",  knobFill:"--knobFillBass",  knobGlow:"--knobGlowBass" },
      { key:"pad",   label:"Pad",          noteVar:"--padNote",   knobFill:"--knobFillPad",   knobGlow:"--knobGlowPad" },
    ];

    const busOrder = [...LANES.map(l => l.key), "drum"];

    /* ===================== STATE ===================== */
    let ctx = null;
    let master = null;

    let bpm = 115;
    let resIndex = 2;          // default 1/64 at launch
    let LOOP_STEPS = 64;       // 16/32/64 (playback)
    let currentStep = 0;       // 0..LOOP_STEPS-1
    let nextNoteTime = 0;
    let isPlaying = false;
    let isPaused = false;
    let timerId = null;

    const lookAhead = 0.025;
    const scheduleAhead = 0.12;

    let activeRoll = "piano";
    let suggestedLane = null;

    // transpose per instrument (semitones)
    const transpose = Object.fromEntries(LANES.map(l => [l.key, 0]));

    // mixer state
    const busState = Object.fromEntries(busOrder.map(k => [k, { mute:false, solo:false }]));
    const mix = {};   // per bus pan/lpf/send values + nodes
    const buses = {}; // per bus gain nodes

    let rvConvolver = null;
    let rvReturnGain = null;
    let rvInput = null;
    let rvSize = 45;
    let rvReturn = 22;

    // Theme persisted into project JSON
    const theme = {
      bgBase: getComputedStyle(document.documentElement).getPropertyValue("--userBg").trim() || "#0f1115",
      drums: {
        kick:  getCssVar("--kick")  || "#ff8b5a",
        snare: getCssVar("--snare") || "#58a6ff",
        clap:  getCssVar("--clap")  || "#ffffff",
        shaker:getCssVar("--shaker")|| "#ba8cff",
        ch:    getCssVar("--ch")    || "#7cffb2",
        oh:    getCssVar("--oh")    || "#ffd278",
        tom:   getCssVar("--tom")   || "#ff78c8",
        ride:  getCssVar("--ride")  || "#78d2ff",
        crash: getCssVar("--crash") || "#ff7878",
      },
      lanes: {
        piano: "#7cffb2",
        ep: "#ffd778",
        poly: "#78fff0",
        bell: "#ff96e6",
        synth: "#ff8b5a",
        bass: "#58a6ff",
        pad: "#ba8cff",
      },
      labelText: { drums:{}, lanes:{} }
    };

    // Project data:
    // - drums: each is MASTER_STEPS boolean
    // - lanes: grid [pitch][MASTER_STEPS] storing note length at start cell (0 means empty/non-start)
    // NOTE: This supports "hold as long as painted note"
    function emptyLaneGrid(){
      return Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0));
    }
    function makeEmptyProject(){
      return {
        version: 1,
        bpm: 115,
        resIndex: 2,
        theme: structuredClone(theme),
        transpose: structuredClone(transpose),

        drums: Object.fromEntries(drumKeys.map(k => [k, new Array(MASTER_STEPS).fill(false)])),
        lanes: Object.fromEntries(LANES.map(l => [l.key, emptyLaneGrid()])),
        drumVols: { kick:100, clap:85, shaker:65, snare:92, ch:62, oh:70, tom:78, ride:66, crash:70 },

        mixer: {
          faders: { piano:0.35, ep:0.30, poly:0.28, bell:0.24, synth:0.32, bass:0.40, pad:0.26, drum:0.85 },
          pan:    { piano:0, ep:0, poly:0, bell:0, synth:0, bass:0, pad:0, drum:0 },
          lpf:    { piano:100, ep:100, poly:100, bell:100, synth:100, bass:100, pad:100, drum:100 },
          verb:   { piano:12, ep:12, poly:12, bell:12, synth:12, bass:12, pad:22, drum:12 },
          mute:   Object.fromEntries(busOrder.map(k => [k,false])),
          solo:   Object.fromEntries(busOrder.map(k => [k,false])),
          rvReturn: 22,
          rvSize: 45
        }
      };
    }
    let project = makeEmptyProject();

    /* ===================== DOM ===================== */
    const playBtn = document.getElementById("playBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const stopBtn = document.getElementById("stopBtn");

    const bpmEl = document.getElementById("bpm");
    const bpmLabel = document.getElementById("bpmLabel");

    const resEl = document.getElementById("resolution");
    const resLabel = document.getElementById("resolutionLabel");
    const resText = document.getElementById("resText");
    const groupText = document.getElementById("groupText");

    const loadDemoBtn = document.getElementById("loadDemo");
    const clearProjectBtn = document.getElementById("clearProject");

    const importMidiBtn = document.getElementById("importMidiBtn");
    const midiFileInput = document.getElementById("midiFile");

    const saveProjectBtn = document.getElementById("saveProjectBtn");
    const loadProjectBtn = document.getElementById("loadProjectBtn");
    const projectFileInput = document.getElementById("projectFile");

    const bgBtn = document.getElementById("bgBtn");
    const colorPicker = document.getElementById("colorPicker");

    const drumGridEl = document.getElementById("drumGrid");
    const rollCanvas = document.getElementById("roll");
    const g = rollCanvas.getContext("2d");

    const mixerGrid = document.getElementById("mixerGrid");
    const tabsEl = document.getElementById("tabs");
    const trKnobsEl = document.getElementById("trKnobs");

    // MIDI Library
    const midiLibraryBtn = document.getElementById("midiLibraryBtn");
    const midiModalOverlay = document.getElementById("midiModalOverlay");
    const closeMidiModal = document.getElementById("closeMidiModal");
    const refreshMidiIndex = document.getElementById("refreshMidiIndex");
    const midiSearch = document.getElementById("midiSearch");
    const fitToLoop = document.getElementById("fitToLoop");
    const packListEl = document.getElementById("packList");
    const fileListEl = document.getElementById("fileList");
    const midiIndexStatus = document.getElementById("midiIndexStatus");
    const midiFileStatus = document.getElementById("midiFileStatus");
    const targetLaneBadge = document.getElementById("targetLaneBadge");

    /* ====== UI label elements (for color updates) ====== */
    const laneStripLabelEls = {};
    const drumLabelEls = {};

    /* ===================== UTIL ===================== */
    function getCssVar(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
    function setCssVar(name, value){ document.documentElement.style.setProperty(name, value); }
    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
    function clampInt(v, min, max){
      v = Number(v);
      if (!Number.isFinite(v)) return min;
      v = Math.round(v);
      return Math.max(min, Math.min(max, v));
    }
    function normalizeHex(hex){
      if (!hex) return "#000000";
      hex = String(hex).trim();
      if (hex.startsWith("rgb")) return rgbStringToHex(hex);
      if (!hex.startsWith("#")) return "#000000";
      if (hex.length === 4) return "#" + hex[1]+hex[1] + hex[2]+hex[2] + hex[3]+hex[3];
      if (hex.length === 7) return hex;
      return "#000000";
    }
    function rgbStringToHex(str){
      const m = str.match(/rgba?\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)/i);
      if (!m) return "#000000";
      const r = clampInt(m[1],0,255), g = clampInt(m[2],0,255), b = clampInt(m[3],0,255);
      const to2 = (n)=>n.toString(16).padStart(2,"0");
      return `#${to2(r)}${to2(g)}${to2(b)}`;
    }
    function hexToRgb(hex){
      hex = normalizeHex(hex);
      return {
        r: parseInt(hex.slice(1,3),16),
        g: parseInt(hex.slice(3,5),16),
        b: parseInt(hex.slice(5,7),16),
      };
    }
    function hexToRgba(hex, a){
      const {r,g,b} = hexToRgb(hex);
      return `rgba(${r},${g},${b},${a})`;
    }
    function relLuminance(hex){
      const {r,g,b} = hexToRgb(hex);
      const srgb = [r,g,b].map(v => v/255).map(v => v <= 0.03928 ? v/12.92 : Math.pow((v+0.055)/1.055,2.4));
      return 0.2126*srgb[0] + 0.7152*srgb[1] + 0.0722*srgb[2];
    }
    function contrastText(hex){
      const L = relLuminance(hex);
      return (L > 0.55) ? "rgba(0,0,0,0.85)" : "rgba(255,255,255,0.88)";
    }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }
    function structuredClone(obj){
      return JSON.parse(JSON.stringify(obj));
    }

    function attachDoubleTap(el, handler){
      el.addEventListener("dblclick", (e) => { e.preventDefault(); handler(e); });
      let lastTap = 0;
      el.addEventListener("pointerup", (e) => {
        if (e.pointerType !== "touch") return;
        const now = performance.now();
        const dt = now - lastTap;
        lastTap = now;
        if (dt < 300) { e.preventDefault(); handler(e); }
      }, {passive:false});
    }

    // Transport shortcuts
    function isTypingTarget(el){
      if (!el) return false;
      const tag = (el.tagName || "").toLowerCase();
      return tag === "input" || tag === "textarea" || el.isContentEditable;
    }
    window.addEventListener("keydown", (e) => {
      if (e.code !== "Space") return;
      if (isTypingTarget(document.activeElement)) return;
      e.preventDefault();
      togglePlayPause();
    }, {passive:false});

    /* ===================== COLOR PICKER ===================== */
    let pendingPick = null;
    function openColorPicker(startHex, onPick){
      pendingPick = { onPick };
      colorPicker.value = normalizeHex(startHex);
      colorPicker.click();
    }
    colorPicker.addEventListener("input", () => {
      if (!pendingPick?.onPick) return;
      pendingPick.onPick(colorPicker.value);
    });
    colorPicker.addEventListener("change", () => { pendingPick = null; });

    function applyBgColor(hex){
      hex = normalizeHex(hex);
      project.theme.bgBase = hex;
      setCssVar("--userBg", hex);
    }

    function applyLaneColor(laneKey, hex){
      hex = normalizeHex(hex);
      project.theme.lanes[laneKey] = hex;

      const lane = LANES.find(l => l.key === laneKey);
      if (!lane) return;

      setCssVar(lane.noteVar, hexToRgba(hex, 0.78));
      setCssVar(lane.knobFill, hexToRgba(hex, 0.95));
      setCssVar(lane.knobGlow, hexToRgba(hex, 0.26));

      project.theme.labelText.lanes[laneKey] = contrastText(hex);

      updateLaneLabelStyles(laneKey);
      updateActiveTabStyles();
      drawRoll(isPlaying ? currentStep : -1);
    }

    function applyDrumColor(drumKey, hex){
      hex = normalizeHex(hex);
      project.theme.drums[drumKey] = hex;
      setCssVar(`--${drumKey}`, hex);
      project.theme.labelText.drums[drumKey] = contrastText(hex);
      updateDrumLabelStyles(drumKey);
      refreshDrumUI();
    }

    function updateLaneLabelStyles(laneKey){
      const hex = project.theme.lanes[laneKey] || "#999";
      const txt = project.theme.labelText.lanes[laneKey] || contrastText(hex);

      const el = laneStripLabelEls[laneKey];
      if (el){
        el.style.background = hexToRgba(hex, 0.16);
        el.style.borderColor = hexToRgba(hex, 0.45);
        el.style.color = txt;
      }

      // tabs use this too
      document.querySelectorAll(`.tab[data-roll="${laneKey}"]`).forEach(tab => {
        if (!tab.classList.contains("active")) return;
        tab.style.color = "var(--ink)";
      });
    }

    function updateDrumLabelStyles(drumKey){
      const hex = project.theme.drums[drumKey] || "#999";
      const txt = project.theme.labelText.drums[drumKey] || contrastText(hex);
      const el = drumLabelEls[drumKey];
      if (!el) return;
      el.style.background = hexToRgba(hex, 0.16);
      el.style.borderColor = hexToRgba(hex, 0.45);
      el.style.color = txt;
    }

    function updateActiveTabStyles(){
      document.querySelectorAll(".tab").forEach(tab => {
        const key = tab.dataset.roll;
        const hex = project.theme.lanes[key] || "#888";
        if (tab.classList.contains("active")){
          tab.style.background = hexToRgba(hex, 0.16);
          tab.style.borderColor = hexToRgba(hex, 0.45);
          tab.style.boxShadow = `0 0 0 2px ${hexToRgba(hex, 0.12)} inset`;
          tab.style.color = "var(--ink)";
        } else {
          tab.style.background = "rgba(0,0,0,.22)";
          tab.style.borderColor = "rgba(255,255,255,.10)";
          tab.style.boxShadow = "none";
          tab.style.color = "var(--muted)";
        }
      });
    }

    /* ===================== LOOP TIMING (ABSOLUTE BPM) ===================== */
    // master tick is 1/64 note: 4 beats per bar => 16 1/16 notes => 64 1/64 notes
    function secondsPerMasterStep(){
      // 1 beat = 60/bpm seconds
      // 1/64 note = 1/16 of a beat
      return (60 / bpm) / 16;
    }
    function stepSecondsForCurrentResolution(){
      const factor = MASTER_STEPS / LOOP_STEPS; // 64/16=4, 64/32=2, 64/64=1
      return secondsPerMasterStep() * factor;   // absolute BPM unchanged
    }
    function masterIndexFromLoopStep(loopStep){
      const factor = MASTER_STEPS / LOOP_STEPS;
      return (loopStep * factor) | 0;
    }

    /* ===================== AUDIO ENGINE ===================== */
    function ensureAudio(){
      if (ctx) return;

      ctx = new (window.AudioContext || window.webkitAudioContext)();

      master = ctx.createGain();
      master.gain.value = 0.9;
      master.connect(ctx.destination);

      // Reverb return
      rvInput = ctx.createGain();
      rvConvolver = ctx.createConvolver();
      rvReturnGain = ctx.createGain();
      rvInput.connect(rvConvolver);
      rvConvolver.connect(rvReturnGain);
      rvReturnGain.connect(master);

      // impulse
      setReverbSize(project.mixer.rvSize ?? 45);
      setReverbReturn(project.mixer.rvReturn ?? 22);

      // buses
      busOrder.forEach(k => { buses[k] = ctx.createGain(); });

      busOrder.forEach(k => {
        const lpf = ctx.createBiquadFilter();
        lpf.type = "lowpass";
        const pan = ctx.createStereoPanner();
        const send = ctx.createGain();

        // bus -> lpf -> pan -> master
        buses[k].connect(lpf);
        lpf.connect(pan);
        pan.connect(master);

        // bus -> send -> reverb
        buses[k].connect(send);
        send.connect(rvInput);

        mix[k] = {
          lpf, pan, send,
          panVal: (project.mixer.pan?.[k] ?? 0),
          lpfVal: (project.mixer.lpf?.[k] ?? 100),
          sendVal:(project.mixer.verb?.[k] ?? 12)
        };
      });

      applyAllMixNodes();
      applyBusRouting();
    }

    async function ensureRunning(){
      ensureAudio();
      if (ctx.state !== "running") await ctx.resume();
    }

    function makeImpulseResponse(decaySeconds){
      const sr = ctx.sampleRate;
      const len = Math.max(1, Math.floor(sr * decaySeconds));
      const buffer = ctx.createBuffer(2, len, sr);
      for (let ch=0; ch<2; ch++){
        const data = buffer.getChannelData(ch);
        for (let i=0; i<len; i++){
          const t = i / len;
          const env = Math.pow(1 - t, 2.8);
          data[i] = (Math.random()*2 - 1) * env;
        }
      }
      return buffer;
    }

    function setReverbSize(size0to100){
      rvSize = clamp(Math.round(size0to100), 0, 100);
      if (!ctx || !rvConvolver) return;
      const decay = 0.6 + (rvSize/100) * 5.4;
      rvConvolver.buffer = makeImpulseResponse(decay);
      project.mixer.rvSize = rvSize;
    }

    function setReverbReturn(v0to100){
      rvReturn = clamp(Math.round(v0to100), 0, 100);
      if (!rvReturnGain) return;
      rvReturnGain.gain.value = (rvReturn/100) * 0.55;
      project.mixer.rvReturn = rvReturn;
    }

    function lpfCutoffFromPct(pct01){
      const min = 200;
      const max = 18000;
      const ratio = max / min;
      return min * Math.pow(ratio, pct01);
    }

    function applyMixNodes(busKey){
      const m = mix[busKey];
      if (!m) return;
      m.pan.pan.value = clamp(m.panVal/100, -1, 1);
      m.lpf.frequency.setValueAtTime(lpfCutoffFromPct(clamp(m.lpfVal/100, 0, 1)), ctx.currentTime);
      m.lpf.Q.value = 0.7;
      const s = clamp(m.sendVal/100, 0, 1);
      m.send.gain.value = s*s;
    }
    function applyAllMixNodes(){
      busOrder.forEach(applyMixNodes);
    }

    function applyBusRouting(){
      const anySolo = Object.values(busState).some(b => b.solo);
      function effGain(busKey){
        const base = Number(project.mixer.faders?.[busKey] ?? 0.3);
        const s = busState[busKey];
        if (anySolo) return (s.solo ? (s.mute ? 0 : base) : 0);
        return (s.mute ? 0 : base);
      }
      busOrder.forEach(k => { if (buses[k]) buses[k].gain.value = effGain(k); });
    }

    /* ===================== SYNTH SOURCES ===================== */
    // Simple, fast, no external samples.
    function envGainAt(time, gainNode, a, d, s, r, peak=1, sustain=0.2){
      // Attack/Decay/Sustain/Release
      gainNode.gain.cancelScheduledValues(time);
      gainNode.gain.setValueAtTime(0.0001, time);
      gainNode.gain.exponentialRampToValueAtTime(peak, time + a);
      gainNode.gain.exponentialRampToValueAtTime(sustain, time + a + d);
      // release scheduled by caller
    }

    function noteHz(midi){
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    function playTone(busKey, midi, time, durSec, type="sine", amp=0.25, detune=0){
      ensureAudio();
      const osc = ctx.createOscillator();
      osc.type = type;
      osc.frequency.setValueAtTime(noteHz(midi), time);
      osc.detune.setValueAtTime(detune, time);

      const gNode = ctx.createGain();
      gNode.gain.value = 0.0001;

      // basic voice filter for softer sound
      const f = ctx.createBiquadFilter();
      f.type = "lowpass";
      f.frequency.setValueAtTime(12000, time);

      osc.connect(f);
      f.connect(gNode);
      gNode.connect(buses[busKey]);

      // envelope
      let a=0.005, d=0.08, s=0.18, r=0.08, peak=amp, sustain=amp*0.28;
      if (busKey==="pad"){ a=0.08; d=0.35; r=0.55; sustain=amp*0.55; }
      if (busKey==="bass"){ a=0.005; d=0.12; r=0.10; sustain=amp*0.20; }
      if (busKey==="bell"){ a=0.001; d=0.18; r=0.22; sustain=amp*0.06; }
      if (busKey==="poly"){ a=0.01; d=0.18; r=0.14; sustain=amp*0.25; }
      if (busKey==="ep"){ a=0.004; d=0.14; r=0.16; sustain=amp*0.22; }

      envGainAt(time, gNode, a, d, s, r, peak, sustain);
      gNode.gain.setTargetAtTime(0.0001, time + Math.max(0.03, durSec), r);

      osc.start(time);
      osc.stop(time + durSec + r + 0.12);
    }

    function playDrum(drumKey, time){
      ensureAudio();

      const out = ctx.createGain();
      out.gain.value = (project.drumVols?.[drumKey] ?? 80) / 100;
      out.connect(buses.drum);

      const t = time;

      if (drumKey === "kick"){
        const osc = ctx.createOscillator();
        osc.type = "sine";
        const gN = ctx.createGain();
        gN.gain.value = 0.0001;
        osc.connect(gN);
        gN.connect(out);

        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(50, t + 0.12);

        gN.gain.setValueAtTime(0.0001, t);
        gN.gain.exponentialRampToValueAtTime(1.0, t + 0.006);
        gN.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

        osc.start(t);
        osc.stop(t + 0.20);
        return;
      }

      // noise helper
      function noiseBuffer(){
        const dur = 0.25;
        const len = Math.floor(ctx.sampleRate * dur);
        const buf = ctx.createBuffer(1, len, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i=0;i<len;i++) data[i] = Math.random()*2 - 1;
        return buf;
      }

      const src = ctx.createBufferSource();
      src.buffer = noiseBuffer();

      const filter = ctx.createBiquadFilter();
      filter.type = "bandpass";

      const gN = ctx.createGain();
      gN.gain.value = 0.0001;

      src.connect(filter);
      filter.connect(gN);
      gN.connect(out);

      if (drumKey === "snare"){
        filter.frequency.setValueAtTime(1800, t);
        filter.Q.setValueAtTime(0.8, t);
        gN.gain.setValueAtTime(0.0001, t);
        gN.gain.exponentialRampToValueAtTime(0.85, t + 0.004);
        gN.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);
        src.start(t);
        src.stop(t + 0.20);
        return;
      }

      if (drumKey === "clap"){
        filter.frequency.setValueAtTime(2200, t);
        filter.Q.setValueAtTime(0.7, t);

        // multi-burst
        const bursts = [0, 0.02, 0.045, 0.075];
        bursts.forEach((off, i) => {
          const s2 = ctx.createBufferSource();
          s2.buffer = src.buffer;
          const g2 = ctx.createGain();
          g2.gain.value = 0.0001;

          s2.connect(filter);
          filter.connect(g2);
          g2.connect(out);

          const tt = t + off;
          g2.gain.setValueAtTime(0.0001, tt);
          g2.gain.exponentialRampToValueAtTime(0.65 / (1 + i*0.25), tt + 0.003);
          g2.gain.exponentialRampToValueAtTime(0.0001, tt + 0.06);

          s2.start(tt);
          s2.stop(tt + 0.09);
        });
        return;
      }

      // hats / shaker / ride / crash / tom
      if (drumKey === "ch" || drumKey === "oh" || drumKey === "shaker" || drumKey === "ride" || drumKey === "crash"){
        const freq = (drumKey==="ch") ? 7800 :
                     (drumKey==="oh") ? 6600 :
                     (drumKey==="shaker") ? 5200 :
                     (drumKey==="ride") ? 4500 : 3200;

        filter.type = "highpass";
        filter.frequency.setValueAtTime(freq, t);
        filter.Q.setValueAtTime(0.7, t);

        const dur = (drumKey==="ch") ? 0.06 :
                    (drumKey==="oh") ? 0.20 :
                    (drumKey==="shaker") ? 0.10 :
                    (drumKey==="ride") ? 0.25 : 0.35;

        gN.gain.setValueAtTime(0.0001, t);
        gN.gain.exponentialRampToValueAtTime(drumKey==="crash" ? 0.95 : 0.55, t + 0.002);
        gN.gain.exponentialRampToValueAtTime(0.0001, t + dur);

        src.start(t);
        src.stop(t + dur + 0.02);
        return;
      }

      if (drumKey === "tom"){
        // pitched thump
        const osc = ctx.createOscillator();
        osc.type = "sine";
        const g2 = ctx.createGain();
        g2.gain.value = 0.0001;
        osc.connect(g2);
        g2.connect(out);

        osc.frequency.setValueAtTime(180, t);
        osc.frequency.exponentialRampToValueAtTime(95, t + 0.12);

        g2.gain.setValueAtTime(0.0001, t);
        g2.gain.exponentialRampToValueAtTime(0.8, t + 0.004);
        g2.gain.exponentialRampToValueAtTime(0.0001, t + 0.16);

        osc.start(t);
        osc.stop(t + 0.22);
        return;
      }
    }

    /* ===================== MIDI AUTO-DETECT (REQUIRED) ===================== */
    function laneLabel(key){
      return (LANES.find(l => l.key === key)?.label) || key;
    }

    // ✅ filename keyword guess
    function suggestLaneFromName(name){
      const n = (name || "").toLowerCase();
      const rules = [
        { lane:"bass",  keys:["bass","808","sub","lowend"] },
        { lane:"ep",    keys:["rhodes","ep","e-piano","electric piano","wurl","wurli"] },
        { lane:"piano", keys:["piano","keys","chords"] },
        { lane:"pad",   keys:["pad","atmo","ambient","wash"] },
        { lane:"poly",  keys:["poly","supersaw","stack"] },
        { lane:"bell",  keys:["bell","glock","mallet","chime"] },
        { lane:"synth", keys:["synth","lead","arp","arpeggio","pluck"] },
      ];
      for (const r of rules){
        if (r.keys.some(k => n.includes(k))) return r.lane;
      }
      return "piano";
    }

    // ✅ pitch-range fallback
    function suggestLaneFromMidi(midi){
      let lo = Infinity, hi = -Infinity, count = 0;
      midi.tracks.forEach(t => (t.notes||[]).forEach(n => {
        lo = Math.min(lo, n.midi);
        hi = Math.max(hi, n.midi);
        count++;
      }));
      if (!Number.isFinite(lo) || !Number.isFinite(hi) || count === 0) return "piano";
      const range = hi - lo;
      if (hi <= 55) return "bass";
      if (lo < 52 && range < 18) return "bass";
      if (range >= 20 && lo >= 48 && hi <= 84) return "piano";
      if (lo >= 60) return "synth";
      return "piano";
    }

    /* ===================== UI BUILDERS ===================== */
    function buildTabs(){
      tabsEl.innerHTML = "";
      LANES.forEach((l, idx) => {
        const t = document.createElement("div");
        t.className = "tab" + (idx===0 ? " active" : "");
        t.textContent = l.label;
        t.dataset.roll = l.key;

        t.addEventListener("click", () => {
          document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
          t.classList.add("active");
          activeRoll = l.key;
          updateActiveTabStyles();
          drawRoll(isPlaying ? currentStep : -1);
          if (midiModalOverlay.classList.contains("show")){
            const sug = suggestedLane ? laneLabel(suggestedLane) : laneLabel(activeRoll);
            targetLaneBadge.textContent = `Suggested: ${sug} • Current: ${laneLabel(activeRoll)}`;
          }
        });

        // color wheel on tab label
        attachDoubleTap(t, () => {
          const start = project.theme.lanes[l.key] || "#888888";
          openColorPicker(start, (hex) => applyLaneColor(l.key, hex));
        });

        tabsEl.appendChild(t);
      });

      updateActiveTabStyles();
    }

    function semitoneToPct(v){ return (clamp(v, -24, 24) + 24) / 48; }
    function knobStyleForPercent(pct){
      pct = clamp(pct, 0, 1);
      const deg = pct * 270;
      const rot = (-135 + pct * 270);
      return { fillDeg: `${deg}deg`, rotDeg: `${rot}deg` };
    }
    function setKnobVisual(knobEl, pct){
      const st = knobStyleForPercent(pct);
      knobEl.style.setProperty("--knobDeg", st.fillDeg);
      knobEl.style.setProperty("--knobRot", st.rotDeg);
    }
    function setTranspose(inst, val){
      const v = clamp(Math.round(Number(val)), -24, 24);
      project.transpose[inst] = v;
      transpose[inst] = v;
      const grp = trKnobsEl.querySelector(`.trGroup[data-inst="${inst}"]`);
      if (grp){
        grp.querySelector(".trVal").textContent = String(v);
        setKnobVisual(grp.querySelector(".knob"), semitoneToPct(v));
      }
    }
    function attachTransposeKnob(knobEl, inst){
      let active=false, pid=null, startY=0, startVal=0;
      const onDown = async (e) => {
        e.preventDefault();
        await ensureRunning();
        active=true; pid=e.pointerId; startY=e.clientY; startVal=transpose[inst]||0;
        knobEl.setPointerCapture(pid);
      };
      const onMove = (e) => {
        if (!active || e.pointerId !== pid) return;
        e.preventDefault();
        const dy = startY - e.clientY;
        setTranspose(inst, startVal + dy/12);
      };
      const onUp = (e) => { if (!active || e.pointerId !== pid) return; active=false; pid=null; };
      knobEl.addEventListener("pointerdown", onDown, {passive:false});
      knobEl.addEventListener("pointermove", onMove, {passive:false});
      knobEl.addEventListener("pointerup", onUp);
      knobEl.addEventListener("pointercancel", onUp);
      knobEl.addEventListener("lostpointercapture", ()=>{active=false;pid=null;});
      knobEl.addEventListener("dblclick", (e)=>{e.preventDefault(); setTranspose(inst,0);});
    }

    function buildTransposeKnobs(){
      trKnobsEl.innerHTML = "";
      LANES.forEach(l => {
        const grp = document.createElement("div");
        grp.className = "trGroup";
        grp.dataset.inst = l.key;

        const lab = document.createElement("div");
        lab.className = "trLabel";
        lab.textContent = (l.label.length > 7 ? l.label.slice(0,7) : l.label) + " Tr";

        const knob = document.createElement("div");
        knob.className = "knob trKnob";
        knob.style.setProperty("--knobFill", getCssVar(l.knobFill));
        knob.style.setProperty("--knobGlow", getCssVar(l.knobGlow));
        knob.appendChild(Object.assign(document.createElement("div"), { className:"knobDot" }));

        const val = document.createElement("div");
        val.className = "kbd trVal";
        val.textContent = String(transpose[l.key] ?? 0);

        grp.appendChild(lab);
        grp.appendChild(knob);
        grp.appendChild(val);
        trKnobsEl.appendChild(grp);

        setKnobVisual(knob, semitoneToPct(transpose[l.key] ?? 0));
        attachTransposeKnob(knob, l.key);
      });
    }

    // ===== mixer UI =====
    const busMeta = {
      piano:{ label:"Piano", fill:"--knobFillPiano", glow:"--knobGlowPiano" },
      ep:{ label:"Electric Piano", fill:"--knobFillEP", glow:"--knobGlowEP" },
      poly:{ label:"Poly Synth", fill:"--knobFillPoly", glow:"--knobGlowPoly" },
      bell:{ label:"Bell", fill:"--knobFillBell", glow:"--knobGlowBell" },
      synth:{ label:"Synth", fill:"--knobFillSynth", glow:"--knobGlowSynth" },
      bass:{ label:"Bass", fill:"--knobFillBass", glow:"--knobGlowBass" },
      pad:{ label:"Pad", fill:"--knobFillPad", glow:"--knobGlowPad" },
      drum:{ label:"Drums", fill:"--knobFillDrum", glow:"--knobGlowDrum" },
    };

    const busUI = {};

    function setKnobVisualDeg(knobEl, pct){
      pct = clamp(pct,0,1);
      const deg = pct * 270;
      const rot = (-135 + pct*270);
      knobEl.style.setProperty("--knobDeg", `${deg}deg`);
      knobEl.style.setProperty("--knobRot", `${rot}deg`);
    }

    function bindKnob({knobEl, valEl, min, max, step, initial, onChange, format, dblClickReset}){
      let value = initial;
      const valueToPct = (v) => (v - min) / (max - min);

      function setValue(v){
        v = clamp(v, min, max);
        if (step) v = Math.round(v / step) * step;
        value = v;
        setKnobVisualDeg(knobEl, valueToPct(value));
        if (valEl) valEl.textContent = format ? format(value) : String(value);
        onChange && onChange(value);
      }
      setValue(value);

      let active=false, pid=null, startY=0, startVal=0;
      const onDown = async (e) => {
        e.preventDefault();
        await ensureRunning();
        active=true; pid=e.pointerId; startY=e.clientY; startVal=value;
        knobEl.setPointerCapture(pid);
      };
      const onMove = (e) => {
        if (!active || e.pointerId !== pid) return;
        e.preventDefault();
        const dy = startY - e.clientY;
        const delta = (dy / 120) * (max - min);
        setValue(startVal + delta);
      };
      const onUp = (e) => { if (!active || e.pointerId !== pid) return; active=false; pid=null; };

      knobEl.addEventListener("pointerdown", onDown, {passive:false});
      knobEl.addEventListener("pointermove", onMove, {passive:false});
      knobEl.addEventListener("pointerup", onUp);
      knobEl.addEventListener("pointercancel", onUp);
      knobEl.addEventListener("lostpointercapture", ()=>{active=false;pid=null;});
      if (dblClickReset !== undefined){
        knobEl.addEventListener("dblclick", (e)=>{e.preventDefault(); setValue(dblClickReset);});
      }
    }

    function makeStrip(busKey){
      const meta = busMeta[busKey];

      const strip = document.createElement("div");
      strip.className = "strip";

      const hd = document.createElement("div");
      hd.className = "stripHd";
      const name = document.createElement("div");
      name.className = "stripName";
      name.textContent = meta.label;
      hd.appendChild(name);
      strip.appendChild(hd);

      if (busKey !== "drum"){
        laneStripLabelEls[busKey] = name;
        attachDoubleTap(name, () => {
          const start = project.theme.lanes[busKey] || "#888";
          openColorPicker(start, (hex) => applyLaneColor(busKey, hex));
        });
        updateLaneLabelStyles(busKey);
      }

      const body = document.createElement("div");
      body.className = "stripBody";

      const faderCol = document.createElement("div");
      faderCol.className = "faderCol";
      faderCol.dataset.inst = busKey;

      const fLbl = document.createElement("div");
      fLbl.className = "faderLbl";
      fLbl.textContent = "Vol";

      const wrap = document.createElement("div");
      wrap.className = "vFaderWrap";
      const fader = document.createElement("input");
      fader.className = "vFader";
      fader.type = "range";
      fader.min = "0"; fader.max="1"; fader.step="0.01";
      fader.value = String(project.mixer.faders?.[busKey] ?? 0.3);
      wrap.appendChild(fader);

      const fVal = document.createElement("div");
      fVal.className = "faderVal";
      fVal.textContent = Number(fader.value).toFixed(2);

      const ms = document.createElement("div");
      ms.className = "faderMS";

      const mute = document.createElement("button");
      mute.className = "msBtn mute";
      mute.type = "button";
      mute.textContent = "M";

      const solo = document.createElement("button");
      solo.className = "msBtn solo";
      solo.type = "button";
      solo.textContent = "S";

      ms.appendChild(mute);
      ms.appendChild(solo);

      faderCol.appendChild(fLbl);
      faderCol.appendChild(wrap);
      faderCol.appendChild(fVal);
      faderCol.appendChild(ms);

      const knobs = document.createElement("div");
      knobs.className = "stripKnobs";

      function mkKnob(labelText){
        const col = document.createElement("div");
        col.className = "kCol";
        const k = document.createElement("div");
        k.className = "knob";
        k.style.setProperty("--knobFill", getCssVar(meta.fill));
        k.style.setProperty("--knobGlow", getCssVar(meta.glow));
        k.appendChild(Object.assign(document.createElement("div"), { className:"knobDot" }));
        const lbl = document.createElement("div");
        lbl.className = "kLbl";
        lbl.textContent = labelText;
        const v = document.createElement("div");
        v.className = "kMiniVal";
        v.textContent = "0";
        col.appendChild(k); col.appendChild(lbl); col.appendChild(v);
        return { col, knob:k, val:v };
      }

      // ✅ REQUIRED ORDER (PAN, LPF, VERB) — and CSS locks vertical alignment
      const pan = mkKnob("Pan");
      const lpf = mkKnob("LPF");
      const snd = mkKnob("Verb");
      knobs.appendChild(pan.col);
      knobs.appendChild(lpf.col);
      knobs.appendChild(snd.col);

      body.appendChild(faderCol);
      body.appendChild(knobs);
      strip.appendChild(body);

      busUI[busKey] = { strip, fader, fVal, mute, solo, pan, lpf, snd, labelEl:name };
      return strip;
    }

    function buildMixer(){
      mixerGrid.innerHTML = "";
      busOrder.forEach(k => mixerGrid.appendChild(makeStrip(k)));

      // FX strip
      const fx = document.createElement("div");
      fx.className = "strip";
      fx.style.gridColumn = "1 / -1";

      const hd = document.createElement("div");
      hd.className = "stripHd";
      const name = document.createElement("div");
      name.className = "stripName";
      name.textContent = "FX Return";
      name.style.cursor = "default";
      hd.appendChild(name);
      fx.appendChild(hd);

      const knobs = document.createElement("div");
      knobs.className = "stripKnobs fxRow"; // ✅ stays horizontal

      function mkFxKnob(labelText){
        const col = document.createElement("div");
        col.className = "kCol";
        const k = document.createElement("div");
        k.className = "knob";
        k.style.setProperty("--knobFill", getCssVar("--knobFillFx"));
        k.style.setProperty("--knobGlow", getCssVar("--knobGlowFx"));
        k.appendChild(Object.assign(document.createElement("div"), { className:"knobDot" }));
        const lbl = document.createElement("div");
        lbl.className = "kLbl";
        lbl.textContent = labelText;
        const v = document.createElement("div");
        v.className = "kMiniVal";
        v.textContent = "0";
        col.appendChild(k); col.appendChild(lbl); col.appendChild(v);
        return { col, knob:k, val:v };
      }

      const rvRet = mkFxKnob("Return");
      const rvSiz = mkFxKnob("Size");
      knobs.appendChild(rvRet.col);
      knobs.appendChild(rvSiz.col);

      fx.appendChild(knobs);
      mixerGrid.appendChild(fx);

      busUI.__fx = { rvRet, rvSiz };
    }
    /* ===================== MIXER BINDINGS ===================== */
    function wireMixer(){
      // per-bus
      busOrder.forEach(k => {
        const ui = busUI[k];
        if (!ui) return;

        // initial M/S
        busState[k].mute = !!project.mixer.mute?.[k];
        busState[k].solo = !!project.mixer.solo?.[k];
        ui.mute.classList.toggle("active", busState[k].mute);
        ui.solo.classList.toggle("active", busState[k].solo);

        ui.fader.addEventListener("input", () => {
          ui.fVal.textContent = Number(ui.fader.value).toFixed(2);
          project.mixer.faders[k] = Number(ui.fader.value);
          applyBusRouting();
        });

        ui.mute.addEventListener("click", async (e) => {
          e.preventDefault(); await ensureRunning();
          busState[k].mute = !busState[k].mute;
          project.mixer.mute[k] = busState[k].mute;
          ui.mute.classList.toggle("active", busState[k].mute);
          applyBusRouting();
        });

        ui.solo.addEventListener("click", async (e) => {
          e.preventDefault(); await ensureRunning();
          busState[k].solo = !busState[k].solo;
          project.mixer.solo[k] = busState[k].solo;
          ui.solo.classList.toggle("active", busState[k].solo);
          applyBusRouting();
        });

        // knobs: pan/lpf/send
        bindKnob({
          knobEl: ui.pan.knob, valEl: ui.pan.val,
          min:-100, max:100, step:1, initial: project.mixer.pan?.[k] ?? 0, dblClickReset:0,
          format:(v)=>String(v),
          onChange:(v)=>{ mix[k].panVal=v; project.mixer.pan[k]=v; applyMixNodes(k); }
        });

        bindKnob({
          knobEl: ui.lpf.knob, valEl: ui.lpf.val,
          min:0, max:100, step:1, initial: project.mixer.lpf?.[k] ?? 100, dblClickReset:100,
          format:(v)=>String(v),
          onChange:(v)=>{ mix[k].lpfVal=v; project.mixer.lpf[k]=v; applyMixNodes(k); }
        });

        bindKnob({
          knobEl: ui.snd.knob, valEl: ui.snd.val,
          min:0, max:100, step:1, initial: project.mixer.verb?.[k] ?? 12, dblClickReset:0,
          format:(v)=>String(v),
          onChange:(v)=>{ mix[k].sendVal=v; project.mixer.verb[k]=v; applyMixNodes(k); }
        });

        // ensure labels match lane colors
        if (k !== "drum") updateLaneLabelStyles(k);
      });

      // FX return knobs
      bindKnob({
        knobEl: busUI.__fx.rvRet.knob, valEl: busUI.__fx.rvRet.val,
        min:0, max:100, step:1, initial: project.mixer.rvReturn ?? 22, dblClickReset:22,
        format:(v)=>String(v),
        onChange:(v)=>setReverbReturn(v)
      });
      bindKnob({
        knobEl: busUI.__fx.rvSiz.knob, valEl: busUI.__fx.rvSiz.val,
        min:0, max:100, step:1, initial: project.mixer.rvSize ?? 45, dblClickReset:45,
        format:(v)=>String(v),
        onChange:(v)=>setReverbSize(v)
      });
    }

    /* ===================== DRUM UI ===================== */
    function buildDrumGrid(){
      drumGridEl.innerHTML = "";

      const namesCol = document.createElement("div");
      namesCol.className = "trackNames";

      const stepsCol = document.createElement("div");
      stepsCol.className = "steps";

      drumKeys.forEach((dk, rowIdx) => {
        // left label cell
        const tn = document.createElement("div");
        tn.className = "trackName";

        const lab = document.createElement("div");
        lab.className = "trackLabel";
        lab.textContent = drumNames[rowIdx];
        drumLabelEls[dk] = lab;

        // volume knob (circular)
        const vol = document.createElement("div");
        vol.className = "knob";
        vol.style.width = "30px";
        vol.style.height = "30px";
        vol.style.setProperty("--knobFill", "rgba(255,255,255,.92)");
        vol.style.setProperty("--knobGlow", "rgba(255,255,255,.18)");
        vol.appendChild(Object.assign(document.createElement("div"), { className:"knobDot" }));

        // small value pill
        const vPill = document.createElement("div");
        vPill.className = "kbd";
        vPill.style.fontSize = "11px";
        vPill.style.padding = "1px 6px";
        vPill.textContent = String(project.drumVols?.[dk] ?? 80);

        // bind knob to volume 0..100
        bindKnob({
          knobEl: vol,
          valEl: vPill,
          min:0, max:100, step:1,
          initial: project.drumVols?.[dk] ?? 80,
          dblClickReset: (dk==="kick" ? 100 : 70),
          format:(v)=>String(v),
          onChange:(v)=>{ project.drumVols[dk] = v; }
        });

        // label doubletap -> color wheel
        attachDoubleTap(lab, () => {
          const start = project.theme.drums[dk] || "#999";
          openColorPicker(start, (hex) => applyDrumColor(dk, hex));
        });

        tn.appendChild(lab);
        tn.appendChild(vol);
        tn.appendChild(vPill);
        namesCol.appendChild(tn);
        updateDrumLabelStyles(dk);

        // right steps row
        const row = document.createElement("div");
        row.className = "rowSteps";
        stepsCol.appendChild(row);
      });

      drumGridEl.appendChild(namesCol);
      drumGridEl.appendChild(stepsCol);

      refreshDrumUI();
      wireDrumPainting();
    }

    function refreshDrumUI(){
      // rebuild step grid widths based on LOOP_STEPS
      const rows = drumGridEl.querySelectorAll(".rowSteps");
      rows.forEach((row, rIdx) => {
        row.innerHTML = "";
        row.style.gridTemplateColumns = `repeat(${LOOP_STEPS}, minmax(0, 1fr))`;

        const dk = drumKeys[rIdx];

        for (let s=0; s<LOOP_STEPS; s++){
          const mi = masterIndexFromLoopStep(s);
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.row = String(rIdx);
          cell.dataset.step = String(s);

          // subtle grouping: every 4 steps
          const group = (Math.floor(s/4) % 2 === 0) ? "groupA" : "groupB";
          cell.classList.add(group);

          // beat divider every 4 (quarter subdivision of 1/16? visually helpful)
          if ((s+1) % 4 === 0) cell.classList.add("beatDivider");

          const on = !!project.drums[dk][mi];
          if (on) cell.classList.add("on", dk);

          row.appendChild(cell);
        }
      });
    }

    function setDrumCell(rowIdx, loopStep, on){
      const dk = drumKeys[rowIdx];
      const mi = masterIndexFromLoopStep(loopStep);
      project.drums[dk][mi] = !!on;
    }

    function wireDrumPainting(){
      // drag paint: only paints the row you started on (your requirement)
      let dragging=false;
      let dragRow=-1;
      let dragMode=null; // "on" or "off"

      const onPointerDown = async (e) => {
        const cell = e.target.closest(".cell");
        if (!cell) return;
        e.preventDefault();
        await ensureRunning();

        dragging = true;
        dragRow = Number(cell.dataset.row);
        const loopStep = Number(cell.dataset.step);
        const dk = drumKeys[dragRow];
        const mi = masterIndexFromLoopStep(loopStep);
        const currentlyOn = !!project.drums[dk][mi];
        dragMode = currentlyOn ? "off" : "on";
        setDrumCell(dragRow, loopStep, dragMode==="on");
        refreshDrumUI();
      };

      const onPointerMove = (e) => {
        if (!dragging) return;
        const cell = e.target.closest(".cell");
        if (!cell) return;
        const rowIdx = Number(cell.dataset.row);
        if (rowIdx !== dragRow) return; // ✅ lock row
        const loopStep = Number(cell.dataset.step);
        setDrumCell(dragRow, loopStep, dragMode==="on");
        cell.classList.add("drag-hover");
      };

      const onPointerUp = () => {
        dragging=false;
        dragRow=-1;
        dragMode=null;
        drumGridEl.querySelectorAll(".cell.drag-hover").forEach(c => c.classList.remove("drag-hover"));
      };

      drumGridEl.addEventListener("pointerdown", onPointerDown, {passive:false});
      drumGridEl.addEventListener("pointermove", onPointerMove, {passive:true});
      window.addEventListener("pointerup", onPointerUp);
      window.addEventListener("pointercancel", onPointerUp);
    }

    /* ===================== PIANO ROLL DRAW + EDIT ===================== */
    // Layout
    const keyW = 110;
    const topPad = 10;
    const leftPad = 0;
    const gridX = keyW + leftPad;
    const gridY = topPad;
    const gridW = rollCanvas.width - gridX - 10;
    const gridH = rollCanvas.height - gridY - 10;
    const rowH = gridH / ROLL_PITCHES;

    function isBlackKey(midi){
      const pc = midi % 12;
      return [1,3,6,8,10].includes(pc);
    }
    function noteName(midi){
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const n = names[midi % 12];
      const oct = Math.floor(midi/12) - 1;
      return `${n}${oct}`;
    }

    function rollColorsForLane(laneKey){
      const lane = LANES.find(l => l.key===laneKey);
      const rgba = getCssVar(lane?.noteVar || "--pianoNote") || "rgba(124,255,178,.85)";
      return rgba;
    }

    function clearCanvas(){
      g.clearRect(0,0,rollCanvas.width, rollCanvas.height);
    }

    function drawRoll(playhead=-1){
      clearCanvas();

      // background strip
      g.fillStyle = getCssVar("--rollBg");
      g.fillRect(0,0,rollCanvas.width, rollCanvas.height);

      // key strip bg
      g.fillStyle = getCssVar("--rollStrip");
      g.fillRect(0,0,keyW, rollCanvas.height);

      // grid bg rows (white/black subtle)
      for (let r=0;r<ROLL_PITCHES;r++){
        const midi = ROLL_TOP_MIDI - r;
        const y = gridY + r*rowH;
        g.fillStyle = isBlackKey(midi) ? getCssVar("--rowBlack") : (r%2===0 ? getCssVar("--rowWhiteA") : getCssVar("--rowWhiteB"));
        g.fillRect(gridX, y, gridW, rowH);
      }

      // vertical grid lines based on LOOP_STEPS
      const cellW = gridW / LOOP_STEPS;

      for (let s=0;s<=LOOP_STEPS;s++){
        const x = gridX + s*cellW;
        const beat = (s % 4 === 0);
        g.strokeStyle = beat ? getCssVar("--gridBeat") : getCssVar("--gridLine");
        g.lineWidth = 1;
        g.beginPath();
        g.moveTo(x, gridY);
        g.lineTo(x, gridY + gridH);
        g.stroke();
      }

      // horizontal lines
      g.strokeStyle = getCssVar("--gridLine");
      for (let r=0;r<=ROLL_PITCHES;r++){
        const y = gridY + r*rowH;
        g.beginPath();
        g.moveTo(gridX, y);
        g.lineTo(gridX + gridW, y);
        g.stroke();
      }

      // draw keys (white/black style + note text)
      for (let r=0;r<ROLL_PITCHES;r++){
        const midi = ROLL_TOP_MIDI - r;
        const y = gridY + r*rowH;

        const blk = isBlackKey(midi);
        g.fillStyle = blk ? (r%2? getCssVar("--blackKeyB") : getCssVar("--blackKeyA")) : (r%2? getCssVar("--whiteKeyB") : getCssVar("--whiteKeyA"));
        g.fillRect(0, y, keyW, rowH);

        g.strokeStyle = getCssVar("--keyBorder");
        g.strokeRect(0, y, keyW, rowH);

        // text color
        g.fillStyle = blk ? "rgba(255,255,255,.88)" : "rgba(0,0,0,.78)";
        g.font = "12px ui-monospace, Menlo, monospace";
        g.textBaseline = "middle";
        g.fillText(noteName(midi), 10, y + rowH/2);
      }

      // notes for active lane
      const laneGrid = project.lanes[activeRoll];
      const noteFill = rollColorsForLane(activeRoll);
      g.fillStyle = noteFill;

      for (let r=0;r<ROLL_PITCHES;r++){
        for (let mi=0; mi<MASTER_STEPS; mi++){
          const len = laneGrid[r][mi];
          if (!len || len <= 0) continue;

          // if this note start is not on a visible resolution boundary, still show it snapped to nearest visible step
          // Compute visible step index range
          const factor = MASTER_STEPS / LOOP_STEPS;
          const startStep = Math.floor(mi / factor);
          const endMi = Math.min(MASTER_STEPS, mi + len);

          const x = gridX + startStep * (gridW/LOOP_STEPS);
          const wSteps = (endMi - mi) / factor;
          const w = (gridW/LOOP_STEPS) * wSteps;

          const y = gridY + r*rowH;
          g.fillRect(x+1, y+2, Math.max(2, w-2), rowH-4);
        }
      }

      // playhead
      if (playhead >= 0){
        const x = gridX + playhead * (gridW/LOOP_STEPS);
        g.strokeStyle = "rgba(255,255,255,.35)";
        g.lineWidth = 2;
        g.beginPath();
        g.moveTo(x, gridY);
        g.lineTo(x, gridY + gridH);
        g.stroke();
      }
    }

    // Piano roll interaction: paint/resize notes
    let rollDrag = null;
    function rollPosToCell(clientX, clientY){
      const rect = rollCanvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (rollCanvas.width / rect.width);
      const y = (clientY - rect.top) * (rollCanvas.height / rect.height);

      if (x < gridX || y < gridY || x > gridX+gridW || y > gridY+gridH) return null;
      const col = clampInt(Math.floor((x - gridX) / (gridW/LOOP_STEPS)), 0, LOOP_STEPS-1);
      const row = clampInt(Math.floor((y - gridY) / rowH), 0, ROLL_PITCHES-1);
      return { col, row };
    }

    function clearNoteAtRowMaster(row, mi){
      // erase any note that overlaps this master index by finding starts
      const grid = project.lanes[activeRoll];
      // if this is a start, clear it
      if (grid[row][mi] > 0){ grid[row][mi] = 0; return; }
      // otherwise find a start behind it that covers it
      for (let s=mi; s>=0; s--){
        const len = grid[row][s];
        if (len > 0 && s + len > mi){
          grid[row][s] = 0;
          return;
        }
      }
    }

    async function previewNote(midi){
      await ensureRunning();
      // quick preview on active instrument
      const base = midi + (transpose[activeRoll] ?? 0);
      playTone(activeRoll, base, ctx.currentTime + 0.01, 0.18, instrumentOscType(activeRoll), instrumentAmp(activeRoll));
    }

    function instrumentOscType(lane){
      if (lane==="bass") return "square";
      if (lane==="bell") return "triangle";
      if (lane==="poly") return "sawtooth";
      if (lane==="pad") return "sine";
      if (lane==="ep") return "triangle";
      return "sine";
    }
    function instrumentAmp(lane){
      if (lane==="bass") return 0.30;
      if (lane==="pad") return 0.18;
      if (lane==="bell") return 0.22;
      if (lane==="poly") return 0.20;
      if (lane==="ep") return 0.22;
      return 0.20;
    }

    rollCanvas.addEventListener("pointerdown", async (e) => {
      const cell = rollPosToCell(e.clientX, e.clientY);
      if (!cell) return;

      e.preventDefault();
      await ensureRunning();
      rollCanvas.setPointerCapture(e.pointerId);

      const factor = MASTER_STEPS / LOOP_STEPS;
      const miStart = cell.col * factor;

      const midi = (ROLL_TOP_MIDI - cell.row);
      // preview always
      previewNote(midi);

      const erase = e.shiftKey || e.button === 2;
      if (erase){
        clearNoteAtRowMaster(cell.row, miStart);
        drawRoll(isPlaying ? currentStep : -1);
        rollDrag = null;
        return;
      }

      // create note start with initial len = factor (one visible cell)
      const grid = project.lanes[activeRoll];
      grid[cell.row][miStart] = factor;

      rollDrag = {
        pid: e.pointerId,
        row: cell.row,
        miStart,
        startCol: cell.col,
        factor
      };

      drawRoll(isPlaying ? currentStep : -1);
    }, {passive:false});

    rollCanvas.addEventListener("pointermove", (e) => {
      if (!rollDrag || e.pointerId !== rollDrag.pid) return;
      const cell = rollPosToCell(e.clientX, e.clientY);
      if (!cell) return;
      if (cell.row !== rollDrag.row) return; // lock row

      const grid = project.lanes[activeRoll];
      const endCol = Math.max(cell.col, rollDrag.startCol);
      const colsLen = (endCol - rollDrag.startCol) + 1;
      const newLen = colsLen * rollDrag.factor;

      grid[rollDrag.row][rollDrag.miStart] = clampInt(newLen, rollDrag.factor, MASTER_STEPS - rollDrag.miStart);
      drawRoll(isPlaying ? currentStep : -1);
    }, {passive:true});

    function endRollDrag(e){
      if (!rollDrag || (e && e.pointerId !== rollDrag.pid)) return;
      rollDrag = null;
    }
    rollCanvas.addEventListener("pointerup", endRollDrag);
    rollCanvas.addEventListener("pointercancel", endRollDrag);
    rollCanvas.addEventListener("lostpointercapture", endRollDrag);

    // prevent context menu so right-click erase doesn't pop menu
    rollCanvas.addEventListener("contextmenu", (e)=>e.preventDefault());

    /* ===================== PLAYBACK SCHEDULER ===================== */
    function scheduleStep(loopStep, time){
      const mi = masterIndexFromLoopStep(loopStep);

      // drums at master index
      drumKeys.forEach(dk => {
        if (project.drums[dk][mi]) playDrum(dk, time);
      });

      // instruments: trigger note starts at master index
      LANES.forEach(l => {
        const grid = project.lanes[l.key];
        for (let r=0;r<ROLL_PITCHES;r++){
          const len = grid[r][mi];
          if (len > 0){
            const baseMidi = (ROLL_TOP_MIDI - r) + (transpose[l.key] ?? 0);
            const durSec = secondsPerMasterStep() * len;
            playTone(l.key, baseMidi, time, durSec, instrumentOscType(l.key), instrumentAmp(l.key));
          }
        }
      });
    }

    function scheduler(){
      if (!isPlaying || !ctx) return;

      while (nextNoteTime < ctx.currentTime + scheduleAhead){
        scheduleStep(currentStep, nextNoteTime);
        currentStep = (currentStep + 1) % LOOP_STEPS;
        nextNoteTime += stepSecondsForCurrentResolution();
      }

      drawRoll(currentStep);
      updateDrumPlayhead();

      timerId = setTimeout(scheduler, lookAhead*1000);
    }

    function updateDrumPlayhead(){
      // highlight current step in drum grid
      const rows = drumGridEl.querySelectorAll(".rowSteps");
      rows.forEach(row => {
        row.querySelectorAll(".cell").forEach(cell => cell.classList.remove("playhead"));
        const c = row.querySelector(`.cell[data-step="${currentStep}"]`);
        if (c) c.classList.add("playhead");
      });
    }

    async function play(){
      await ensureRunning();
      isPlaying = true;
      isPaused = false;

      playBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;

      nextNoteTime = ctx.currentTime + 0.05;
      timerId && clearTimeout(timerId);
      timerId = setTimeout(scheduler, 0);
    }

    function pause(){
      if (!isPlaying) return;
      isPlaying = false;
      isPaused = true;
      timerId && clearTimeout(timerId);
      timerId = null;

      playBtn.disabled = false;
      pauseBtn.disabled = true;
      stopBtn.disabled = false;
    }

    function stop(){
      isPlaying = false;
      isPaused = false;
      timerId && clearTimeout(timerId);
      timerId = null;

      currentStep = 0;

      playBtn.disabled = false;
      pauseBtn.disabled = true;
      stopBtn.disabled = true;

      drawRoll(-1);
      refreshDrumUI();
    }

    function togglePlayPause(){
      if (isPlaying) pause();
      else play();
    }

    playBtn.addEventListener("click", play);
    pauseBtn.addEventListener("click", pause);
    stopBtn.addEventListener("click", stop);

    /* ===================== BPM + RESOLUTION ===================== */
    bpmEl.addEventListener("input", () => {
      bpm = Number(bpmEl.value);
      bpmLabel.textContent = String(bpm);
      project.bpm = bpm;
      // absolute BPM: just changes stepSeconds, doesn't affect resolution stored
    });

    function setResolution(idx){
      resIndex = clampInt(idx, 0, RES_OPTIONS.length-1);
      project.resIndex = resIndex;

      LOOP_STEPS = RES_OPTIONS[resIndex].steps;

      resLabel.textContent = RES_OPTIONS[resIndex].label;
      resText.textContent = RES_OPTIONS[resIndex].label;
      groupText.textContent = RES_OPTIONS[resIndex].label;

      refreshDrumUI();
      drawRoll(isPlaying ? currentStep : -1);
    }

    resEl.addEventListener("input", () => {
      const idx = Number(resEl.value);
      setResolution(idx);
    });

    /* ===================== SAVE / LOAD PROJECT ===================== */
    function downloadText(filename, text){
      const blob = new Blob([text], {type:"application/json"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);
    }

    saveProjectBtn.addEventListener("click", () => {
      const data = structuredClone(project);
      data.bpm = bpm;
      data.resIndex = resIndex;
      downloadText(`project_${Date.now()}.json`, JSON.stringify(data, null, 2));
    });

    loadProjectBtn.addEventListener("click", () => projectFileInput.click());
    projectFileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try{
        const txt = await file.text();
        const obj = JSON.parse(txt);
        loadProjectObject(obj);
      }catch(err){
        console.warn(err);
        alert("Failed to load project JSON.");
      }finally{
        projectFileInput.value = "";
      }
    });

    function loadProjectObject(obj){
      // soft-merge for forwards compatibility
      const fresh = makeEmptyProject();
      project = Object.assign(fresh, obj);

      bpm = Number(project.bpm ?? 115);
      bpmEl.value = String(bpm);
      bpmLabel.textContent = String(bpm);

      // theme
      if (project.theme?.bgBase) applyBgColor(project.theme.bgBase);
      for (const k of drumKeys){
        if (project.theme?.drums?.[k]) applyDrumColor(k, project.theme.drums[k]);
      }
      for (const l of LANES){
        if (project.theme?.lanes?.[l.key]) applyLaneColor(l.key, project.theme.lanes[l.key]);
      }

      // transpose
      LANES.forEach(l => {
        transpose[l.key] = clampInt(project.transpose?.[l.key] ?? 0, -24, 24);
      });
      buildTransposeKnobs();

      // resolution
      setResolution(project.resIndex ?? 2);
      resEl.value = String(resIndex);

      // mixer values used by UI on rebuild
      buildMixer();
      wireMixer();
      ensureAudio(); // ensures nodes exist, not mandatory but keeps routing consistent
      applyAllMixNodes();
      applyBusRouting();

      refreshDrumUI();
      drawRoll(isPlaying ? currentStep : -1);
    }

    /* ===================== DEMO LOAD / CLEAR ===================== */
    async function loadDemo(){
      try{
        const url = new URL(DEMO_JSON_PATH, window.location.href).toString();
        const res = await fetch(url, {cache:"no-store"});
        if (!res.ok) throw new Error(`Missing ${DEMO_JSON_PATH}`);
        const obj = await res.json();
        loadProjectObject(obj);
      }catch(err){
        console.warn(err);
        // fallback: simple starter demo
        const p = makeEmptyProject();
        p.bpm = 115;
        p.resIndex = 2;

        // trap-ish demo
        // kick on 1, and some sync
        [0, 16, 32, 48].forEach(i => p.drums.kick[i] = true);
        [12, 28, 44, 60].forEach(i => p.drums.kick[i] = true);

        // snare on 2/4
        [16, 48].forEach(i => p.drums.snare[i] = true);

        // hats 1/16 w/ rolls
        for (let i=0;i<64;i+=4) p.drums.ch[i] = true;
        [30,31,62,63].forEach(i => p.drums.oh[i]=true);

        // simple chords
        // Abmaj-ish: Ab C Eb
        function putChord(start, len, notes){
          notes.forEach(m => {
            const r = (ROLL_TOP_MIDI - m);
            if (r>=0 && r<ROLL_PITCHES) p.lanes.piano[r][start] = len;
          });
        }
        putChord(0, 16, [68,60,63]);
        putChord(16,16, [65,58,61]);
        putChord(32,16, [63,56,60]);
        putChord(48,16, [61,56,58]);

        loadProjectObject(p);
      }
    }

    loadDemoBtn.addEventListener("click", loadDemo);

    clearProjectBtn.addEventListener("click", () => {
      const keepTheme = structuredClone(project.theme);
      project = makeEmptyProject();
      project.theme = keepTheme;
      bpm = 115; bpmEl.value="115"; bpmLabel.textContent="115";
      setResolution(2); resEl.value="2";
      refreshDrumUI();
      drawRoll(-1);
    });

    /* ===================== MIDI IMPORT (FILE) ===================== */
    importMidiBtn.addEventListener("click", () => midiFileInput.click());
    midiFileInput.addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      try{
        await ensureRunning();
        const ab = await file.arrayBuffer();
        importMidiArrayBufferToLane(ab, activeRoll, { fit: true });
      }catch(err){
        console.warn(err);
        alert("Failed to import MIDI.");
      }finally{
        midiFileInput.value = "";
      }
    });

    function quantizeToMasterSteps(tSec, barSec){
      // convert time within bar to master index 0..63
      const frac = clamp(tSec / barSec, 0, 0.999999);
      return clampInt(Math.floor(frac * MASTER_STEPS), 0, MASTER_STEPS-1);
    }
    function quantizeLenToMasterSteps(dSec, barSec){
      const frac = clamp(dSec / barSec, 0, 4);
      const steps = Math.max(1, Math.round(frac * MASTER_STEPS));
      return clampInt(steps, 1, MASTER_STEPS);
    }

    function importMidiArrayBufferToLane(arrayBuffer, laneKey, {fit=true} = {}){
      const midi = new Midi(arrayBuffer);
      const lane = project.lanes[laneKey];
      if (!lane) return;

      // Clear lane then import (typical DAW behavior)
      project.lanes[laneKey] = emptyLaneGrid();

      // bar length (4 beats)
      const barSec = 4 * (60 / bpm);

      // flatten notes
      const notes = [];
      midi.tracks.forEach(t => (t.notes||[]).forEach(n => notes.push(n)));
      notes.sort((a,b)=>a.time-b.time);

      const fileDur = midi.duration || barSec;
      const scale = fit ? (barSec / Math.max(0.001, fileDur)) : 1;

      for (const n of notes){
        const t = n.time * scale;
        const d = Math.max(0.02, n.duration * scale);

        const mi = quantizeToMasterSteps(t % barSec, barSec);
        const len = quantizeLenToMasterSteps(d, barSec);

        const midiNum = n.midi;
        if (midiNum < ROLL_BASE_MIDI || midiNum > ROLL_TOP_MIDI) continue;

        const row = ROLL_TOP_MIDI - midiNum;
        // only write start if empty (avoid stomp; simple)
        project.lanes[laneKey][row][mi] = Math.min(len, MASTER_STEPS - mi);
      }

      drawRoll(isPlaying ? currentStep : -1);
    }

    // helper: import without changing active roll
    function importMidiArrayBufferToLaneNoSwitch(arrayBuffer, laneKey, {fit=true}={}){
      const prev = activeRoll;
      importMidiArrayBufferToLane(arrayBuffer, laneKey, {fit});
      activeRoll = prev;
      drawRoll(isPlaying ? currentStep : -1);
    }

    /* ===================== MIDI LIBRARY (AUTO-DETECT INCLUDED) ===================== */
    let midiIndex = null;
    let activePackIdx = 0;

    midiLibraryBtn.addEventListener("click", showMidiModal);
    closeMidiModal.addEventListener("click", hideMidiModal);
    midiModalOverlay.addEventListener("click", (e) => { if (e.target === midiModalOverlay) hideMidiModal(); });
    refreshMidiIndex.addEventListener("click", () => loadMidiIndex(true));
    midiSearch.addEventListener("input", () => renderMidiLibrary());
    window.addEventListener("keydown", (e) => {
      if (!midiModalOverlay.classList.contains("show")) return;
      if (e.key === "Escape") hideMidiModal();
    });

    function showMidiModal(){
      const sug = suggestedLane ? laneLabel(suggestedLane) : laneLabel(activeRoll);
      targetLaneBadge.textContent = `Suggested: ${sug} • Current: ${laneLabel(activeRoll)}`;
      midiModalOverlay.classList.add("show");
      midiModalOverlay.setAttribute("aria-hidden","false");
      midiSearch.value = "";
      midiFileStatus.textContent = "";
      loadMidiIndex();
    }
    function hideMidiModal(){
      midiModalOverlay.classList.remove("show");
      midiModalOverlay.setAttribute("aria-hidden","true");
    }

    async function loadMidiIndex(force=false){
      midiIndexStatus.textContent = "Loading MIDI index…";
      fileListEl.innerHTML = "";
      packListEl.innerHTML = "";
      try{
        const url = new URL(MIDI_INDEX_PATH, window.location.href).toString();
        const res = await fetch(url, { cache: force ? "no-store" : "default" });
        if (!res.ok) throw new Error(`Failed to load ${MIDI_INDEX_PATH} (${res.status})`);
        midiIndex = await res.json();
        activePackIdx = 0;
        midiIndexStatus.textContent = `Loaded ${midiIndex?.packs?.length ?? 0} packs from /midi`;
        renderMidiLibrary();
      }catch(err){
        console.warn(err);
        midiIndexStatus.textContent =
          `Couldn’t load ${MIDI_INDEX_PATH}.\n` +
          `Make sure /midi/index.json exists and is committed (GitHub Pages won’t list directories).`;
      }
    }

    function renderMidiLibrary(){
      const q = (midiSearch.value || "").trim().toLowerCase();
      const packs = Array.isArray(midiIndex?.packs) ? midiIndex.packs : [];

      const filtered = packs.map((p, idx) => {
        const files = Array.isArray(p.files) ? p.files : [];
        const packMatch = (p.name || "").toLowerCase().includes(q);
        const fileMatch = files.some(f => (f.name||f.file||"").toLowerCase().includes(q));
        const keep = !q || packMatch || fileMatch;
        return { pack:p, idx, keep };
      }).filter(x => x.keep);

      packListEl.innerHTML = "";
      if (!filtered.length){
        packListEl.innerHTML = `<div class="status">No packs match “${escapeHtml(q)}”.</div>`;
        fileListEl.innerHTML = "";
        return;
      }

      const foundActive = filtered.find(x => x.idx === activePackIdx);
      if (!foundActive) activePackIdx = filtered[0].idx;

      filtered.forEach(({pack, idx}) => {
        const el = document.createElement("div");
        el.className = "pack" + (idx === activePackIdx ? " active" : "");
        el.innerHTML = `
          <div class="packName">${escapeHtml(pack.name || `Pack ${idx+1}`)}</div>
          <div class="packMeta">${(pack.files?.length ?? 0)} files • /midi/${escapeHtml(pack.path || "")}</div>
        `;
        el.addEventListener("click", () => {
          activePackIdx = idx;
          renderMidiLibrary();
        });
        packListEl.appendChild(el);
      });

      const pack = packs[activePackIdx] || filtered[0].pack;
      renderFileList(pack, q);
    }

    function buildMidiPath(pack, file){
      const p = (pack?.path || "").replace(/^\/+|\/+$/g,"");
      const f = (file?.file || "").replace(/^\/+/g,"");
      return `midi/${p}/${f}`;
    }

    async function fetchMidiArrayBuffer(path){
      const url = new URL(path, window.location.href).toString();
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to fetch MIDI: ${path} (${res.status})`);
      return await res.arrayBuffer();
    }

    function renderFileList(pack, q){
      fileListEl.innerHTML = "";
      const files = Array.isArray(pack?.files) ? pack.files : [];
      const filteredFiles = files.filter(f => {
        if (!q) return true;
        return ((f.name || f.file || "").toLowerCase().includes(q)) || ((pack.name||"").toLowerCase().includes(q));
      });

      if (!filteredFiles.length){
        fileListEl.innerHTML = `<div class="status">No files match “${escapeHtml(q)}” in this pack.</div>`;
        return;
      }

      filteredFiles.forEach((f) => {
        const filename = (f.name || f.file || "");
        const guess = suggestLaneFromName(filename);

        suggestedLane = guess;
        targetLaneBadge.textContent = `Suggested: ${laneLabel(suggestedLane)} • Current: ${laneLabel(activeRoll)}`;

        const row = document.createElement("div");
        row.className = "fileRow";

        const left = document.createElement("div");
        left.style.minWidth = "0";
        left.innerHTML = `<div class="fileName">${escapeHtml(f.name || f.file)}</div>`;

        const btns = document.createElement("div");
        btns.className = "fileBtns";

        const importBtn = document.createElement("button");
        importBtn.className = "miniBtn primary";
        importBtn.textContent = `Import → ${laneLabel(guess)}`;

        importBtn.addEventListener("click", async () => {
          await importMidiFromLibrary(pack, f);
        });

        btns.appendChild(importBtn);
        row.appendChild(left);
        row.appendChild(btns);
        fileListEl.appendChild(row);
      });

      midiFileStatus.textContent =
        `Auto-detect suggests a lane from filename; if name is generic, MIDI pitch-range can override.`;
    }

    async function importMidiFromLibrary(pack, file){
      try{
        midiFileStatus.textContent = `Importing…`;
        await ensureRunning();

        const filename = (file?.name || file?.file || "");
        const nameGuess = suggestLaneFromName(filename);

        const ab = await fetchMidiArrayBuffer(buildMidiPath(pack, file));
        let finalLane = nameGuess;

        try{
          const midi = new Midi(ab);
          const generic = !/(bass|808|sub|piano|keys|chords|lead|arp|pad|bell|poly|synth|pluck|ep|rhodes)/i.test(filename);
          if (generic) finalLane = suggestLaneFromMidi(midi);
        }catch{ /* ignore */ }

        // ✅ import into suggested lane WITHOUT changing activeRoll
        importMidiArrayBufferToLaneNoSwitch(ab, finalLane, { fit: !!fitToLoop.checked });

        suggestedLane = finalLane;
        targetLaneBadge.textContent = `Suggested: ${laneLabel(finalLane)} • Current: ${laneLabel(activeRoll)}`;
        midiFileStatus.textContent = `Imported into ${laneLabel(finalLane)}: ${filename}`;
      }catch(err){
        console.warn(err);
        midiFileStatus.textContent = `Import failed. Check file path + /midi/index.json entries.`;
      }
    }

    /* ===================== BACKGROUND BUTTON ===================== */
    bgBtn.addEventListener("click", () => {
      openColorPicker(project.theme.bgBase || "#0f1115", (hex) => applyBgColor(hex));
    });
    attachDoubleTap(bgBtn, () => {
      openColorPicker(project.theme.bgBase || "#0f1115", (hex) => applyBgColor(hex));
    });

    /* ===================== INIT + APPLY THEME ===================== */
    function applyThemeFromProject(){
      applyBgColor(project.theme.bgBase || "#0f1115");
      drumKeys.forEach(k => applyDrumColor(k, project.theme.drums[k] || getCssVar(`--${k}`)));
      LANES.forEach(l => applyLaneColor(l.key, project.theme.lanes[l.key] || "#888"));
    }

    function init(){
      // default BPM + resolution
      bpm = 115;
      bpmEl.value = "115";
      bpmLabel.textContent = "115";

      setResolution(2);
      resEl.value = "2";

      // theme init
      applyThemeFromProject();

      buildTabs();
      buildTransposeKnobs();

      buildMixer();
      wireMixer();

      buildDrumGrid();

      // instrument button colors on selection (tabs)
      updateActiveTabStyles();

      // initial render
      drawRoll(-1);

      // load demo from /demos/demo01.json if present
      loadDemo();
    }

    /* ===================== TRANSPORT BUTTONS ===================== */
    // (already wired above)

    init();
  })();
  </script>
</body>
</html>
