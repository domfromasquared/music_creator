<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>RetroLoop Studio — Drum Sequencer + Piano Roll</title>
  <style>
    :root{
      --bg:#0f1115;
      --ink:#e9eef5;
      --muted:#97a3b6;

      --btn:#22283a;
      --btn2:#2a3150;

      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 14px;

      /* Drum 4-step grouping */
      --groupA:#121a28;
      --groupB:#211a2f;
      --inactiveOverlay: rgba(0,0,0,0.38);
      --playheadOutline: rgba(255,255,255,0.30);
      --beatDivider: rgba(255,255,255,0.18);
      --dragOutline: rgba(255,255,255,0.45);
      --dragFill: rgba(255,255,255,0.10);

      /* Drum instrument colors */
      --kick: rgba(255,139,90,0.95);
      --hat: rgba(124,255,178,0.92);
      --snare: rgba(88,166,255,0.92);
      --clap: rgba(255,255,255,0.88);

      /* Piano roll */
      --rollBg: rgba(0,0,0,.18);
      --rollStrip: rgba(0,0,0,.32);
      --gridLine: rgba(255,255,255,.06);
      --gridBeat: rgba(255,255,255,.14);

      /* Piano keys */
      --whiteKeyA: rgba(255,255,255,0.92);
      --whiteKeyB: rgba(255,255,255,0.82);
      --blackKeyA: rgba(12,14,20,0.98);
      --blackKeyB: rgba(22,24,32,0.98);
      --keyBorder: rgba(0,0,0,0.35);

      /* Row shading on grid (black keys darker) */
      --rowWhiteA: rgba(255,255,255,.03);
      --rowWhiteB: rgba(255,255,255,.015);
      --rowBlack: rgba(0,0,0,.22);

      /* Notes */
      --melNote: rgba(124,255,178,.85);
      --bassNote: rgba(88,166,255,.80);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 20% -10%, #1b2040 0%, transparent 60%),
                  radial-gradient(900px 500px at 90% 0%, #223022 0%, transparent 55%),
                  var(--bg);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 18px;
    }
    h1{margin:0 0 6px 0; font-size:18px; letter-spacing:.2px}
    .sub{color:var(--muted); margin:0 0 16px 0; font-size:13px}

    .wrap{
      display:grid;
      grid-template-columns: 410px 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.07);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .title{
      font-size:13px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.12em
    }
    .bd{padding: 12px}

    button{
      background: linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ink);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 9px 12px;
      font-weight: 700;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:disabled{opacity:.5; cursor:not-allowed}

    .btnRow{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--muted);
      display:flex; gap:8px; align-items:center;
    }
    input[type="range"]{width: 150px}
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      padding:1px 6px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:8px;
      background: rgba(0,0,0,.25);
      color: var(--ink);
    }
    .hint{color:var(--muted); font-size:12px; margin-top:10px; line-height:1.35}

    /* Drum grid */
    .drumGrid{
      display:grid;
      grid-template-columns: 170px 1fr;
      gap:10px;
      align-items:start;
      touch-action: none;
    }
    .trackNames{
      display:grid;
      gap:8px;
    }
    .trackName{
      height:40px;
      border-radius: 12px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 8px 10px;
      user-select:none;
      gap:10px;
    }
    .trackLabel{
      font-size:12px;
      color: var(--muted);
      width:54px;
      text-transform:uppercase;
      letter-spacing:.08em;
      flex: 0 0 auto;
    }
    .volWrap{
      display:flex;
      align-items:center;
      gap:8px;
      flex:1;
      min-width:0;
    }
    .volWrap input[type="range"]{
      width: 100%;
      min-width: 74px;
    }
    .volVal{
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      width: 40px;
      text-align:center;
      flex: 0 0 auto;
    }

    /* Steps container scrolls horizontally (no overlap at 1/64) */
    .steps{
      display:grid;
      gap:8px;
      overflow-x: auto;
      overflow-y: hidden;
      padding-bottom: 2px;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-x;
      border-radius: 12px;
    }
    .rowSteps{
      display:grid;
      gap:6px;
      height:40px;
      align-items:stretch;
      touch-action: none;
      width: max-content;
    }

    .cell{
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      position:relative;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }

    .cell.groupA{ background: var(--groupA); }
    .cell.groupB{ background: var(--groupB); }

    .cell::after{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.38);
      opacity:.55;
      pointer-events:none;
    }

    .cell.on::after{opacity:.07}
    .cell.on.kick{ background: linear-gradient(180deg, var(--kick), rgba(255,139,90,0.45)); border-color: rgba(255,139,90,0.75); }
    .cell.on.hat{  background: linear-gradient(180deg, var(--hat),  rgba(124,255,178,0.30)); border-color: rgba(124,255,178,0.65); }
    .cell.on.snare{background: linear-gradient(180deg, var(--snare),rgba(88,166,255,0.30)); border-color: rgba(88,166,255,0.65); }
    .cell.on.clap{ background: linear-gradient(180deg, var(--clap), rgba(255,255,255,0.18)); border-color: rgba(255,255,255,0.45); }

    .cell.beatDivider{ box-shadow: inset -2px 0 0 rgba(255,255,255,0.18); }
    .cell.playhead{
      outline: 2px solid rgba(255,255,255,0.30);
      outline-offset: 1px;
    }
    .cell.drag-hover{
      outline: 2px solid rgba(255,255,255,0.45);
      outline-offset: -2px;
      box-shadow: inset 0 0 0 999px rgba(255,255,255,0.10);
    }

    /* Piano roll */
    .tabs{display:flex; gap:8px}
    .tab{
      padding: 7px 10px;
      border-radius: 999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .tab.active{
      background: rgba(124,255,178,.14);
      border-color: rgba(124,255,178,.35);
      color: var(--ink);
    }

    .rollWrap{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);
      border-radius: 14px;
      overflow:hidden;
      touch-action: none;
    }
    canvas{display:block; width:100%; height:auto; touch-action:none}
  </style>
</head>
<body>
  <h1>RetroLoop Studio</h1>
  <p class="sub">4/4 • Drum sequencer + piano roll • Resolution: <span class="kbd" id="resText">1/16</span> • Keys: C3 → C5</p>

  <div class="wrap">
    <div class="card">
      <div class="hd">
        <div class="title">Transport</div>
        <div class="btnRow">
          <button id="playBtn">Play</button>
          <button id="pauseBtn" disabled>Pause</button>
          <button id="stopBtn" disabled>Stop</button>
        </div>
      </div>
      <div class="bd">
        <div class="btnRow" style="margin-bottom:10px;">
          <div class="pill">
            <span style="min-width:38px;">BPM</span>
            <input id="bpm" type="range" min="70" max="180" value="120"/>
            <span id="bpmLabel" class="kbd">120</span>
          </div>

          <!-- 3-step resolution slider -->
          <div class="pill">
            <span>Resolution</span>
            <input id="resolution" type="range" min="0" max="2" step="1" value="0"/>
            <span id="resolutionLabel" class="kbd">1/16</span>
          </div>
        </div>

        <div class="btnRow" style="margin-bottom:10px;">
          <div class="pill">
            <span>Mel</span><input id="melVol" type="range" min="0" max="1" step="0.01" value="0.35"/>
          </div>
          <div class="pill">
            <span>Bass</span><input id="bassVol" type="range" min="0" max="1" step="0.01" value="0.40"/>
          </div>
          <div class="pill">
            <span>Drum Bus</span><input id="drumVol" type="range" min="0" max="1" step="0.01" value="0.85"/>
          </div>
        </div>

        <div class="btnRow">
          <button id="clearDrums">Clear Drums</button>
          <button id="clearNotes">Clear Notes</button>
          <button id="demoFill">Demo Fill</button>
        </div>

        <p class="hint">
          <span class="kbd">Space</span> toggles Play/Pause (desktop).<br/>
          Drums: press + drag to paint (mouse/touch). Painting stays on the row you started on.<br/>
          Resolution changes <b>do not delete</b> anything — they only change how the master 1/64 grid is viewed/played.
        </p>
      </div>
    </div>

    <div class="card">
      <div class="hd">
        <div class="title">Drum Sequencer</div>
        <div class="pill">
          <span>Resolution</span>
          <span class="kbd" id="groupText">1/16</span>
        </div>
      </div>
      <div class="bd">
        <div class="drumGrid" id="drumGrid"></div>
      </div>
    </div>

    <div class="card" style="grid-column: 1 / -1;">
      <div class="hd">
        <div class="title">Piano Roll</div>
        <div class="tabs">
          <div class="tab active" data-roll="melody">Melody</div>
          <div class="tab" data-roll="bass">Bass</div>
        </div>
      </div>
      <div class="bd">
        <div class="rollWrap">
          <canvas id="roll" width="1280" height="560"></canvas>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ----------------------------
  // RESOLUTION OPTIONS (3 only)
  // ----------------------------
  const RES_OPTIONS = [
    { label: "1/16", stepsPerBar: 16 },
    { label: "1/32", stepsPerBar: 32 },
    { label: "1/64", stepsPerBar: 64 },
  ];

  // Master grid is always 1/64 (64 steps per bar)
  const MASTER_STEPS = 64;

  // Piano roll range: C3 -> C5 inclusive
  const ROLL_BASE_MIDI = 48; // C3
  const ROLL_TOP_MIDI  = 72; // C5
  const ROLL_PITCHES   = (ROLL_TOP_MIDI - ROLL_BASE_MIDI) + 1; // 25

  // ----------------------------
  // STATE
  // ----------------------------
  const drumNames = ["Kick", "Clap", "Hat", "Snare"];
  const drumKeys  = ["kick", "clap", "hat", "snare"];

  // Master patterns persist forever (resolution changes never delete)
  const drumsMaster = {
    kick:  new Array(MASTER_STEPS).fill(false),
    clap:  new Array(MASTER_STEPS).fill(false),
    hat:   new Array(MASTER_STEPS).fill(false),
    snare: new Array(MASTER_STEPS).fill(false),
  };
  const melodyMaster = Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0));
  const bassMaster   = Array.from({length: ROLL_PITCHES}, () => new Array(MASTER_STEPS).fill(0));

  // Visible / loop length
  let stepsPerBar = 16;     // 16/32/64
  let TOTAL_STEPS = 16;     // display steps in current resolution
  let STEP_FACTOR = 4;      // MASTER_STEPS / TOTAL_STEPS (4 for 1/16, 2 for 1/32, 1 for 1/64)

  // Playback
  let ctx = null;
  let master = null, melBus = null, bassBus = null, drumBus = null;
  const drumGains = { kick:null, clap:null, hat:null, snare:null };

  let isPlaying = false;
  let isPaused = false;
  let currentStep = 0;      // display step index 0..TOTAL_STEPS-1
  let nextNoteTime = 0;
  let timerId = null;

  let bpm = 120;

  const lookAhead = 0.025;
  const scheduleAhead = 0.12;

  // ----------------------------
  // UI refs
  // ----------------------------
  const playBtn = document.getElementById("playBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const stopBtn = document.getElementById("stopBtn");

  const bpmEl = document.getElementById("bpm");
  const bpmLabel = document.getElementById("bpmLabel");

  const resEl = document.getElementById("resolution");
  const resLabel = document.getElementById("resolutionLabel");
  const resText = document.getElementById("resText");
  const groupText = document.getElementById("groupText");

  const melVol = document.getElementById("melVol");
  const bassVol = document.getElementById("bassVol");
  const drumVol = document.getElementById("drumVol");

  const clearDrumsBtn = document.getElementById("clearDrums");
  const clearNotesBtn = document.getElementById("clearNotes");
  const demoFillBtn = document.getElementById("demoFill");

  const drumGridEl = document.getElementById("drumGrid");
  const rollCanvas = document.getElementById("roll");
  const g = rollCanvas.getContext("2d");

  // Tabs
  let activeRoll = "melody";
  document.querySelectorAll(".tab").forEach(t => {
    t.addEventListener("click", () => {
      document.querySelectorAll(".tab").forEach(x => x.classList.remove("active"));
      t.classList.add("active");
      activeRoll = t.dataset.roll;
      drawRoll(isPlaying ? currentStep : -1);
    });
  });

  bpmEl.addEventListener("input", () => {
    bpm = Number(bpmEl.value);
    bpmLabel.textContent = String(bpm);
  });

  // ----------------------------
  // Spacebar Play/Pause (desktop)
  // ----------------------------
  function isTypingTarget(el){
    if (!el) return false;
    const tag = (el.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || el.isContentEditable;
  }
  window.addEventListener("keydown", (e) => {
    if (e.code !== "Space") return;
    if (isTypingTarget(document.activeElement)) return;
    e.preventDefault();
    togglePlayPause();
  }, {passive:false});

  // ----------------------------
  // RESOLUTION MAPPING (fix BPM feel + preserve timing)
  // ----------------------------
  function updateStepFactor(){
    TOTAL_STEPS = stepsPerBar;
    STEP_FACTOR = MASTER_STEPS / TOTAL_STEPS; // 4, 2, or 1
  }
  function displayToMasterStep(displayStep){
    return displayStep * STEP_FACTOR;
  }

  // ----------------------------
  // AUDIO
  // ----------------------------
  const AudioContext = window.AudioContext || window.webkitAudioContext;

  function ensureAudio(){
    if (ctx) return;

    ctx = new AudioContext();

    master = ctx.createGain();
    master.gain.value = 0.9;
    master.connect(ctx.destination);

    melBus = ctx.createGain();
    bassBus = ctx.createGain();
    drumBus = ctx.createGain();

    melBus.gain.value = Number(melVol.value);
    bassBus.gain.value = Number(bassVol.value);
    drumBus.gain.value = Number(drumVol.value);

    drumGains.kick = ctx.createGain(); drumGains.kick.gain.value = 1;
    drumGains.clap = ctx.createGain(); drumGains.clap.gain.value = 1;
    drumGains.hat  = ctx.createGain(); drumGains.hat.gain.value  = 1;
    drumGains.snare= ctx.createGain(); drumGains.snare.gain.value= 1;

    drumGains.kick.connect(drumBus);
    drumGains.clap.connect(drumBus);
    drumGains.hat.connect(drumBus);
    drumGains.snare.connect(drumBus);

    melBus.connect(master);
    bassBus.connect(master);
    drumBus.connect(master);

    melVol.addEventListener("input", () => melBus.gain.value = Number(melVol.value));
    bassVol.addEventListener("input", () => bassBus.gain.value = Number(bassVol.value));
    drumVol.addEventListener("input", () => drumBus.gain.value = Number(drumVol.value));
  }

  async function ensureRunning(){
    ensureAudio();
    if (ctx.state !== "running") await ctx.resume();
  }

  function midiToHz(midi){
    return 440 * Math.pow(2, (midi - 69) / 12);
  }

  function playNote(freq, time, dur, bus, type, peak){
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const lp = ctx.createBiquadFilter();

    osc.type = type;
    osc.frequency.setValueAtTime(freq, time);

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(peak, time + 0.01);

    const rel = Math.max(0.02, Math.min(0.14, dur * 0.25));
    gain.gain.exponentialRampToValueAtTime(0.0001, time + dur + rel);

    lp.type = "lowpass";
    lp.frequency.setValueAtTime(type === "square" ? 4200 : 2400, time);

    osc.connect(lp).connect(gain).connect(bus);
    osc.start(time);
    osc.stop(time + dur + rel + 0.03);
  }

  async function previewMidi(midi){
    await ensureRunning();
    const hz = midiToHz(midi);
    const now = ctx.currentTime + 0.001;
    const bus = (activeRoll === "melody") ? melBus : bassBus;
    const type = (activeRoll === "melody") ? "square" : "triangle";
    playNote(hz, now, 0.12, bus, type, (activeRoll === "melody") ? 0.18 : 0.22);
  }

  // Drum synths
  let noiseBuf = null;
  function getNoiseBuffer(){
    if (noiseBuf) return noiseBuf;
    const len = ctx.sampleRate * 0.3;
    const b = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = b.getChannelData(0);
    for (let i=0;i<len;i++) d[i] = Math.random()*2 - 1;
    noiseBuf = b;
    return b;
  }

  function playKick(time){
    const out = drumGains.kick;

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(160, time);
    osc.frequency.exponentialRampToValueAtTime(50, time + 0.09);

    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(1.0, time + 0.004);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.14);

    const click = ctx.createOscillator();
    const cg = ctx.createGain();
    click.type = "square";
    click.frequency.setValueAtTime(900, time);
    cg.gain.setValueAtTime(0.18, time);
    cg.gain.exponentialRampToValueAtTime(0.0001, time + 0.01);

    osc.connect(gain).connect(out);
    click.connect(cg).connect(out);

    osc.start(time); osc.stop(time + 0.16);
    click.start(time); click.stop(time + 0.02);
  }

  function playSnare(time){
    const out = drumGains.snare;

    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1800, time);
    bp.Q.setValueAtTime(0.8, time);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.9, time + 0.003);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.10);

    const osc = ctx.createOscillator();
    const og = ctx.createGain();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(220, time);
    og.gain.setValueAtTime(0.0001, time);
    og.gain.exponentialRampToValueAtTime(0.24, time + 0.004);
    og.gain.exponentialRampToValueAtTime(0.0001, time + 0.08);

    src.connect(bp).connect(gain).connect(out);
    osc.connect(og).connect(out);

    src.start(time); src.stop(time + 0.12);
    osc.start(time); osc.stop(time + 0.10);
  }

  function playHat(time){
    const out = drumGains.hat;

    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(7000, time);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.exponentialRampToValueAtTime(0.35, time + 0.002);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.04);

    src.connect(hp).connect(gain).connect(out);
    src.start(time); src.stop(time + 0.06);
  }

  function playClap(time){
    const out = drumGains.clap;

    const burstTimes = [0, 0.012, 0.024];
    burstTimes.forEach(dt => {
      const t = time + dt;
      const src = ctx.createBufferSource();
      src.buffer = getNoiseBuffer();

      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(2200, t);
      bp.Q.setValueAtTime(0.7, t);

      const gain = ctx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.55, t + 0.002);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.07);

      src.connect(bp).connect(gain).connect(out);
      src.start(t); src.stop(t + 0.09);
    });
  }

  // ----------------------------
  // DRUM GRID UI + PAINTING (row-locked + mapped to master steps)
  // ----------------------------
  function buildDrumGrid(){
    drumGridEl.innerHTML = "";

    const namesCol = document.createElement("div");
    namesCol.className = "trackNames";

    const stepsCol = document.createElement("div");
    stepsCol.className = "steps";

    drumKeys.forEach((key, idx) => {
      const nameRow = document.createElement("div");
      nameRow.className = "trackName";

      const label = document.createElement("div");
      label.className = "trackLabel";
      label.textContent = drumNames[idx];

      const volWrap = document.createElement("div");
      volWrap.className = "volWrap";

      const vol = document.createElement("input");
      vol.type = "range";
      vol.min = "0";
      vol.max = "100";
      vol.step = "1";
      vol.value = "100";

      const val = document.createElement("div");
      val.className = "volVal";
      val.textContent = "100";

      vol.addEventListener("input", () => {
        val.textContent = String(vol.value);
        const x = Number(vol.value) / 100;
        const gain = x * x;
        ensureAudio();
        drumGains[key].gain.value = gain;
      });

      volWrap.appendChild(vol);
      volWrap.appendChild(val);

      nameRow.appendChild(label);
      nameRow.appendChild(volWrap);
      namesCol.appendChild(nameRow);

      const row = document.createElement("div");
      row.className = "rowSteps";

      // cell width heuristic (readable + scroll for bigger grids)
      const cellW = (TOTAL_STEPS <= 16) ? 34 : (TOTAL_STEPS <= 32 ? 26 : 18);
      row.style.gridTemplateColumns = `repeat(${TOTAL_STEPS}, ${cellW}px)`;

      for (let s = 0; s < TOTAL_STEPS; s++){
        const cell = document.createElement("div");
        cell.className = "cell";

        const group = Math.floor(s / 4) % 2;
        cell.classList.add(group === 0 ? "groupA" : "groupB");

        cell.classList.add(key);

        if ((s+1) % 4 === 0 && s !== TOTAL_STEPS-1) cell.classList.add("beatDivider");

        cell.dataset.track = key;
        cell.dataset.step = String(s); // display step
        cell.ondragstart = () => false;

        row.appendChild(cell);
      }

      stepsCol.appendChild(row);
    });

    drumGridEl.appendChild(namesCol);
    drumGridEl.appendChild(stepsCol);

    enableDrumPainting(stepsCol);
    refreshDrumUI();
  }

  function refreshDrumUI(){
    const rows = drumGridEl.querySelectorAll(".rowSteps");
    drumKeys.forEach((k, r) => {
      const row = rows[r];
      if (!row) return;
      for (let s=0; s<TOTAL_STEPS; s++){
        const ms = displayToMasterStep(s);
        row.children[s].classList.toggle("on", drumsMaster[k][ms]);
      }
    });
  }

  function updatePlayheadUI(displayStep){
    drumGridEl.querySelectorAll(".cell").forEach(c => c.classList.remove("playhead"));
    if (displayStep < 0) return;
    const rows = drumGridEl.querySelectorAll(".rowSteps");
    drumKeys.forEach((_, rIdx) => {
      const row = rows[rIdx];
      const cell = row && row.children[displayStep];
      if (cell) cell.classList.add("playhead");
    });
  }

  let drumPaint = { active:false, pointerId:null, value:true, visited:new Set(), track:null };

  function cellFromPoint(clientX, clientY){
    const el = document.elementFromPoint(clientX, clientY);
    if (!el) return null;
    return el.classList && el.classList.contains("cell") ? el : null;
  }
  function clearDragHover(){
    drumGridEl.querySelectorAll(".cell.drag-hover").forEach(c => c.classList.remove("drag-hover"));
  }
  function applyDrumCell(cell, value){
    const key = cell.dataset.track;
    if (drumPaint.track && key !== drumPaint.track) return;

    const ds = Number(cell.dataset.step);
    const ms = displayToMasterStep(ds);

    const id = `${key}:${ds}`;
    if (drumPaint.visited.has(id)) return;
    drumPaint.visited.add(id);

    drumsMaster[key][ms] = value;
    cell.classList.toggle("on", value);
    cell.classList.add("drag-hover");
  }

  function enableDrumPainting(container){
    container.addEventListener("pointerdown", (e) => {
      const cell = e.target.closest(".cell");
      if (!cell) return;
      e.preventDefault();

      drumPaint.active = true;
      drumPaint.pointerId = e.pointerId;
      drumPaint.visited.clear();
      clearDragHover();

      const key = cell.dataset.track;
      const ds = Number(cell.dataset.step);
      const ms = displayToMasterStep(ds);

      drumPaint.track = key;
      drumPaint.value = !drumsMaster[key][ms];

      container.setPointerCapture(e.pointerId);
      applyDrumCell(cell, drumPaint.value);
    }, {passive:false});

    container.addEventListener("pointermove", (e) => {
      if (!drumPaint.active) return;
      if (drumPaint.pointerId !== e.pointerId) return;
      e.preventDefault();

      const cell = cellFromPoint(e.clientX, e.clientY);
      if (!cell) return;
      applyDrumCell(cell, drumPaint.value);
    }, {passive:false});

    const end = (e) => {
      if (!drumPaint.active) return;
      if (drumPaint.pointerId !== e.pointerId) return;
      drumPaint.active = false;
      drumPaint.pointerId = null;
      drumPaint.track = null;
      drumPaint.visited.clear();
      setTimeout(clearDragHover, 40);
    };

    container.addEventListener("pointerup", end);
    container.addEventListener("pointercancel", end);
    container.addEventListener("lostpointercapture", () => {
      drumPaint.active = false;
      drumPaint.pointerId = null;
      drumPaint.track = null;
      drumPaint.visited.clear();
      setTimeout(clearDragHover, 40);
    });
  }

  // ----------------------------
  // PIANO ROLL (mapped to master steps)
  // ----------------------------
  const KEY_PAD = 128;

  function isBlackKey(midi){
    const pc = midi % 12;
    return pc === 1 || pc === 3 || pc === 6 || pc === 8 || pc === 10;
  }

  function midiNameFlat(m){
    const pc = m % 12;
    const oct = Math.floor(m/12) - 1;
    const names = { 0:"C", 1:"Db", 2:"D", 3:"Eb", 4:"E", 5:"F", 6:"Gb", 7:"G", 8:"Ab", 9:"A", 10:"Bb", 11:"B" };
    return `${names[pc]}${oct}`;
  }

  function css(varName){
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  function drawRoll(playheadDisplayStep = -1){
    const W = rollCanvas.width;
    const H = rollCanvas.height;

    const grid = (activeRoll === "melody") ? melodyMaster : bassMaster;

    const leftPad = KEY_PAD;
    const cellW = (W - leftPad) / TOTAL_STEPS;
    const cellH = H / ROLL_PITCHES;

    g.clearRect(0,0,W,H);
    g.fillStyle = css("--rollBg");
    g.fillRect(0,0,W,H);

    // row shading
    for (let p=0; p<ROLL_PITCHES; p++){
      const midi = ROLL_BASE_MIDI + p;
      const y = H - (p+1)*cellH;

      g.fillStyle = isBlackKey(midi) ? css("--rowBlack") : ((p % 2 === 0) ? css("--rowWhiteA") : css("--rowWhiteB"));
      g.fillRect(leftPad, y, W-leftPad, cellH);
    }

    // grid lines (display)
    for (let s=0; s<=TOTAL_STEPS; s++){
      const x = leftPad + s*cellW;
      g.strokeStyle = (s % 4 === 0) ? css("--gridBeat") : css("--gridLine");
      g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke();
    }
    for (let p=0; p<=ROLL_PITCHES; p++){
      const y = p*cellH;
      g.strokeStyle = css("--gridLine");
      g.beginPath(); g.moveTo(leftPad,y); g.lineTo(W,y); g.stroke();
    }

    // keys strip
    g.fillStyle = css("--rollStrip");
    g.fillRect(0,0,leftPad,H);

    // key rows with labels
    for (let p=0; p<ROLL_PITCHES; p++){
      const midi = ROLL_BASE_MIDI + p;
      const y = H - (p+1)*cellH;
      const black = isBlackKey(midi);

      if (!black){
        const grad = g.createLinearGradient(0,y,0,y+cellH);
        grad.addColorStop(0, css("--whiteKeyA"));
        grad.addColorStop(1, css("--whiteKeyB"));
        g.fillStyle = grad;
        g.fillRect(6, y+1, leftPad-12, cellH-2);
        g.strokeStyle = css("--keyBorder");
        g.strokeRect(6.5, y+1.5, leftPad-13, cellH-3);

        g.fillStyle = "rgba(0,0,0,0.80)";
        g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
        g.fillText(midiNameFlat(midi), 12, y + cellH*0.68);
      } else {
        const grad = g.createLinearGradient(0,y,0,y+cellH);
        grad.addColorStop(0, css("--blackKeyB"));
        grad.addColorStop(1, css("--blackKeyA"));

        const insetLeft = 22;
        const insetRight = 20;
        g.fillStyle = grad;
        g.fillRect(insetLeft, y+2, leftPad - insetLeft - insetRight, cellH-4);
        g.strokeStyle = "rgba(255,255,255,.10)";
        g.strokeRect(insetLeft+0.5, y+2.5, leftPad - insetLeft - insetRight - 1, cellH-5);

        g.fillStyle = "rgba(255,255,255,0.80)";
        g.font = "12px ui-monospace, SFMono-Regular, Menlo, monospace";
        g.fillText(midiNameFlat(midi), insetLeft+6, y + cellH*0.68);
      }
    }

    // notes: only show notes that start on the displayed grid (masterStart divisible by factor)
    for (let p=0; p<ROLL_PITCHES; p++){
      for (let ds=0; ds<TOTAL_STEPS; ds++){
        const ms = displayToMasterStep(ds);
        const mLen = grid[p][ms];
        if (mLen <= 0) continue;

        const dLen = Math.max(1, Math.ceil(mLen / STEP_FACTOR));
        const clamped = Math.min(dLen, TOTAL_STEPS - ds);

        const x = leftPad + ds*cellW + 1;
        const y = H - (p+1)*cellH + 1;
        const w = (cellW * clamped) - 2;
        const h = cellH - 2;

        g.fillStyle = (activeRoll === "melody") ? css("--melNote") : css("--bassNote");
        g.fillRect(x,y,w,h);
        g.strokeStyle = "rgba(255,255,255,.18)";
        g.strokeRect(x+0.5,y+0.5,w-1,h-1);
      }
    }

    if (playheadDisplayStep >= 0){
      const x = leftPad + playheadDisplayStep*cellW;
      g.fillStyle = "rgba(255,255,255,.12)";
      g.fillRect(x,0,cellW,H);
    }
  }

  function rollHitTest(clientX, clientY){
    const rect = rollCanvas.getBoundingClientRect();
    const px = (clientX - rect.left) * (rollCanvas.width / rect.width);
    const py = (clientY - rect.top)  * (rollCanvas.height / rect.height);

    const W = rollCanvas.width;
    const H = rollCanvas.height;

    const leftPad = KEY_PAD;
    const cellW = (W - leftPad) / TOTAL_STEPS;
    const cellH = H / ROLL_PITCHES;

    const pitch = Math.floor((H - py) / cellH);
    if (pitch < 0 || pitch >= ROLL_PITCHES) return null;

    if (px < leftPad) return { area:"keys", pitch };

    const step = Math.floor((px - leftPad) / cellW); // display step
    if (step < 0 || step >= TOTAL_STEPS) return null;

    return { area:"grid", pitch, step };
  }

  function rangesOverlap(aStart, aLen, bStart, bLen){
    const aEnd = aStart + aLen;
    const bEnd = bStart + bLen;
    return aStart < bEnd && bStart < aEnd;
  }

  function clearOverlaps(row, start, len){
    for (let s=0; s<MASTER_STEPS; s++){
      const l = row[s];
      if (l <= 0) continue;
      if (rangesOverlap(s, l, start, len)) row[s] = 0;
    }
  }

  // Find a note that *covers* a master step (used for delete)
  function findCoveringNote(row, masterStep){
    for (let s=0; s<MASTER_STEPS; s++){
      const len = row[s];
      if (len <= 0) continue;
      if (masterStep >= s && masterStep < s + len) return {start:s, len};
    }
    return null;
  }

  function setNoteLength(grid, pitch, masterStart, masterLen){
    const row = grid[pitch];
    masterLen = Math.max(1, Math.min(masterLen, MASTER_STEPS - masterStart));
    clearOverlaps(row, masterStart, masterLen);
    row[masterStart] = masterLen;
  }

  let noteDrag = {active:false, pointerId:null, grid:null, pitch:0, dStart:0};

  rollCanvas.addEventListener("pointerdown", async (e) => {
    e.preventDefault();
    const hit = rollHitTest(e.clientX, e.clientY);
    if (!hit) return;

    const midi = ROLL_BASE_MIDI + hit.pitch;
    const grid = (activeRoll === "melody") ? melodyMaster : bassMaster;

    if (hit.area === "keys"){
      await previewMidi(midi);
      return;
    }

    const dStep = hit.step;
    const mStep = displayToMasterStep(dStep);

    const row = grid[hit.pitch];

    // delete any note covering this master step
    const existing = findCoveringNote(row, mStep);
    if (existing){
      row[existing.start] = 0;
      drawRoll(isPlaying ? currentStep : -1);
      return;
    }

    await previewMidi(midi);

    // place note aligned to displayed grid, with length in master steps
    setNoteLength(grid, hit.pitch, mStep, STEP_FACTOR);
    noteDrag = {active:true, pointerId:e.pointerId, grid, pitch:hit.pitch, dStart:dStep};
    rollCanvas.setPointerCapture(e.pointerId);

    drawRoll(isPlaying ? currentStep : -1);
  }, {passive:false});

  rollCanvas.addEventListener("pointermove", (e) => {
    if (!noteDrag.active) return;
    if (noteDrag.pointerId !== e.pointerId) return;
    e.preventDefault();

    const hit = rollHitTest(e.clientX, e.clientY);
    if (!hit || hit.area !== "grid") return;

    const dEnd = Math.max(noteDrag.dStart, Math.min(hit.step, TOTAL_STEPS - 1));
    const dLen = (dEnd - noteDrag.dStart) + 1;

    const mStart = displayToMasterStep(noteDrag.dStart);
    const mLen = dLen * STEP_FACTOR;

    setNoteLength(noteDrag.grid, noteDrag.pitch, mStart, mLen);
    drawRoll(isPlaying ? currentStep : -1);
  }, {passive:false});

  const endNoteDrag = (e) => {
    if (!noteDrag.active) return;
    if (noteDrag.pointerId !== e.pointerId) return;
    noteDrag.active = false;
    noteDrag.pointerId = null;
  };
  rollCanvas.addEventListener("pointerup", endNoteDrag);
  rollCanvas.addEventListener("pointercancel", endNoteDrag);
  rollCanvas.addEventListener("lostpointercapture", () => {
    noteDrag.active = false;
    noteDrag.pointerId = null;
  });

  // ----------------------------
  // SEQUENCER TIMING (BPM stays consistent across resolution)
  // IMPORTANT: bar length is ALWAYS 4 beats => 4*(60/bpm) seconds.
  // secondsPerDisplayStep = barDuration / TOTAL_STEPS
  // ----------------------------
  function secondsPerStep(){
    const barSeconds = 4 * (60 / bpm);
    return barSeconds / TOTAL_STEPS;
  }

  function scheduleDisplayStep(displayStep, time){
    const masterStep = displayToMasterStep(displayStep);

    // drums: trigger events at the masterStep corresponding to the displayed subdivision
    if (drumsMaster.kick[masterStep])  playKick(time);
    if (drumsMaster.snare[masterStep]) playSnare(time);
    if (drumsMaster.hat[masterStep])   playHat(time);
    if (drumsMaster.clap[masterStep])  playClap(time);

    // melody / bass: start only on aligned master step
    for (let p=0; p<ROLL_PITCHES; p++){
      const mLen = melodyMaster[p][masterStep];
      if (mLen > 0){
        const hz = midiToHz(ROLL_BASE_MIDI + p);
        const dur = (mLen / MASTER_STEPS) * (4 * (60 / bpm)) * 0.98; // exact bar-scaled duration
        playNote(hz, time, dur, melBus, "square", 0.20);
      }
    }
    for (let p=0; p<ROLL_PITCHES; p++){
      const mLen = bassMaster[p][masterStep];
      if (mLen > 0){
        const hz = midiToHz(ROLL_BASE_MIDI + p);
        const dur = (mLen / MASTER_STEPS) * (4 * (60 / bpm)) * 0.98;
        playNote(hz, time, dur, bassBus, "triangle", 0.26);
      }
    }

    updatePlayheadUI(displayStep);
    drawRoll(displayStep);
  }

  function nextStep(){
    currentStep = (currentStep + 1) % TOTAL_STEPS;
    nextNoteTime += secondsPerStep();
  }

  function tick(){
    while (nextNoteTime < ctx.currentTime + scheduleAhead){
      scheduleDisplayStep(currentStep, nextNoteTime);
      nextStep();
    }
    timerId = window.setTimeout(tick, lookAhead * 1000);
  }

  async function startFromCurrentStep(){
    await ensureRunning();
    isPlaying = true;
    isPaused = false;

    playBtn.disabled = true;
    pauseBtn.disabled = false;
    stopBtn.disabled = false;

    nextNoteTime = ctx.currentTime + 0.06;
    tick();
  }

  function pause(){
    isPaused = true;
    isPlaying = false;

    playBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = false;

    if (timerId) { clearTimeout(timerId); timerId = null; }
  }

  function stop(){
    isPlaying = false;
    isPaused = false;

    playBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;

    if (timerId) { clearTimeout(timerId); timerId = null; }

    currentStep = 0;
    updatePlayheadUI(-1);
    drawRoll(-1);
  }

  function togglePlayPause(){
    if (!ctx && !isPlaying && !isPaused){ startFromCurrentStep(); return; }
    if (isPlaying) pause();
    else startFromCurrentStep();
  }

  playBtn.addEventListener("click", () => { currentStep = 0; startFromCurrentStep(); });
  pauseBtn.addEventListener("click", pause);
  stopBtn.addEventListener("click", stop);

  // ----------------------------
  // CLEAR / DEMO (operate on MASTER arrays)
  // ----------------------------
  clearDrumsBtn.addEventListener("click", () => {
    drumKeys.forEach(k => drumsMaster[k].fill(false));
    refreshDrumUI();
  });

  clearNotesBtn.addEventListener("click", () => {
    melodyMaster.forEach(row => row.fill(0));
    bassMaster.forEach(row => row.fill(0));
    drawRoll(isPlaying ? currentStep : -1);
  });

  demoFillBtn.addEventListener("click", () => {
    drumKeys.forEach(k => drumsMaster[k].fill(false));
    melodyMaster.forEach(r => r.fill(0));
    bassMaster.forEach(r => r.fill(0));

    // Example groove aligned to the master grid:
    // Kick on beats 1,2,3,4 => master steps 0,16,32,48
    drumsMaster.kick[0] = true;
    drumsMaster.kick[16] = true;
    drumsMaster.kick[32] = true;
    drumsMaster.kick[48] = true;

    // Snare on 2 & 4 => 16,48
    drumsMaster.snare[16] = true;
    drumsMaster.snare[48] = true;

    // Hats on 8th notes => every 8 master steps
    for (let s=0; s<MASTER_STEPS; s+=8) drumsMaster.hat[s] = true;

    // Notes: C4 phrase aligned to master
    const putMel = (mStart, midi, mLen) => {
      const p = midi - ROLL_BASE_MIDI;
      if (p>=0 && p<ROLL_PITCHES) setNoteLength(melodyMaster, p, mStart, mLen);
    };
    const putBass = (mStart, midi, mLen) => {
      const p = midi - ROLL_BASE_MIDI;
      if (p>=0 && p<ROLL_PITCHES) setNoteLength(bassMaster, p, mStart, mLen);
    };

    putMel(0, 60, 8);    // C4 (8/64 bar)
    putMel(8, 62, 8);    // D4
    putMel(16,64, 4);    // E4
    putMel(20,67, 8);    // G4
    putMel(32,69, 8);    // A4
    putMel(48,67, 12);   // G4

    putBass(0, 48, 32);  // C3 sustain half bar

    refreshDrumUI();
    drawRoll(isPlaying ? currentStep : -1);
  });

  // ----------------------------
  // RESOLUTION CHANGE (3 options; BPM stays the same)
  // ----------------------------
  resEl.addEventListener("input", () => {
    const opt = RES_OPTIONS[Number(resEl.value)];
    applyResolution(opt.stepsPerBar, opt.label);
  });

  function applyResolution(newStepsPerBar, label){
    stop(); // stop transport only (patterns remain)

    stepsPerBar = newStepsPerBar;
    updateStepFactor();

    resLabel.textContent = label;
    resText.textContent = label;
    groupText.textContent = label;

    buildDrumGrid();
    drawRoll(-1);
  }

  // ----------------------------
  // INIT
  // ----------------------------
  bpmLabel.textContent = bpmEl.value;

  // default slider value 0 => 1/16
  const initialOpt = RES_OPTIONS[Number(resEl.value)];
  resLabel.textContent = initialOpt.label;
  resText.textContent = initialOpt.label;
  groupText.textContent = initialOpt.label;

  stepsPerBar = initialOpt.stepsPerBar;
  updateStepFactor();

  buildDrumGrid();
  drawRoll(-1);

})();
</script>
</body>
</html>
